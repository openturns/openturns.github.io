
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_using_otagrum.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_using_otagrum.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_using_otagrum.py:


Using otagrum
=============

.. GENERATED FROM PYTHON SOURCE LINES 7-12

.. code-block:: Python

    import openturns as ot
    import pyAgrum as gum
    from matplotlib import pylab as plt
    import otagrum








.. GENERATED FROM PYTHON SOURCE LINES 13-35

.. code-block:: Python



    def showDot(dotstring):
        try:
            # fails outside notebook
            import pyAgrum.lib.notebook as gnb

            gnb.showDot(dotstring)
        except ImportError:
            import pydot
            from io import BytesIO

            graph = pydot.graph_from_dot_data(dotstring)[0]
            with BytesIO() as f:
                f.write(graph.create_png())
                f.seek(0)
                img = plt.imread(f)
            fig = plt.imshow(img)
            fig.axes.axis("off")
            plt.show()









.. GENERATED FROM PYTHON SOURCE LINES 36-40

Creating the CBN structure
We begin by creating the CBN that will be used throughout this example.

To do so, we need a NamedDAG structure...

.. GENERATED FROM PYTHON SOURCE LINES 42-44

.. code-block:: Python

    dag = gum.DAG()








.. GENERATED FROM PYTHON SOURCE LINES 45-51

.. code-block:: Python

    mapping = {}
    mapping["A"] = dag.addNode()  # Add node A
    mapping["B"] = dag.addNode()  # Add node B
    mapping["C"] = dag.addNode()  # Add node C
    mapping["D"] = dag.addNode()  # Add node D








.. GENERATED FROM PYTHON SOURCE LINES 52-57

.. code-block:: Python

    dag.addArc(mapping["A"], mapping["C"])  # Arc A -> C
    dag.addArc(mapping["B"], mapping["C"])  # Arc B -> C
    dag.addArc(mapping["C"], mapping["D"])  # Arc C -> D









.. GENERATED FROM PYTHON SOURCE LINES 58-61

.. code-block:: Python

    dag






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (pyAgrum.DAG@0x55858af5ccc0) {0,1,2,3} , {2->3,0->2,1->2}



.. GENERATED FROM PYTHON SOURCE LINES 62-65

.. code-block:: Python

    structure = otagrum.NamedDAG(dag, list(mapping.keys()))









.. GENERATED FROM PYTHON SOURCE LINES 66-69

.. code-block:: Python

    showDot(structure.toDot())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <IPython.core.display.SVG object>




.. GENERATED FROM PYTHON SOURCE LINES 70-71

Parameters of the CBN ... and a collection of marginals and local conditional copulas.

.. GENERATED FROM PYTHON SOURCE LINES 73-84

.. code-block:: Python

    m_list = [ot.Uniform(0.0, 1.0) for i in range(structure.getSize())]  # Local marginals
    lcc_list = []  # Local Conditional Copulas
    for i in range(structure.getSize()):
        dim_lcc = structure.getParents(i).getSize() + 1
        R = ot.CorrelationMatrix(dim_lcc)
        for j in range(dim_lcc):
            for k in range(j):
                R[j, k] = 0.6
        lcc_list.append(ot.Normal([0.0] * dim_lcc, [1.0] * dim_lcc, R).getCopula())









.. GENERATED FROM PYTHON SOURCE LINES 85-87

Now that we have a NamedDAG structure and a collection of local conditional
copulas, we can construct a CBN.

.. GENERATED FROM PYTHON SOURCE LINES 89-91

.. code-block:: Python

    cbn = otagrum.ContinuousBayesianNetwork(structure, m_list, lcc_list)








.. GENERATED FROM PYTHON SOURCE LINES 92-93

Having a CBN, we can now sample from it.

.. GENERATED FROM PYTHON SOURCE LINES 95-101

.. code-block:: Python

    ot.RandomGenerator.SetSeed(10)  # Set random seed
    sample = cbn.getSample(1000)
    train = sample[:-100]
    test = sample[-100:]









.. GENERATED FROM PYTHON SOURCE LINES 102-104

Learning the structure with continuous PC:
Now that we have data, we can use it to learn the structure with the continuous PC algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 106-108

.. code-block:: Python

    learner = otagrum.ContinuousPC(sample, 5, 0.1)








.. GENERATED FROM PYTHON SOURCE LINES 109-110

We first learn the skeleton, that is the undirected structure.

.. GENERATED FROM PYTHON SOURCE LINES 112-115

.. code-block:: Python

    skeleton = learner.learnSkeleton()









.. GENERATED FROM PYTHON SOURCE LINES 116-118

.. code-block:: Python

    skeleton





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (pyAgrum.UndiGraph@0x55858ae7db20) {0,1,2,3} , {2--3,0--2,1--2}



.. GENERATED FROM PYTHON SOURCE LINES 119-120

Then we look for the v-structures, leading to a Partially Directed Acyclic Graph (PDAG)

.. GENERATED FROM PYTHON SOURCE LINES 122-125

.. code-block:: Python

    pdag = learner.learnPDAG()









.. GENERATED FROM PYTHON SOURCE LINES 126-128

.. code-block:: Python

    pdag





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (pyAgrum.MixedGraph@0x55858a18bd30) {0,1,2,3} , {1->2,0->2} , {2--3}



.. GENERATED FROM PYTHON SOURCE LINES 129-130

Finally, the remaining edges are oriented by propagating constraints

.. GENERATED FROM PYTHON SOURCE LINES 132-135

.. code-block:: Python

    ndag = learner.learnDAG()









.. GENERATED FROM PYTHON SOURCE LINES 136-138

.. code-block:: Python

    showDot(ndag.toDot())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <IPython.core.display.SVG object>




.. GENERATED FROM PYTHON SOURCE LINES 139-142

The true structure has been recovered.
Learning with continuous MIIC
Otagrum provides another learning algorithm to learn the structure: the continuous MIIC algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 144-146

.. code-block:: Python

    learner = otagrum.ContinuousMIIC(sample)








.. GENERATED FROM PYTHON SOURCE LINES 147-156

This algorithm relies on the computing of mutual information which is done
through the copula function. Hence, a copula model for the data is needed.
The continuous MIIC algorithm can make use of Gaussian copulas (parametric)
or Bernstein copulas (non-parametric) to compute mutual information.
Moreover, due to finite sampling size, the mutual information estimators
need to be corrected.
Two kind of correction are provided: NoCorr (no correction) or Naive
(a fixed correction is subtracted from the raw mutual information
estimators). Those behaviours can be changed as follows:

.. GENERATED FROM PYTHON SOURCE LINES 158-159

learner.setCMode(otagrum.CorrectedMutualInformation.CModeTypes_Bernstein) # By default

.. GENERATED FROM PYTHON SOURCE LINES 159-168

.. code-block:: Python

    learner.setCMode(
        otagrum.CorrectedMutualInformation.CModeTypes_Gaussian
    )  # To use Gaussian copulas
    learner.setKMode(otagrum.CorrectedMutualInformation.KModeTypes_Naive)  # By default
    # learner.setKMode(otagrum.CorrectedMutualInformation.KModeTypes_NoCorr) # To use the raw estimators
    learner.setAlpha(
        0.01
    )  # Set the correction value for the Naive behaviour, it is set to 0.01 by default








.. GENERATED FROM PYTHON SOURCE LINES 169-170

As with PC algorithm we can learn the skeleton, PDAG and DAG using

.. GENERATED FROM PYTHON SOURCE LINES 172-175

.. code-block:: Python

    skeleton = learner.learnSkeleton()









.. GENERATED FROM PYTHON SOURCE LINES 176-179

.. code-block:: Python

    skeleton






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (pyAgrum.UndiGraph@0x558589d460b0) {0,1,2,3} , {2--3,0--2,1--2}



.. GENERATED FROM PYTHON SOURCE LINES 180-183

.. code-block:: Python

    pdag = learner.learnPDAG()









.. GENERATED FROM PYTHON SOURCE LINES 184-187

.. code-block:: Python

    pdag






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (pyAgrum.MixedGraph@0x55858afdc4d0) {0,1,2,3} , {2->3,1->2,0->2} , {}



.. GENERATED FROM PYTHON SOURCE LINES 188-191

.. code-block:: Python

    dag = learner.learnDAG()









.. GENERATED FROM PYTHON SOURCE LINES 192-194

.. code-block:: Python

    showDot(dag.toDot())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    <IPython.core.display.SVG object>




.. GENERATED FROM PYTHON SOURCE LINES 195-197

Learning parameters
Bernstein copulas are used to learn the local conditional copulas associated to each node

.. GENERATED FROM PYTHON SOURCE LINES 199-214

.. code-block:: Python

    m_list = []
    lcc_list = []
    for i in range(train.getDimension()):
        m_list.append(ot.UniformFactory().build(train.getMarginal(i)))
        indices = [i] + [int(n) for n in ndag.getParents(i)]
        dim_lcc = len(indices)
        if dim_lcc == 1:
            bernsteinCopula = ot.IndependentCopula(1)
        elif dim_lcc > 1:
            K = otagrum.ContinuousTTest.GetK(len(train), dim_lcc)
            bernsteinCopula = ot.EmpiricalBernsteinCopula(
                train.getMarginal(indices), K, False
            )
        lcc_list.append(bernsteinCopula)








.. GENERATED FROM PYTHON SOURCE LINES 215-216

We can now create the learned CBN

.. GENERATED FROM PYTHON SOURCE LINES 218-220

.. code-block:: Python

    lcbn = otagrum.ContinuousBayesianNetwork(ndag, m_list, lcc_list)  # Learned CBN








.. GENERATED FROM PYTHON SOURCE LINES 221-222

And compare the mean loglikelihood between the true and the learned models

.. GENERATED FROM PYTHON SOURCE LINES 224-234

.. code-block:: Python



    def compute_mean_LL(cbn, test):
        ll = 0
        for t in test:
            ll += cbn.computeLogPDF(t)
        ll /= len(test)
        return ll









.. GENERATED FROM PYTHON SOURCE LINES 235-239

.. code-block:: Python

    true_LL = compute_mean_LL(cbn, test)
    print(true_LL)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0.31620906143480526




.. GENERATED FROM PYTHON SOURCE LINES 240-242

.. code-block:: Python

    exp_LL = compute_mean_LL(lcbn, test)
    print(exp_LL)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0.15241697100666607





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.218 seconds)


.. _sphx_glr_download_auto_examples_plot_using_otagrum.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_using_otagrum.ipynb <plot_using_otagrum.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_using_otagrum.py <plot_using_otagrum.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
