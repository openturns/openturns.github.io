
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Linear Regression with interval-censored observations &#8212; OpenTURNS 1.20rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/openturns.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/mysearchtools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Numerical methods" href="../../auto_numerical_methods/index.html" />
    <link rel="prev" title="Customize your Metropolis-Hastings algorithm" href="plot_ackley_distribution.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="http://www.openturns.org/">Home</a></li>
    <li><a href="../../install.html">Get it</a></li>
    <li><a href="../../contents.html">Doc</a></li>
    <li><a href="https://openturns.discourse.group/">Forum</a></li>
    <li><a href="https://gitter.im/openturns/community">Chat</a></li>
    <li><a href="https://github.com/openturns/openturns/wiki/Modules">Modules</a></li>
    <li><a href="https://github.com/openturns">Code</a></li>
    <li><a href="https://github.com/openturns/openturns/issues">Bugs</a></li>
  </ul>
  <a href="../../index.html">
    <h1>
      <img src="../../_static/logo-openturns-wo-bg.png" alt="" width=100px height=100px />
      OpenTURNS
    </h1>
    <h2> An Open source initiative for the Treatment of Uncertainties, Risks'N Statistics</h2>
  </a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../auto_numerical_methods/index.html" title="Numerical methods"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="plot_ackley_distribution.html" title="Customize your Metropolis-Hastings algorithm"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">OpenTURNS 1.20rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../contents.html" >Contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../examples/examples.html" >Examples</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >Calibration</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" accesskey="U">Bayesian calibration</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Linear Regression with interval-censored observations</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../../index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Linear Regression with interval-censored observations</a><ul>
<li><a class="reference internal" href="#model-formulation">1. Model formulation</a><ul>
<li><a class="reference internal" href="#likelihood-of-the-linear-regression-model">1.1. Likelihood of the linear regression model</a></li>
<li><a class="reference internal" href="#interval-censorship">1.2. Interval Censorship</a></li>
<li><a class="reference internal" href="#remarks">1.3. Remarks</a></li>
<li><a class="reference internal" href="#simulate-the-dataset">1.4 Simulate the dataset</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bayesian-inference">2. Bayesian Inference</a><ul>
<li><a class="reference internal" href="#choice-of-a-prior-law">2.1. Choice of a prior law</a></li>
<li><a class="reference internal" href="#posterior-sampling">2.2. Posterior sampling</a><ul>
<li><a class="reference internal" href="#updating-vect-y">2.2.1. Updating <img class="math" src="../../_images/math/f226966057cd198bc5b8e728a3f9b629b5f15b2f.svg" alt="\vect{Y}"/></a></li>
<li><a class="reference internal" href="#updating-vect-theta">2.2.2. Updating <img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/></a></li>
<li><a class="reference internal" href="#updating-tau">2.2.3. Updating <img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/></a></li>
</ul>
</li>
<li><a class="reference internal" href="#initialization">2.3. Initialization</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="plot_ackley_distribution.html"
                          title="previous chapter">Customize your Metropolis-Hastings algorithm</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="../../auto_numerical_methods/index.html"
                          title="next chapter">Numerical methods</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/auto_calibration/bayesian_calibration/plot_gibbs_simus.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-auto-calibration-bayesian-calibration-plot-gibbs-simus-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="linear-regression-with-interval-censored-observations">
<span id="sphx-glr-auto-calibration-bayesian-calibration-plot-gibbs-simus-py"></span><h1>Linear Regression with interval-censored observations<a class="headerlink" href="#linear-regression-with-interval-censored-observations" title="Permalink to this heading">¶</a></h1>
<section id="model-formulation">
<h2>1. Model formulation<a class="headerlink" href="#model-formulation" title="Permalink to this heading">¶</a></h2>
<p>We consider the following linear model:</p>
<div class="math">
<p><img src="../../_images/math/177bc4b35151f20cf3b1d3827a28c63018bf0127.svg" alt="\vect{Y} = \mat{X} \vect{\theta} + \vect{\varepsilon},"/></p>
</div><p>where the observation vector <img class="math" src="../../_images/math/b8e5b462c891c134f94db006c6f526d63c59c5ca.svg" alt="\vect{Y} \in \mathbb R^{n}"/> is modeled as
the sum of:</p>
<ul class="simple">
<li><p>a linear part, with an <img class="math" src="../../_images/math/841680dfcba7d24240cf9cb16804f49b21515fc2.svg" alt="n \times p"/> design matrix <img class="math" src="../../_images/math/8a86dc197d7fe23de541382c33b8371348192767.svg" alt="\mat{X}"/>
and unknown regression coefficients <img class="math" src="../../_images/math/994e09b648250886c63d09da2770c1cd14502916.svg" alt="\vect{\theta} \in\mathbb R^p"/>,</p></li>
<li><p>a Gaussian error term
<img class="math" src="../../_images/math/cf362ed524d906950e1e681a76486b48d8a36e5a.svg" alt="\vect{\varepsilon} \sim \mathcal N_n(\vect{0}, \tau^{-1} \mat{I}_n+\mat{Q}^{-1})"/>,</p></li>
</ul>
<p>where <img class="math" src="../../_images/math/3ef8288fc1ce7d9ace66f65978269a235e11f1f1.svg" alt="\mat{Q}"/> represents a known <em>precision</em> (inverse variance) matrix
for measurement errors,
and <img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/> an unknown precision parameter
quantifying the variability of the observed phenomenon.</p>
<section id="likelihood-of-the-linear-regression-model">
<h3>1.1. Likelihood of the linear regression model<a class="headerlink" href="#likelihood-of-the-linear-regression-model" title="Permalink to this heading">¶</a></h3>
<p>The above linear regression model can thus be written:</p>
<div class="math">
<p><img src="../../_images/math/f42d56bf4a553b6a79078c32ae2af9532198d210.svg" alt="\vect{Y} | \vect{\theta}, \tau
{\sim} \mathcal N_{n}(\mat{X} \vect{\theta} ; \tau^{-1} \mat{I}_n +\mat{Q}^{-1}),"/></p>
</div><p>We then have the following likelihood:</p>
<div class="math">
<p><img src="../../_images/math/65e550e540fe448483d092e74a1e0a3467009c11.svg" alt="\mathcal L(\vect{Y}|\vect{\theta}, \tau) =
(2\pi)^{-\frac{n}{2}}
{\rm det}(\tau^{-1} \mat{I}_n+\mat{Q}^{-1})^{-\frac{1}{2}}
e^{-\frac{1}{2}
||\vect{Y} - \mat{X} \vect{\theta} ||_{\tau^{-1} \mat{I}_n +\mat{Q}^{-1}}^2
}"/></p>
</div><p>where <img class="math" src="../../_images/math/f1d0432dcbee82fdc687fcb8d9aa7cd33ddd748d.svg" alt="||\vect{X}-\vect{Y}||_{\mat{V}}^2"/> is the Mahalanobis distance between
<img class="math" src="../../_images/math/2bcbd5b2b78ef65f3c1a1987095a65863870aa77.svg" alt="\vect{X}"/> and <img class="math" src="../../_images/math/f226966057cd198bc5b8e728a3f9b629b5f15b2f.svg" alt="\vect{Y}"/> with covariance matrice <img class="math" src="../../_images/math/2d473235fd0c9ea9cf48a51e6ab7148e7acdc735.svg" alt="\mat{V}"/>:</p>
<div class="math">
<p><img src="../../_images/math/a3d097ad5198ddfc1242f35edfe91dee87d49cca.svg" alt="||\vect{X}-\vect{Y}||_{\mat{V}}^2 = (\vect{X}-\vect{Y})^\top\ \mat{V}^{-1}\ (\vect{X}-\vect{Y})."/></p>
</div></section>
<section id="interval-censorship">
<h3>1.2. Interval Censorship<a class="headerlink" href="#interval-censorship" title="Permalink to this heading">¶</a></h3>
<p>We now assume that, instead of observing directly the
<img class="math" src="../../_images/math/7c9f077eb9e2cc11354b14e4282c0f1d16ceac49.svg" alt="Y_i, i=1,\ldots,n"/> as described above, we only have access to
discretized values <img class="math" src="../../_images/math/1e3071f1ab821f3934654d73147edc4748697297.svg" alt="Y_i^{obs} \in \delta \times \mathbb N"/>, where
<img class="math" src="../../_images/math/57d91f215264295a97eb54cb72bdd8aeee86d24f.svg" alt="\delta &gt; 0"/> is a grid length and <img class="math" src="../../_images/math/6257cb85aab49d85e64e4d020d7c6a3251d14bd7.svg" alt="Y_i^{obs} = \delta \times k"/> means that
<img class="math" src="../../_images/math/fe8ca569eb1053fc1fade2293ccd6187b3e18ce8.svg" alt="Y_i \in \delta \times \left[ k - \frac{1}{2}; k + \frac{1}{2} \right["/>.</p>
</section>
<section id="remarks">
<h3>1.3. Remarks<a class="headerlink" href="#remarks" title="Permalink to this heading">¶</a></h3>
<ul class="simple">
<li><p>The presence of a composite matrix <img class="math" src="../../_images/math/ed37d52fbe0f393c3da029fad79a1afd6ee1dbbe.svg" alt="\tau^{-1} \mat{I}_n+\mat{Q}^{-1}"/> makes
estimation more complex than with a spherical one
<img class="math" src="../../_images/math/6aebf5ba6451f82b97da4f800eecc2c084b33841.svg" alt="\tau^{-1}\mat{I}_n,"/> since we would then have explicit (closed-form)
maximum likelihood estimators, and also conjugate priors leading to
explicit full joint posterior distributions.</p></li>
<li><p>Another difficulty is the presence of censored data, since the
likelihood is no more available in closed-form. As we will see, this
can be overcome thanks to Bayesian inference.</p></li>
<li><p>Heteroscedastic linear modeling under interval censorship as
formulated above was originally motivated by an industrial case-study
in seismology, wherein the <img class="math" src="../../_images/math/dd9086c07744a030302ce95caec8869005b54a89.svg" alt="Y_i"/> correspond to the observed
intensity of an earthquake in a distant site, and explanatory
variables <img class="math" src="../../_images/math/89c3aecc821e5dbbc0061bd198bfeab8d5adb4a9.svg" alt="\vect{X}_{i}"/> are derived from the epicentral distance to the
earthquake’s source as well as its characteristics (magnitude,
depth). But it can also arise in many different contexts, as soon as
observations are available with known statistical precisions (hence
the heteroscedasticity) and limited numerical accuracy (hence the
censorship).</p></li>
</ul>
</section>
<section id="simulate-the-dataset">
<h3>1.4 Simulate the dataset<a class="headerlink" href="#simulate-the-dataset" title="Permalink to this heading">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openturns</span> <span class="k">as</span> <span class="nn">ot</span>
<span class="kn">from</span> <span class="nn">openturns.viewer</span> <span class="kn">import</span> <span class="n">View</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">ot</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">Show</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">Log</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
<span class="n">ot</span><span class="o">.</span><span class="n">RandomGenerator</span><span class="o">.</span><span class="n">SetSeed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">delta</span> <span class="o">=</span> <span class="mf">0.5</span>
</pre></div>
</div>
<p>Build the design matrix <img class="math" src="../../_images/math/8a86dc197d7fe23de541382c33b8371348192767.svg" alt="\mat{X}"/></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Sample</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
<span class="n">X</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span><span class="o">.</span><span class="n">getSample</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>Make the precision matrix <img class="math" src="../../_images/math/3ef8288fc1ce7d9ace66f65978269a235e11f1f1.svg" alt="\mat{Q}"/> a diagonal matrix and sample
its diagonal coefficients from an <a class="reference internal" href="../../user_manual/_generated/openturns.Exponential.html#openturns.Exponential" title="openturns.Exponential"><code class="xref py py-class docutils literal notranslate"><span class="pre">Exponential</span></code></a> distribution.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">ot</span><span class="o">.</span><span class="n">Exponential</span><span class="p">()</span><span class="o">.</span><span class="n">getSample</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>Choose values for the parameters <img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/> and <img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">theta_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]])</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">theta_true</span><span class="p">)</span>
<span class="n">tau_true</span> <span class="o">=</span> <span class="mf">0.1</span>
</pre></div>
</div>
<p>First sample uncensored, and then censored observation data.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mean_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">theta_true</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">std_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">tau_true</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

<span class="n">Y_sim</span> <span class="o">=</span> <span class="n">mean_true</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">()</span><span class="o">.</span><span class="n">getSample</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">*</span> <span class="n">std_true</span>
<span class="n">Yobs_sim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">Y_sim</span> <span class="o">/</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta</span>
</pre></div>
</div>
<p>Plot the simulated dataset.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">graph</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;Simulated data&quot;</span><span class="p">,</span> <span class="s2">&quot;$X_1$&quot;</span><span class="p">,</span> <span class="s2">&quot;$Y$&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;topleft&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
<span class="n">cloud_obs</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asPoint</span><span class="p">(),</span> <span class="n">Yobs_sim</span><span class="p">)</span>
<span class="n">cloud_obs</span><span class="o">.</span><span class="n">setPointStyle</span><span class="p">(</span><span class="s2">&quot;bullet&quot;</span><span class="p">)</span>
<span class="n">cloud_sim</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asPoint</span><span class="p">(),</span> <span class="n">Y_sim</span><span class="p">)</span>
<span class="n">cloud_sim</span><span class="o">.</span><span class="n">setPointStyle</span><span class="p">(</span><span class="s2">&quot;bullet&quot;</span><span class="p">)</span>
<span class="n">curve</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">asPoint</span><span class="p">(),</span> <span class="n">mean_true</span><span class="p">)</span>
<span class="n">curve</span><span class="o">.</span><span class="n">setLineWidth</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curve</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cloud_sim</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cloud_obs</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">setLegends</span><span class="p">([</span><span class="s2">&quot;Trend&quot;</span><span class="p">,</span> <span class="s2">&quot;$Y^</span><span class="si">{sim}</span><span class="s2">$&quot;</span><span class="p">,</span> <span class="s2">&quot;$Y^</span><span class="si">{obs}</span><span class="s2">$&quot;</span><span class="p">])</span>
<span class="n">graph</span><span class="o">.</span><span class="n">setColors</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">Drawable</span><span class="o">.</span><span class="n">BuildDefaultPalette</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_gibbs_simus_001.png" srcset="../../_images/sphx_glr_plot_gibbs_simus_001.png" alt="Simulated data" class = "sphx-glr-single-img"/></section>
</section>
<section id="bayesian-inference">
<h2>2. Bayesian Inference<a class="headerlink" href="#bayesian-inference" title="Permalink to this heading">¶</a></h2>
<section id="choice-of-a-prior-law">
<h3>2.1. Choice of a prior law<a class="headerlink" href="#choice-of-a-prior-law" title="Permalink to this heading">¶</a></h3>
<p>We use the standard Normal-Gamma prior for <img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/> and
<img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/>:</p>
<div class="math">
<p><img src="../../_images/math/4f50d8c8915105c0f89457f790d54f9d696e06b0.svg" alt="\vect{\theta} | \tau \sim \mathcal N_{p}(\vect{\mu}_0; \tau^{-1}\mat{\Sigma}_0) \\
\tau \sim \mathcal G(a_0, b_0),"/></p>
</div><p>where all parameters are assumed <em>a priori</em> independent if not stated
otherwise.</p>
<p>Furthermore, a default choice for the hyperparameters consists in having
all prior variances go to infinity, equivalent to the degenerate case:</p>
<div class="math">
<p><img src="../../_images/math/3c273bbe17661ed4c9ecb6d7aa6e73e7394e6b5e.svg" alt="\vect{\mu}_0, \mat{\Sigma}_0^{-1}, a_0, b_0 \equiv 0"/></p>
</div><p>But the resulting prior is improper. Hence, posterior propriety needs to
be proven first.</p>
<p>A simpler solution is to ensure prior (hence posterior) propriety by
imposing bounds <img class="math" src="../../_images/math/28aaef5c9a8a5790375049e97b0e6176610a088f.svg" alt="\vect{\theta}_{\min}, \vect{\theta}_{\max}, \tau_{\min}, \tau_{\max}"/>
on all parameters following:</p>
<div class="math">
<p><img src="../../_images/math/c5e35a543e297ec4dae0d61ad651fb88ac5a6993.svg" alt="\vect{\theta} | \tau \sim \mathcal N_{p}(\vect{\mu}_0; \tau^{-1}\mat{\Sigma}_0) {\bf 1}_{\{\vect{\theta}_{\min} \leq \vect{\theta} \leq \vect{\theta}_{\max}\}} ;\\
\tau \sim \mathcal G(a_0, b_0){\bf 1}_{\{\tau_{\min} \leq \tau \leq \tau_{\max}\}},"/></p>
</div><p>where inequalites are taken componentwise. When all hyperparameters go to
<img class="math" src="../../_images/math/919aee1dbe276bb63ee7a88b62487eea3957e41e.svg" alt="0"/> as described above, the prior converges to a product of
uniform distributions.</p>
<p>We will use this product of univariate uniforms as a prior in the
following. As discussed above, there is no simple way to obtain the
posterior distribution, justifying the use of Monte-Carlo Markov chain
techniques, as described hereafter.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">lower</span> <span class="o">=</span> <span class="p">(</span><span class="n">Yobs_sim</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">-</span> <span class="n">delta</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">upper</span> <span class="o">=</span> <span class="p">(</span><span class="n">Yobs_sim</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

<span class="c1"># Global support of the joint distribution: theta, tau, outputs</span>
<span class="n">support</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">([</span><span class="o">-</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1e-4</span><span class="p">]</span> <span class="o">+</span> <span class="n">lower</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1e1</span><span class="p">]</span> <span class="o">+</span> <span class="n">upper</span><span class="p">)</span>

<span class="n">prior</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">ComposedDistribution</span><span class="p">(</span>
    <span class="p">[</span><span class="n">ot</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span> <span class="n">ot</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">),</span> <span class="n">ot</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">1e-4</span><span class="p">,</span> <span class="mf">1e1</span><span class="p">)]</span>
<span class="p">)</span>

<span class="c1"># Initialize to true value</span>
<span class="n">initial_state</span> <span class="o">=</span> <span class="n">theta_true</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="n">tau_true</span><span class="p">]</span> <span class="o">+</span> <span class="n">Y_sim</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">initial_state</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="posterior-sampling">
<h3>2.2. Posterior sampling<a class="headerlink" href="#posterior-sampling" title="Permalink to this heading">¶</a></h3>
<p>The solution we advocate consists in sampling from the joint posterior
distribution of all uncertain parameters, including the vector of
continuous intensities <img class="math" src="../../_images/math/799a36060c2b7a0826115f0170735d6f39ac02bc.svg" alt="\vect{Y},"/> seen here as a latent variable.
Indeed, adding <img class="math" src="../../_images/math/f226966057cd198bc5b8e728a3f9b629b5f15b2f.svg" alt="\vect{Y}"/> to the vector of sampled variables yields a
posterior density which is available in closed form, up to an unkown
multiplicative factor</p>
<div class="math">
<p><img src="../../_images/math/6de340b8f082cdbdd23af58ffe3019ba6d8d8edb.svg" alt="\begin{array}{ll}
\pi(\vect{Y},\vect{\theta},\tau|\vect{Y}^{obs})
    &amp; \propto \pi(\vect{\theta},\tau)\times\mathcal L(\vect{Y}|\vect{\theta},\tau)\mathcal L(\vect{Y}^{obs}|\vect{Y})\\
    &amp; \propto
    {\bf 1}_{\{\vect{\theta}_{\min} \leq \vect{\theta} \leq \vect{\theta}_{\max}\}}\times
    {\bf 1}_{\{\tau_{\min} \leq \tau \leq \tau_{\max}\}}\times
    \mathcal N_n (\vect{Y}|\mat{X} \vect{\theta};\tau^{-1} \mat{I}_n + \mat{Q}^{-1}) \times
    {\bf 1}_{\left[\vect{Y}^{obs}-\frac{\delta}{2}; \vect{Y}^{obs}+\frac{\delta}{2}\right[}(\vect{Y}).
    \end{array}"/></p>
</div><p>This allows to perform the following Metropolis within Gibbs sampling
scheme, wherein the pre-defined blocks of variables
<img class="math" src="../../_images/math/bfe21b2992718de1427ca336744cac11fe2e6e03.svg" alt="(\vect{Y},\vect{\theta},\tau)"/> are updated in turn, according to their
conditional posterior density, or to a Markov kernel targeting it, as
described in the following.</p>
<section id="updating-vect-y">
<h4>2.2.1. Updating <img class="math" src="../../_images/math/f226966057cd198bc5b8e728a3f9b629b5f15b2f.svg" alt="\vect{Y}"/><a class="headerlink" href="#updating-vect-y" title="Permalink to this heading">¶</a></h4>
<p><img class="math" src="../../_images/math/39a37eccd816f6ef2f05396ae52868366acc1cf8.svg" alt="\pi(\vect{Y}|\vect{\theta},\tau,\vect{Y}^{obs})\propto\prod_{i=1}^{n}\mathcal N(Y_{i}|\vect{X}_{i} \vect{\theta}, \tau^{-1}+q_{i}^{-1}) {\bf 1}_{\left[Y_{i}^{obs}-\frac{\delta}{2}; Y_{i}^{obs}+\frac{\delta}{2}\right[}(Y_{i})"/>,
hence the latent variables <img class="math" src="../../_images/math/dd9086c07744a030302ce95caec8869005b54a89.svg" alt="Y_i"/> are updated by simply simulating
independent univariate truncated normals.</p>
<p>Step 1 : Create associated <a class="reference internal" href="../../user_manual/_generated/openturns.RandomVector.html#openturns.RandomVector" title="openturns.RandomVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomVector</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">marginals_trunc</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">ot</span><span class="o">.</span><span class="n">TruncatedNormal</span><span class="p">(</span><span class="n">Yobs_sim</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">lower</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">upper</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
<span class="p">]</span>

<span class="n">trunc_cond_Y</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">ComposedDistribution</span><span class="p">(</span><span class="n">marginals_trunc</span><span class="p">)</span>
<span class="n">RV_Y</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">RandomVector</span><span class="p">(</span><span class="n">trunc_cond_Y</span><span class="p">)</span>
</pre></div>
</div>
<p>Step 2 : Link function, giving the parameters of the univariate truncated normals in function of the chain’s current state</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">gen_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trunc_cond_Y</span><span class="o">.</span><span class="n">getParameter</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">py_link_function_y</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    link function for Y conditional density</span>

<span class="sd">    Input</span>
<span class="sd">        x: vector with length (p + 1 + n), containing the current state of (theta, tau, Y)</span>

<span class="sd">    Output</span>
<span class="sd">        params: vector with length 4*n, corresponding to mean, std, a and b, for each component of Y</span>

<span class="sd">    Notes</span>
<span class="sd">        a and b represent the upper and lower bounds for the truncated normals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="c1"># compute conditional mean and standard deviates</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">tau</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Q</span><span class="p">)</span>
    <span class="c1"># inject values in blueprint</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">gen_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">params</span><span class="p">[::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>
    <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">params</span>
</pre></div>
</div>
</section>
<section id="updating-vect-theta">
<h4>2.2.2. Updating <img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/><a class="headerlink" href="#updating-vect-theta" title="Permalink to this heading">¶</a></h4>
<p><img class="math" src="../../_images/math/8be8c9d3a57fa0924e3e26501094e8e027c37883.svg" alt="\pi(\vect{\theta}|\vect{Y}, \tau, \vect{Y}^{obs})=\pi(\vect{\theta}|\vect{Y},\tau)."/> Due to the
partial conjugacy of the conditional prior <img class="math" src="../../_images/math/1dc30bdb3c826bae7c9b29cd00a191811cdbe01b.svg" alt="\pi(\vect{\theta}|\tau),"/>
this is explicit, and given by the following box-constrained
multivariate normal:</p>
<div class="math">
<p><img src="../../_images/math/98f499d334f04ebbc703e9326d749544ecae4182.svg" alt="\vect{\theta}|\vect{Y},\tau \sim \mathcal N_4( \vect{\mu}_n ; \mat{\Sigma}_n ){\bf 1}_{\{\vect{\theta}_{\min} \leq \vect{\theta} \leq \vect{\theta}_{\max}\}},"/></p>
</div><p>with</p>
<div class="math">
<p><img src="../../_images/math/4b5f5d100184cecb65edcd37ae0bf4c526c31c22.svg" alt="\vect{\mu}_n = \vect{\mu}_0 + \mat{\Sigma}_0X^\top(\mat{X} \mat{\Sigma}_0 \mat{X}^\top + \mat{I}_n + \tau \mat{Q}^{-1})^{-1}(\vect{Y} - \mat{X} \vect{\mu}_0) \\
\mat{\Sigma}_n = \tau^{-1}\mat{\Sigma}_0 - \tau^{-1}\mat{\Sigma}_0 \mat{X}^\top (\mat{X} \mat{\Sigma}_0 \mat{X}^\top + \mat{I}_n + \tau \mat{Q}^{-1})^{-1} \mat{X} \mat{\Sigma}_0,"/></p>
</div><p>or equivalently, thanks to the matrix Woodsbury identity:</p>
<div class="math">
<p><img src="../../_images/math/0b1b9d3c84f088f7183c12b05abe41874765bc8d.svg" alt="\vect{\mu}_n =  (\mat{\Sigma}_0^{-1} + \mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \mat{X})^{-1}(\mat{\Sigma}_0^{-1} \vect{\mu}_0 + \mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \vect{Y})\\
\mat{\Sigma}_n = \tau^{-1}(\mat{\Sigma}_0^{-1} + \mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \mat{X})^{-1}."/></p>
</div><p>By having all hyperparameters go to <img class="math" src="../../_images/math/21fe8df504edff5073ffd2105c782736d35f8f17.svg" alt="0,"/> we obtain the following
simplified form:</p>
<div class="math">
<p><img src="../../_images/math/19ca96ed89b75898edb9c303aa7af814490fb170.svg" alt="\vect{\mu}_n =  (\mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \mat{X})^{-1}(\mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \vect{Y})\\
\mat{\Sigma}_n = \tau^{-1}(\mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \mat{X})^{-1}."/></p>
</div><p>Explicit simulation from a box-constrained multivariate normal can be
done with a simple rejection sampling scheme:</p>
<p>Step 1 : Create associated <a class="reference internal" href="../../user_manual/_generated/openturns.RandomVector.html#openturns.RandomVector" title="openturns.RandomVector"><code class="xref py py-class docutils literal notranslate"><span class="pre">RandomVector</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BoxConstrainedNormal</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">PythonRandomVector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multivariate normal distribution</span>
<span class="sd">    under box constraints</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">r</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">s</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mu</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">d</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;expectation or bound does not have size </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="k">if</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;covariance matrix not have dimensions (</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BoxConstrainedNormal</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">Sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">setParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getDimension</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parameter</span><span class="p">[:</span><span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parameter</span><span class="p">[</span><span class="n">d</span><span class="p">:</span> <span class="n">d</span> <span class="o">+</span> <span class="n">d</span> <span class="o">*</span> <span class="n">d</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parameter</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">d</span><span class="p">:</span> <span class="o">-</span><span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parameter</span><span class="p">[</span><span class="o">-</span><span class="n">d</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">getParameter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">getRealization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">accept</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">proposaldist</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">ot</span><span class="o">.</span><span class="n">CovarianceMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma</span><span class="p">))</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">accept</span><span class="p">:</span>
            <span class="n">proposal</span> <span class="o">=</span> <span class="n">proposaldist</span><span class="o">.</span><span class="n">getRealization</span><span class="p">()</span>
            <span class="n">accept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">proposal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">proposal</span>


<span class="n">RV_theta</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">RandomVector</span><span class="p">(</span><span class="n">BoxConstrainedNormal</span><span class="p">())</span>
</pre></div>
</div>
<p>Step 2 : Link function, giving the parameters of the box-constrained normal in function of <img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/> and <img class="math" src="../../_images/math/f226966057cd198bc5b8e728a3f9b629b5f15b2f.svg" alt="\vect{Y}"/> values</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">py_link_function_theta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
    <span class="c1"># conditional mean and variance</span>
    <span class="c1"># for diagonal Q</span>
    <span class="n">Itilde_inv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">tau</span> <span class="o">/</span> <span class="n">Q</span><span class="p">)</span>
    <span class="n">Xtilde</span> <span class="o">=</span> <span class="n">Itilde_inv</span> <span class="o">*</span> <span class="n">X</span>
    <span class="n">Sigma_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Xtilde</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X</span><span class="p">))</span> <span class="o">/</span> <span class="n">tau</span>
    <span class="n">mu_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Xtilde</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
    <span class="n">mu_n</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Sigma_n</span><span class="p">,</span> <span class="n">mu_n</span><span class="p">)</span>
    <span class="c1"># extract parameters in correct order (coherent with getParameter() method of RV_theta)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">mu_n</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
            <span class="n">Sigma_n</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
            <span class="n">support</span><span class="o">.</span><span class="n">getLowerBound</span><span class="p">()[:</span><span class="n">p</span><span class="p">],</span>
            <span class="n">support</span><span class="o">.</span><span class="n">getUpperBound</span><span class="p">()[:</span><span class="n">p</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">)</span>
</pre></div>
</div>
</section>
<section id="updating-tau">
<h4>2.2.3. Updating <img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/><a class="headerlink" href="#updating-tau" title="Permalink to this heading">¶</a></h4>
<p><img class="math" src="../../_images/math/ade1eacb8435e426461961eb9143a700694f892c.svg" alt="\pi(\tau|\vect{Y},\vect{\theta})"/> is proportional to:</p>
<div class="math">
<p><img src="../../_images/math/961fa7134a719b3aaded1aef7a9bebe7d38cc6bf.svg" alt="\pi(\tau|\vect{Y},\vect{\theta})
\propto
{\bf 1}_{\{\tau_{\min} \leq \tau \leq \tau_{\max}\}}\times
\mathcal N_n(\vect{Y}|\mat{X} \vect{\theta};\tau^{-1} \mat{I}_n + \mat{Q}^{-1})."/></p>
</div><p>Hence, <img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/> can be updated using the Random-walk
Metropolis-Hastings algorithm.</p>
<p>Step 1 : compute tau’s conditional posterior density, up to a multiplicative factor</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">marginals_Y</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">tau</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Q</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="n">mu</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))]</span>


<span class="k">def</span> <span class="nf">py_log_density</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))]</span>
    <span class="n">ld</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">ComposedDistribution</span><span class="p">(</span><span class="n">marginals_Y</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">tau</span><span class="p">))</span><span class="o">.</span><span class="n">computeLogPDF</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ld</span><span class="p">]</span>
</pre></div>
</div>
<p>Step 2 : define the proposal distribution</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">proposal_tau</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="initialization">
<h3>2.3. Initialization<a class="headerlink" href="#initialization" title="Permalink to this heading">¶</a></h3>
<p>To avoid all numerical problems, it is better to provide the algorithm
with a starting point not too far from the posterior mode. To this end,
we propose to set <img class="math" src="../../_images/math/89cc2a66a547d7d6a44e8a9233236ebd68c45230.svg" alt="\vect{Y}=\vect{Y}^{obs}"/> for simplicity, then solve the
following optimization problem</p>
<div class="math">
<p><img src="../../_images/math/d8cd53a5b929ad187179f008cacfbd04484e2c34.svg" alt="\widehat\theta,\widehat\tau = \arg\max_{\vect{\theta},\tau} \pi(\vect{\theta},\tau|\vect{Y}^{obs},\vect{Y}=\vect{Y}^{obs})
= \arg\max_{\theta\in[\vect{\theta}_{\min};\vect{\theta}_{\max}]
\tau\in[\tau_{\min};\tau_{\max}]} \mathcal N(\vect{Y}^{obs}|\vect{\theta} \mat{X}; \tau^{-1} \mat{I}_n + \mat{Q}^{-1})."/></p>
</div><p>Note that the unconstrained optimization over <img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/> for fixed
<img class="math" src="../../_images/math/20de980d786f800acea0d00b9f248081b74ce860.svg" alt="\tau"/> is explicit, since:</p>
<div class="math">
<p><img src="../../_images/math/0c11dd3b49831f28df00fe069cd10fa39bab1dfc.svg" alt="\arg\max_{\vect{\theta}} \pi(\vect{\theta},\tau|\vect{Y}^{obs},\vect{Y}=\vect{Y}^{obs})
=\arg\max_{\vect{\theta}} \pi(\vect{\theta}|\vect{Y}^{obs},\vect{Y}=\vect{Y}^{obs},\tau)."/></p>
</div><p>But we have shown that the conditional posterior density of
<img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/> is Gaussian. Hence the unconstrained conditional
posterior mode (and mean) is given by:</p>
<div class="math">
<p><img src="../../_images/math/3660948c2caaa95ac0072ce4fcae0e1eee97ed69.svg" alt="\arg\max_{\vect{\theta}} \pi(\vect{\theta}|\vect{Y}^{obs},\vect{Y}=\vect{Y}^{obs},\tau) = (\mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \mat{X})^{-1}(\mat{X}^\top (\mat{I}_n + \tau \mat{Q}^{-1})^{-1} \vect{Y}):= \vect{\mu}_n(\tau)."/></p>
</div><p>If this point does not respect the constraints, then we simply project
each component unto the constrained space.</p>
<p>Hence the following 1D problem remains to be solved:</p>
<div class="math">
<p><img src="../../_images/math/d438160338ad7e84b5cae476446196de5c823bd6.svg" alt="\widehat\tau = \arg\max_{\tau\in[\tau_{\min};\tau_{\max}]} \mathcal N(\vect{Y}^{obs}|\vect{\mu}_n(\tau) \mat{X}; \tau^{-1} \mat{I}_n + \mat{Q}^{-1})."/></p>
</div><p>The optimal value of <img class="math" src="../../_images/math/5d535616eeb941f4cf5f21fee2588427aaece1ed.svg" alt="\vect{\theta}"/> is then given by:
<img class="math" src="../../_images/math/848b1f462e3619a11556607ad075f76c5bcbec24.svg" alt="\widehat{\vect{\theta}} = \vect{\mu}_n(\widehat\tau)."/></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mu_n</span><span class="p">(</span><span class="n">tau</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="c1"># trick: posterior conditional mean is computed by the link function</span>
    <span class="k">return</span> <span class="n">py_link_function_theta</span><span class="p">(</span><span class="n">x</span><span class="p">)[:</span><span class="n">p</span><span class="p">]</span>


<span class="c1"># optimization criterion</span>
<span class="k">def</span> <span class="nf">log_cond_tau_post</span><span class="p">(</span><span class="n">tau</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span>
    <span class="c1"># replace theta by its conditional posterior mean</span>
    <span class="n">x</span><span class="p">[:</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">py_link_function_theta</span><span class="p">(</span><span class="n">x</span><span class="p">)[:</span><span class="n">p</span><span class="p">]</span>
    <span class="c1"># compute log conditional posterior of tau</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="n">py_log_density</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ll</span>
</pre></div>
</div>
<p>1D optimization</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">log_cond_tau_post</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>


<span class="n">problem</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">OptimizationProblem</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">PythonFunction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span>
<span class="n">problem</span><span class="o">.</span><span class="n">setBounds</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">([</span><span class="mf">1e-4</span><span class="p">],</span> <span class="p">[</span><span class="mf">1e4</span><span class="p">]))</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">TNC</span><span class="p">(</span><span class="n">problem</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setStartingPoint</span><span class="p">([</span><span class="mf">1.0</span><span class="p">])</span>
<span class="n">solver</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">tauhat</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">getResult</span><span class="p">()</span><span class="o">.</span><span class="n">getOptimalPoint</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tauhat =&quot;</span><span class="p">,</span> <span class="n">tauhat</span><span class="p">)</span>

<span class="c1"># inject result in initialState vector</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
<span class="n">x</span><span class="p">[:</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu_n</span><span class="p">(</span><span class="n">tauhat</span><span class="p">)</span>
<span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">tauhat</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>tauhat = 0.10077295009614318
</pre></div>
</div>
<p>Final step : create a <a class="reference internal" href="../../user_manual/_generated/openturns.MetropolisHastings.html#openturns.MetropolisHastings" title="openturns.MetropolisHastings"><code class="xref py py-class docutils literal notranslate"><span class="pre">MetropolisHastings</span></code></a> object for each block</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">initialState</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">mi_Y</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="p">)]</span>
<span class="n">link_function_y</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">PythonFunction</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="n">py_link_function_y</span><span class="p">)</span>
<span class="n">rvmh_Y</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">RandomVectorMetropolisHastings</span><span class="p">(</span><span class="n">RV_Y</span><span class="p">,</span> <span class="n">initialState</span><span class="p">,</span> <span class="n">mi_Y</span><span class="p">,</span> <span class="n">link_function_y</span><span class="p">)</span>

<span class="n">mi_theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span>
<span class="n">link_function_theta</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">PythonFunction</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="n">py_link_function_theta</span><span class="p">)</span>
<span class="n">rvmh_theta</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">RandomVectorMetropolisHastings</span><span class="p">(</span>
    <span class="n">RV_theta</span><span class="p">,</span> <span class="n">initialState</span><span class="p">,</span> <span class="n">mi_theta</span><span class="p">,</span> <span class="n">link_function_theta</span>
<span class="p">)</span>

<span class="n">log_pdf_tau</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">PythonFunction</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">py_log_density</span><span class="p">)</span>
<span class="n">rwmh_tau</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">RandomWalkMetropolisHastings</span><span class="p">(</span>
    <span class="n">log_pdf_tau</span><span class="p">,</span> <span class="n">support</span><span class="p">,</span> <span class="n">initialState</span><span class="p">,</span> <span class="n">proposal_tau</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># Now, assemble the blocks to create a Gibbs algorithm:</span>
<span class="n">gibbs</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Gibbs</span><span class="p">([</span><span class="n">rvmh_Y</span><span class="p">,</span> <span class="n">rvmh_theta</span><span class="p">,</span> <span class="n">rwmh_tau</span><span class="p">])</span>
</pre></div>
</div>
<p>Launch Algorithm</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sampleSize</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="c1"># Joint posterior density sample</span>
<span class="n">sample</span> <span class="o">=</span> <span class="n">gibbs</span><span class="o">.</span><span class="n">getSample</span><span class="p">(</span><span class="n">sampleSize</span><span class="p">)</span>

<span class="c1"># compute acceptance rate</span>
<span class="n">tau_post</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">p</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">acc_rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">tau_post</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">tau_post</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Acceptance rate: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">acc_rate</span><span class="p">)</span>
</pre></div>
</div>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Acceptance rate: 0.47047047047047047
</pre></div>
</div>
<p>Plot posterior distribution marginals</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># extract interest parameters</span>
<span class="n">post_sample</span> <span class="o">=</span> <span class="n">sample</span><span class="o">.</span><span class="n">getMarginal</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
<span class="n">post_sample</span><span class="o">.</span><span class="n">setDescription</span><span class="p">([</span><span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">theta_0$&quot;</span><span class="p">,</span> <span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">theta_1$&quot;</span><span class="p">,</span> <span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">tau$&quot;</span><span class="p">])</span>

<span class="n">posterior</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">KernelSmoothing</span><span class="p">()</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">post_sample</span><span class="p">)</span>
<span class="n">posterior</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">TruncatedDistribution</span><span class="p">(</span><span class="n">posterior</span><span class="p">,</span> <span class="n">prior</span><span class="o">.</span><span class="n">getRange</span><span class="p">())</span>

<span class="n">grid</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">GridLayout</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s2">&quot;Bayesian inference&quot;</span><span class="p">)</span>
<span class="n">xlabs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;$\theta_0$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$\theta_1$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$\tau$&quot;</span><span class="p">]</span>
<span class="n">p_true</span> <span class="o">=</span> <span class="p">[</span><span class="n">theta_true</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta_true</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tau_true</span><span class="p">]</span>
<span class="k">for</span> <span class="n">parameter_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">posterior</span><span class="o">.</span><span class="n">getMarginal</span><span class="p">(</span><span class="n">parameter_index</span><span class="p">)</span><span class="o">.</span><span class="n">drawPDF</span><span class="p">()</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">getBoundingBox</span><span class="p">()</span>
    <span class="n">bound</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">getUpperBound</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">prior_pdf</span> <span class="o">=</span> <span class="n">prior</span><span class="o">.</span><span class="n">getMarginal</span><span class="p">(</span><span class="n">parameter_index</span><span class="p">)</span><span class="o">.</span><span class="n">drawPDF</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">prior_pdf</span><span class="p">)</span>
    <span class="n">curve_true</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Curve</span><span class="p">([</span><span class="n">p_true</span><span class="p">[</span><span class="n">parameter_index</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">bound</span><span class="p">])</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curve_true</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">setColors</span><span class="p">(</span><span class="n">ot</span><span class="o">.</span><span class="n">Drawable</span><span class="o">.</span><span class="n">BuildDefaultPalette</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">setLegends</span><span class="p">([</span><span class="s2">&quot;Posterior&quot;</span><span class="p">,</span> <span class="s2">&quot;Prior&quot;</span><span class="p">,</span> <span class="s2">&quot;True value&quot;</span><span class="p">])</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">setXTitle</span><span class="p">(</span><span class="n">xlabs</span><span class="p">[</span><span class="n">parameter_index</span><span class="p">])</span>
    <span class="n">grid</span><span class="o">.</span><span class="n">setGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">parameter_index</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_gibbs_simus_002.png" srcset="../../_images/sphx_glr_plot_gibbs_simus_002.png" alt="Bayesian inference" class = "sphx-glr-single-img"/><p>Draw pairplots of the posterior sample.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># sphinx_gallery_thumbnail_number = 3</span>
<span class="n">grid</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">VisualTest</span><span class="o">.</span><span class="n">DrawPairs</span><span class="p">(</span><span class="n">post_sample</span><span class="p">)</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">pt</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">(</span><span class="n">theta_true</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;#2ca02c&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">,</span> <span class="s2">&quot;True value&quot;</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">setGraph</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">pt</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">([[</span><span class="n">theta_true</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tau_true</span><span class="p">]],</span> <span class="s2">&quot;#2ca02c&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">,</span> <span class="s2">&quot;True value&quot;</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">setGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>

<span class="n">graph</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">getGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">pt</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">([[</span><span class="n">theta_true</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">tau_true</span><span class="p">]],</span> <span class="s2">&quot;#2ca02c&quot;</span><span class="p">,</span> <span class="s2">&quot;circle&quot;</span><span class="p">,</span> <span class="s2">&quot;True value&quot;</span><span class="p">)</span>
<span class="n">graph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
<span class="n">grid</span><span class="o">.</span><span class="n">setGraph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>


<span class="n">View</span><span class="o">.</span><span class="n">ShowAll</span><span class="p">()</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_gibbs_simus_003.png" srcset="../../_images/sphx_glr_plot_gibbs_simus_003.png" alt="plot gibbs simus" class = "sphx-glr-single-img"/><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  1.295 seconds)</p>
<div class="sphx-glr-footer sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-calibration-bayesian-calibration-plot-gibbs-simus-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/b5eb43c32b62f5e87325b7ed1c68eb2e/plot_gibbs_simus.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">plot_gibbs_simus.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/74a3b4665b1c5e5168204eea0ecddf4f/plot_gibbs_simus.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">plot_gibbs_simus.ipynb</span></code></a></p>
</div>
</div>
</section>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../auto_numerical_methods/index.html" title="Numerical methods"
             >next</a> |</li>
        <li class="right" >
          <a href="plot_ackley_distribution.html" title="Customize your Metropolis-Hastings algorithm"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">OpenTURNS 1.20rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../contents.html" >Contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../examples/examples.html" >Examples</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >Calibration</a> &#187;</li>
          <li class="nav-item nav-item-4"><a href="index.html" >Bayesian calibration</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Linear Regression with interval-censored observations</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005-2022 Airbus-EDF-IMACS-ONERA-Phimeca.
      Last updated on Oct 12, 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.2.3.
    </div>
  </body>
</html>