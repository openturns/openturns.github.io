
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/distributions/plot_python_distribution.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_distributions_plot_python_distribution.py:


Create a customized distribution or copula
==========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-15

In this example we are going to create a distribution or copula.

The way to go is inheriting the PythonDistribution class and overload the methods of the Distribution object.

To create a Copula, the user has to overload isCopula() and return True.

Then an instance of the new class can be passed on into a Distribution object.

At least computeCDF should be overriden.

.. GENERATED FROM PYTHON SOURCE LINES 17-27

.. code-block:: default

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    import math as m
    import warnings

    warnings.filterwarnings("ignore")
    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 28-29

Inherit PythonDistribution :

.. GENERATED FROM PYTHON SOURCE LINES 31-137

.. code-block:: default

    class UniformNdPy(ot.PythonDistribution):
        def __init__(self, a=[0.0], b=[1.0]):
            super(UniformNdPy, self).__init__(len(a))
            if len(a) != len(b):
                raise ValueError("Invalid bounds")
            for i in range(len(a)):
                if a[i] > b[i]:
                    raise ValueError("Invalid bounds")
            self.a = a
            self.b = b
            self.factor = 1.0
            for i in range(len(a)):
                self.factor *= b[i] - a[i]

        def getRange(self):
            return ot.Interval(self.a, self.b, [True] * len(self.a), [True] * len(self.a))

        def getRealization(self):
            X = []
            for i in range(len(self.a)):
                X.append(
                    self.a[i] + (self.b[i] - self.a[i]) * ot.RandomGenerator.Generate()
                )
            return X

        def getSample(self, size):
            X = []
            for i in range(size):
                X.append(self.getRealization())
            return X

        def computeCDF(self, X):
            prod = 1.0
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                prod *= min(self.b[i], X[i]) - self.a[i]
            return prod / self.factor

        def computePDF(self, X):
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                if X[i] > self.b[i]:
                    return 0.0
            return 1.0 / self.factor

        def getMean(self):
            mu = []
            for i in range(len(self.a)):
                mu.append(0.5 * (self.a[i] + self.b[i]))
            return mu

        def getStandardDeviation(self):
            stdev = []
            for i in range(len(self.a)):
                stdev.append((self.b[i] - self.a[i]) / m.sqrt(12.0))
            return stdev

        def getSkewness(self):
            return [0.0] * len(self.a)

        def getKurtosis(self):
            return [1.8] * len(self.a)

        def getMoment(self, n):
            return [-0.1 * n] * len(self.a)

        def getCentralMoment(self, n):
            return [0.0] * len(self.a)

        def computeCharacteristicFunction(self, x):
            if len(self.a) > 1:
                raise ValueError("dim>1")
            ax = self.a[0] * x
            bx = self.b[0] * x
            return (m.sin(bx) - m.sin(ax) + 1j * (m.cos(ax) - m.cos(bx))) / (bx - ax)

        def isElliptical(self):
            return (len(self.a) == 1) and (self.a[0] == -self.b[0])

        def isCopula(self):
            for i in range(len(self.a)):
                if self.a[i] != 0.0:
                    return False
                if self.b[i] != 1.0:
                    return False
            return True

        def getMarginal(self, indices):
            subA = []
            subB = []
            for i in indices:
                subA.append(self.a[i])
                subB.append(self.b[i])
            py_dist = UniformNdPy(subA, subB)
            return ot.Distribution(py_dist)

        def computeQuantile(self, prob, tail=False):
            q = 1.0 - prob if tail else prob
            quantile = self.a
            for i in range(len(self.a)):
                quantile[i] += q * (self.b[i] - self.a[i])
            return quantile









.. GENERATED FROM PYTHON SOURCE LINES 138-139

Let us instantiate the distribution:

.. GENERATED FROM PYTHON SOURCE LINES 141-143

.. code-block:: default

    distribution = ot.Distribution(UniformNdPy([5, 6], [7, 9]))








.. GENERATED FROM PYTHON SOURCE LINES 144-145

And plot the `cdf`:

.. GENERATED FROM PYTHON SOURCE LINES 147-151

.. code-block:: default

    graph = distribution.drawCDF()
    graph.setColors(["blue"])
    view = viewer.View(graph)




.. image-sg:: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.png
   :alt: [X0,X1] iso-CDF
   :srcset: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 152-153

We can easily generate sample:

.. GENERATED FROM PYTHON SOURCE LINES 155-157

.. code-block:: default

    distribution.getSample(5)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <TABLE><TR><TD></TD><TH>v0</TH><TH>v1</TH></TR>
    <TR><TH>0</TH><TD>6.856661</TD><TD>8.081292</TD></TR>
    <TR><TH>1</TH><TD>5.037569</TD><TD>7.852766</TD></TR>
    <TR><TH>2</TH><TD>6.672036</TD><TD>6.17118</TD></TR>
    <TR><TH>3</TH><TD>6.027888</TD><TD>8.788813</TD></TR>
    <TR><TH>4</TH><TD>6.319285</TD><TD>7.819516</TD></TR>
    </TABLE>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 158-159

or compute the `mean`:

.. GENERATED FROM PYTHON SOURCE LINES 161-163

.. code-block:: default

    distribution.getMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[6,7.5]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 164-165

Also we can compute the probability contained in an interval :

.. GENERATED FROM PYTHON SOURCE LINES 167-169

.. code-block:: default

    distribution.computeProbability(ot.Interval([5.5, 6], [8.5, 9]))
    plt.show()







.. GENERATED FROM PYTHON SOURCE LINES 170-171

And do more (see `Distribution` for all methods)


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.107 seconds)


.. _sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_python_distribution.py <plot_python_distribution.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_python_distribution.ipynb <plot_python_distribution.ipynb>`
