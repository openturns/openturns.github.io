
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_kriging_beam_arbitrary_trend.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:


Configuring an arbitrary trend in Kriging
=========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-16

The goal of this example is to show how to configure an arbitrary trend in a Kriging metamodel.

In general, any collection of multivariate functions can be used as the
`basis` argument of a `KrigingAlgorithm`.
In practice, it might not be convenient to create a multivariate basis and
this is why we sometimes create it by tensorization of univariate functions.
In this example, we first use Legendre polynomials as our univariate functions,
then we create an orthogonal polynomial basis corresponding to the input marginals.

For this purpose, we use the :ref:`cantilever beam <use-case-cantilever-beam>` example.

.. GENERATED FROM PYTHON SOURCE LINES 18-20

Definition of the model
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 22-28

.. code-block:: default

    from openturns.usecases import cantilever_beam
    import openturns as ot

    ot.RandomGenerator.SetSeed(0)
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 29-30

We load the cantilever beam use case

.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: default

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 33-34

We load the function (model) which evaluates the output Y depending on the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 34-36

.. code-block:: default

    model = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 37-38

Then we define the distribution of the input random vector.

.. GENERATED FROM PYTHON SOURCE LINES 38-41

.. code-block:: default

    dimension = cb.dim  # number of inputs
    myDistribution = cb.distribution








.. GENERATED FROM PYTHON SOURCE LINES 42-44

Create the design of experiments
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 46-47

We consider a simple Monte-Carlo sampling as a design of experiments. This is why we generate an input sample using the `getSample` method of the distribution. Then we evaluate the output using the `model` function.

.. GENERATED FROM PYTHON SOURCE LINES 49-53

.. code-block:: default

    sampleSize_train = 20
    X_train = myDistribution.getSample(sampleSize_train)
    Y_train = model(X_train)








.. GENERATED FROM PYTHON SOURCE LINES 54-60

Create the Legendre basis
-------------------------

We first create a Legendre basis of univariate polynomials. In order to convert then into multivariate polynomials, we use a linear enumerate function.

The `LegendreFactory` class creates Legendre polynomials.

.. GENERATED FROM PYTHON SOURCE LINES 62-64

.. code-block:: default

    univariateFactory = ot.LegendreFactory()








.. GENERATED FROM PYTHON SOURCE LINES 65-66

This factory corresponds to the `Uniform` distribution in the [-1,1] interval.

.. GENERATED FROM PYTHON SOURCE LINES 68-70

.. code-block:: default

    univariateFactory.getMeasure()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>Uniform(a = -1, b = 1)</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 71-72

This interval does not correspond to the interval on which the input marginals are defined (we will come back to this topic later), but this will, anyway, create a consistent trend for the kriging.

.. GENERATED FROM PYTHON SOURCE LINES 74-76

.. code-block:: default

    polyColl = [univariateFactory] * dimension








.. GENERATED FROM PYTHON SOURCE LINES 77-80

.. code-block:: default

    enumerateFunction = ot.LinearEnumerateFunction(dimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 81-88

.. code-block:: default

    functions = []
    numberOfTrendCoefficients = 12
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    (1.73205 * x0) * (1.73205 * x1)
    (1.73205 * x0) * (1.73205 * x2)
    (1.73205 * x0) * (1.73205 * x3)
    -1.11803 + 3.3541 * x1^2
    (1.73205 * x1) * (1.73205 * x2)
    (1.73205 * x1) * (1.73205 * x3)




.. GENERATED FROM PYTHON SOURCE LINES 89-91

.. code-block:: default

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 92-94

Create the metamodel
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 96-97

In order to create the kriging metamodel, we first select a constant trend with the `ConstantBasisFactory` class. Then we use a squared exponential covariance model. Finally, we use the `KrigingAlgorithm` class to create the kriging metamodel, taking the training sample, the covariance model and the trend basis as input arguments.

.. GENERATED FROM PYTHON SOURCE LINES 99-101

.. code-block:: default

    covarianceModel = ot.SquaredExponential([1.0] * dimension, [1.0])








.. GENERATED FROM PYTHON SOURCE LINES 102-107

.. code-block:: default

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 108-109

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 111-113

.. code-block:: default

    result.getTrendCoefficients()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [class=Point name=Unnamed dimension=12 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50]]



.. GENERATED FROM PYTHON SOURCE LINES 114-115

We see that the number of coefficients in the trend corresponds to the number of functions in the basis.

.. GENERATED FROM PYTHON SOURCE LINES 117-119

.. code-block:: default

    result.getCovarianceModel()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>SquaredExponential(scale=[1,1,1,1], amplitude=[0.0316491])</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 120-121

The `SquaredExponential` model has one amplitude coefficient and 4 scale coefficients. This is because this covariance model is anisotropic : each of the 4 input variables is associated with its own scale coefficient.

.. GENERATED FROM PYTHON SOURCE LINES 123-125

Create an orthogonal multivariate polynomial factory
----------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 127-132

In order to create a Legendre basis which better corresponds to the input marginals, we could consider the orthogonal basis which would be associated to uniform marginals. To compute the bounds of these uniform distributions, we may consider the 1% and 99% quantiles of each marginal.

There is, however, a simpler way to proceed. We can simply orthogonalize the input marginals and create the orthogonal polynomial basis corresponding to the inputs. This corresponds to the method we would use in the polynomial chaos.

We first create the polynomial basis which corresponds to the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 134-136

.. code-block:: default

    multivariateBasis = ot.OrthogonalProductPolynomialFactory([cb.E, cb.F, cb.L, cb.II])








.. GENERATED FROM PYTHON SOURCE LINES 137-138

Then we create the multivariate basis which has maximum degree equal to 2.

.. GENERATED FROM PYTHON SOURCE LINES 140-145

.. code-block:: default

    totalDegree = 2
    enumerateFunction = multivariateBasis.getEnumerateFunction()
    numberOfTrendCoefficients = enumerateFunction.getStrataCumulatedCardinal(totalDegree)
    numberOfTrendCoefficients





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    15



.. GENERATED FROM PYTHON SOURCE LINES 146-152

.. code-block:: default

    functions = []
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    (1.73205 * x0) * (1.73205 * x1)
    (1.73205 * x0) * (1.73205 * x2)
    (1.73205 * x0) * (1.73205 * x3)
    -1.11803 + 3.3541 * x1^2
    (1.73205 * x1) * (1.73205 * x2)
    (1.73205 * x1) * (1.73205 * x3)
    -1.11803 + 3.3541 * x2^2
    (1.73205 * x2) * (1.73205 * x3)
    -1.11803 + 3.3541 * x3^2




.. GENERATED FROM PYTHON SOURCE LINES 153-155

.. code-block:: default

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 156-161

.. code-block:: default

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 162-163

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 165-167

.. code-block:: default

    result.getTrendCoefficients()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [class=Point name=Unnamed dimension=15 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50,1.39896e-44,7.63508e-52,-7.60276e-46]]



.. GENERATED FROM PYTHON SOURCE LINES 168-179

Conclusion
----------

The trend that we have configured corresponds to the basis that we would have used in a full polynomial chaos computed with least squares.

Other extensions of this work would be:

* to use a Fourier basis with `FourierSeriesFactory`,
* wavelets with `HaarWaveletFactory`,

or any other univariate factory.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.009 seconds)


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_kriging_beam_arbitrary_trend.py <plot_kriging_beam_arbitrary_trend.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_kriging_beam_arbitrary_trend.ipynb <plot_kriging_beam_arbitrary_trend.ipynb>`
