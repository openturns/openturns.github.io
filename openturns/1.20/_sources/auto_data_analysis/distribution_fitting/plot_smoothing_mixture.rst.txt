
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_data_analysis/distribution_fitting/plot_smoothing_mixture.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_data_analysis_distribution_fitting_plot_smoothing_mixture.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_data_analysis_distribution_fitting_plot_smoothing_mixture.py:


Bandwidth sensitivity in kernel smoothing
=========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-33

Introduction
------------

We consider the distribution

.. math::
   f_1(x) = w_1 f_A(x) + w_2 f_B(x)


for any :math:`x\in\mathbb{R}` where :math:`f_A` is the density of the Normal distribution
:math:`\mathcal{N}(0,1)`, :math:`f_B` is the density of the Normal distribution
:math:`\mathcal{N}(3/2,(1/3)^2)` and the weights are :math:`w_1 = \frac{3}{4}` and :math:`w_2 = \frac{1}{4}`.

This is a mixture of two Normal distributions: 1/4th of the observations have the :math:`\mathcal{N}(0,1)`
distribution and 3/4th of the observations have the :math:`\mathcal{N}(3/2,(1/3)^2)` distribution.
This example is considered in (Wand, Jones, 1994), page 14, Figure 2.3.

We consider a sample generated from independent realizations of :math:`f_1` and
want to approximate the distribution from kernel smoothing.
More precisely, we want to observe the sensitivity of the resulting density to the
bandwidth.

References
----------

* "Kernel Smoothing", M.P.Wand, M.C.Jones. Chapman and Hall / CRC (1994).


.. GENERATED FROM PYTHON SOURCE LINES 36-45

Generate the mixture by merging two samples
-------------------------------------------

In this section, we show that a mixture of two Normal distributions is
nothing more than the merged sample of two independent Normal distributions.
In order to generate a sample with size :math:`n`, we sample
:math:`\lfloor w_1 n\rfloor` points from the first Normal distribution
:math:`f_A` and :math:`\lfloor w_2 n\rfloor` points from the second Normal
distribution :math:`f_B`. Then we merge the two samples.

.. GENERATED FROM PYTHON SOURCE LINES 47-51

.. code-block:: default

    import openturns as ot
    import openturns.viewer as otv
    import pylab as pl








.. GENERATED FROM PYTHON SOURCE LINES 52-53

We choose a rather large sample size: :math:`n=1000`.

.. GENERATED FROM PYTHON SOURCE LINES 55-57

.. code-block:: default

    n = 1000








.. GENERATED FROM PYTHON SOURCE LINES 58-59

Then we define the two Normal distributions and their parameters.

.. GENERATED FROM PYTHON SOURCE LINES 61-66

.. code-block:: default

    w1 = 0.75
    w2 = 1.0 - w1
    distribution1 = ot.Normal(0.0, 1.0)
    distribution2 = ot.Normal(1.5, 1.0 / 3.0)








.. GENERATED FROM PYTHON SOURCE LINES 67-68

We generate two independent sub-samples from the two Normal distributions.

.. GENERATED FROM PYTHON SOURCE LINES 70-73

.. code-block:: default

    sample1 = distribution1.getSample(int(w1 * n))
    sample2 = distribution2.getSample(int(w2 * n))








.. GENERATED FROM PYTHON SOURCE LINES 74-75

Then we merge the sub-samples into a larger one with the `add` method of the `Sample` class.

.. GENERATED FROM PYTHON SOURCE LINES 77-81

.. code-block:: default

    sample = ot.Sample(sample1)
    sample.add(sample2)
    sample.getSize()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    1000



.. GENERATED FROM PYTHON SOURCE LINES 82-83

In order to see the result, we build a kernel smoothing approximation on the sample. In order to keep it simple, let us use the default bandwidth selection rule.

.. GENERATED FROM PYTHON SOURCE LINES 85-88

.. code-block:: default

    factory = ot.KernelSmoothing()
    fit = factory.build(sample)








.. GENERATED FROM PYTHON SOURCE LINES 89-92

.. code-block:: default

    graph = fit.drawPDF()
    view = otv.View(graph)




.. image-sg:: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_001.png
   :alt: plot smoothing mixture
   :srcset: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 93-94

We see that the distribution of the merged sample has two modes. However, these modes are not clearly distinct. To distinguish them, we could increase the sample size. However, it might be interesting to see if the bandwidth selection rule can be better chosen: this is the purpose of the next section.

.. GENERATED FROM PYTHON SOURCE LINES 96-100

Simulation based on a mixture
-----------------------------

Since the distribution that we approximate is a mixture, it will be more convenient to create it from the `Mixture` class. It takes as input argument a list of distributions and a list of weights.

.. GENERATED FROM PYTHON SOURCE LINES 102-104

.. code-block:: default

    distribution = ot.Mixture([distribution1, distribution2], [w1, w2])








.. GENERATED FROM PYTHON SOURCE LINES 105-106

Then we generate a sample from it.

.. GENERATED FROM PYTHON SOURCE LINES 108-110

.. code-block:: default

    sample = distribution.getSample(n)








.. GENERATED FROM PYTHON SOURCE LINES 111-114

.. code-block:: default

    factory = ot.KernelSmoothing()
    fit = factory.build(sample)








.. GENERATED FROM PYTHON SOURCE LINES 115-117

.. code-block:: default

    factory.getBandwidth()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[0.208514]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 118-119

We see that the default bandwidth is close to 0.17.

.. GENERATED FROM PYTHON SOURCE LINES 121-129

.. code-block:: default

    graph = distribution.drawPDF()
    curve = fit.drawPDF()
    graph.add(curve)
    graph.setColors(["dodgerblue3", "darkorange1"])
    graph.setLegends(["Mixture", "Kernel smoothing"])
    graph.setLegendPosition("topleft")
    view = otv.View(graph)




.. image-sg:: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_002.png
   :alt: plot smoothing mixture
   :srcset: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 130-131

We see that the result of the kernel smoothing approximation of the mixture is similar to the previous one and could be improved.

.. GENERATED FROM PYTHON SOURCE LINES 133-135

Sensitivity to the bandwidth
----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 137-138

In this section, we observe the sensitivity of the kernel smoothing to the bandwidth. We consider the three following bandwidths: the small bandwidth 0.05, the large bandwidth 0.54 and 0.18 which is in-between. For each bandwidth, we use the second optional argument of the `build` method in order to select a specific bandwidth value.

.. GENERATED FROM PYTHON SOURCE LINES 140-161

.. code-block:: default

    hArray = [0.05, 0.54, 0.18]
    nLen = len(hArray)
    fig = pl.figure(figsize=(10, 8))
    for i in range(nLen):
        ax = fig.add_subplot(2, 2, i + 1)
        fit = factory.build(sample, [hArray[i]])
        graph = fit.drawPDF()
        graph.setColors(["dodgerblue3"])
        graph.setLegends(["h=%.4f" % (hArray[i])])
        exact = distribution.drawPDF()
        curve = exact.getDrawable(0)
        curve.setColor("darkorange1")
        curve.setLegend("Mixture")
        curve.setLineStyle("dashed")
        graph.add(curve)
        graph.setLegendPosition("topleft")
        graph.setXTitle("X")
        view = otv.View(graph, figure=fig, axes=[ax])
        pl.ylim(top=0.5)  # Common y-range

    view = otv.View(graph)



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_003.png
         :alt: plot smoothing mixture
         :srcset: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_004.png
         :alt: plot smoothing mixture
         :srcset: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_004.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 162-163

We see that when the bandwidth is too small, the resulting kernel smoothing has many more modes than the distribution it is supposed to approximate. When the bandwidth is too large, the approximated distribution is too smooth and has only one mode instead of the expected two modes which are in the mixture distribution. When the bandwidth is equal to 0.18, the two modes are correctly represented.

.. GENERATED FROM PYTHON SOURCE LINES 165-169

Sensitivity to the bandwidth rule
---------------------------------

The library provides three different rules to compute the bandwidth. In this section, we compare the results that we can get with them.

.. GENERATED FROM PYTHON SOURCE LINES 171-174

.. code-block:: default

    h1 = factory.computeSilvermanBandwidth(sample)[0]
    h1





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.3445636453391276



.. GENERATED FROM PYTHON SOURCE LINES 175-178

.. code-block:: default

    h2 = factory.computePluginBandwidth(sample)[0]
    h2





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.2021709523195656



.. GENERATED FROM PYTHON SOURCE LINES 179-182

.. code-block:: default

    h3 = factory.computeMixedBandwidth(sample)[0]
    h3





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.20851397168332242



.. GENERATED FROM PYTHON SOURCE LINES 183-185

.. code-block:: default

    factory.getBandwidth()[0]





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.18



.. GENERATED FROM PYTHON SOURCE LINES 186-189

We see that the default rule is the "Mixed" rule. This is because the sample is in dimension 1 and the sample size is quite large. For a small sample in 1 dimension, the "Plugin" rule would have been used.

The following script compares the results produced by the three rules.

.. GENERATED FROM PYTHON SOURCE LINES 191-217

.. code-block:: default

    hArray = [h1, h2, h3]
    legends = ["Silverman", "Plugin", "Mixed"]
    nLen = len(hArray)
    fig = pl.figure(figsize=(10, 8))
    for i in range(nLen):
        ax = fig.add_subplot(2, 2, i + 1)
        fit = factory.build(sample, [hArray[i]])
        graph = fit.drawPDF()
        graph.setColors(["dodgerblue3"])
        graph.setLegends(["h=%.4f, %s" % (hArray[i], legends[i])])
        exact = distribution.drawPDF()
        curve = exact.getDrawable(0)
        curve.setColor("darkorange1")
        curve.setLegend("Mixture")
        curve.setLineStyle("dashed")
        graph.add(curve)
        graph.setLegendPosition("topleft")
        graph.setXTitle("X")
        if i > 0:
            graph.setYTitle("")
        view = otv.View(graph, figure=fig, axes=[ax])
        pl.ylim(top=0.5)  # Common y-range

    view = otv.View(graph)

    otv.View.ShowAll()



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_005.png
         :alt: plot smoothing mixture
         :srcset: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_006.png
         :alt: plot smoothing mixture
         :srcset: /auto_data_analysis/distribution_fitting/images/sphx_glr_plot_smoothing_mixture_006.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 218-219

We see that the bandwidth produced by Silverman's rule is too large, leading to an oversmoothed distribution. The results produced by the Plugin and Mixed rules are comparable in this case.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.784 seconds)


.. _sphx_glr_download_auto_data_analysis_distribution_fitting_plot_smoothing_mixture.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_smoothing_mixture.py <plot_smoothing_mixture.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_smoothing_mixture.ipynb <plot_smoothing_mixture.ipynb>`
