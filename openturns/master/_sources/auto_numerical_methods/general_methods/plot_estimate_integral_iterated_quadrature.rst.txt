
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_numerical_methods/general_methods/plot_estimate_integral_iterated_quadrature.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_numerical_methods_general_methods_plot_estimate_integral_iterated_quadrature.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_numerical_methods_general_methods_plot_estimate_integral_iterated_quadrature.py:


Estimate a multivariate integral with IteratedQuadrature
========================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-18

Introduction
------------

In this example, we consider a function :math:`f: \Rset^d \mapsto \Rset`
and we compute the following integral:

.. math::
   I_f = \int_{a}^{b}\, \int_{l_1(x_0)}^{u_1(x_0)}\, \int_{l_2(x_0, x_1)}^{u_2(x_0,x_1)}\, \int_{l_{d-1}(x_0, \dots, x_{d-2})}^{u_{d-1}(x_0, \dots, x_{d-2})}
   \, f(x_0, \dots, x_{d-1})\mathrm{d}{x_{d-1}}\dots\mathrm{d}{x_0}

using an iterated quadrature algorithm :class:`~openturns.IteratedQuadrature`, based on the Gauss-Kronrod
:class:`~openturns.GaussKronrod` 1d quadrature algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 19-24

.. code-block:: Python


    import openturns as ot
    import openturns.viewer as otv
    import math as m








.. GENERATED FROM PYTHON SOURCE LINES 25-26

To get better colours for the function iso-lines.

.. GENERATED FROM PYTHON SOURCE LINES 26-28

.. code-block:: Python

    ot.ResourceMap.SetAsString("Contour-DefaultColorMapNorm", "rank")








.. GENERATED FROM PYTHON SOURCE LINES 29-44

Case 1: The integrand function presents a lot of discontinuities.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We consider the function:

.. math::
   f : \begin{array}{lcl}
         \Rset^2 & \rightarrow & \Rset \\
         (x,y) & \rightarrow & 1_{{x^2+y^2 \leq 4}}(x,y)
         \end{array}

the domain :math:`\set{D} =[-2,2]\times [-2,2]` and the integral:

.. math::
   I = \int_{\set{D}} f(x,y)\,dxdy = 4\pi


.. GENERATED FROM PYTHON SOURCE LINES 46-47

We first define the integrand :math:`f` and the domain :math:`\set{D}`.

.. GENERATED FROM PYTHON SOURCE LINES 47-59

.. code-block:: Python



    def kernel1(x):
        if x[0]**2 + x[1]**2 <= 4:
            return [1.0]
        else:
            return [0.0]


    integrand = ot.PythonFunction(2, 1, kernel1)
    domain = ot.Interval([-2.0, -2.0], [2.0, 2.0])








.. GENERATED FROM PYTHON SOURCE LINES 60-62

We draw the iso-lines of the integrand function which is
constant equal to 1 inside the circle with radius equal to 2 and equal to 0.0 outside.

.. GENERATED FROM PYTHON SOURCE LINES 62-68

.. code-block:: Python

    g = integrand.draw([-3.0, -3.0], [3.0, 3.0])
    g.setTitle(r'Function $f(x,y) = 1_{\{x^2+y^2 \leq 4\}}(x,y)$')
    g.setXTitle('x')
    g.setYTitle('y')
    view = otv.View(g)




.. image-sg:: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_001.png
   :alt: Function $f(x,y) = 1_{\{x^2+y^2 \leq 4\}}(x,y)$
   :srcset: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 69-79

We compute the integral using an  :class:`~openturns.IteratedQuadrature`
algorithm with
the :class:`~openturns.GaussKronrodRule`  *G11K23*, which means that we use
on each subinterval:

- 11 points for the Gauss approximations,
- 23 points for the Kronrod approximation including the 11 previous ones.

We limit the number of subintervals and we  define a maximum error between both approximations:
when the difference between both approximations is lower, a new subdivision is performed.

.. GENERATED FROM PYTHON SOURCE LINES 79-85

.. code-block:: Python

    maximumSubIntervals = 32
    maximumError = 1e-4
    GKRule = ot.GaussKronrodRule(ot.GaussKronrodRule.G1K3)
    integ_algo = ot.GaussKronrod(maximumSubIntervals, maximumError, GKRule)
    integration_algo = ot.IteratedQuadrature(integ_algo)








.. GENERATED FROM PYTHON SOURCE LINES 86-88

To get the nodes used to approximate the integral, we need to use a :class:`~openturns.MemoizeFunction`
that stores all the calls to the function.

.. GENERATED FROM PYTHON SOURCE LINES 88-95

.. code-block:: Python

    integrand_memoized = ot.MemoizeFunction(integrand)
    I_value = integration_algo.integrate(integrand_memoized, domain)
    print('I = ', I_value[0])
    print('Exact value = ', 4 * m.pi)
    nodes = integrand_memoized.getInputHistory()
    print('Nodes : ', nodes)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    I =  12.898438724470733
    Exact value =  12.566370614359172
    Nodes :      0 : [ -1        -1        ]
        1 : [ -1        -1.7746   ]
        2 : [ -1        -0.225403 ]
    ...
    11337 : [  1.68574   1.5      ]
    11338 : [  1.68574   1.1127   ]
    11339 : [  1.68574   1.8873   ]




.. GENERATED FROM PYTHON SOURCE LINES 96-99

We can draw superimpose the nodes on the graph with the iso-lines of the
function :math:`f`. We can see that the algorithm focuses on the nodes where the
function has its discontinuities.

.. GENERATED FROM PYTHON SOURCE LINES 99-107

.. code-block:: Python

    cloud_nodes = ot.Cloud(nodes)
    cloud_nodes.setPointStyle('dot')
    cloud_nodes.setColor('blue')

    g.add(cloud_nodes)
    g.setLegendPosition('')
    view = otv.View(g)




.. image-sg:: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_002.png
   :alt: Function $f(x,y) = 1_{\{x^2+y^2 \leq 4\}}(x,y)$
   :srcset: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 108-128

Case 2: The integrand function has large gradients.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We consider the function:

.. math::

   f : \begin{array}{lcl}
         \Rset^2 & \rightarrow & \Rset \\
         (x,y) & \rightarrow & e^{-(x^2+y^2)} + e^{-8((x-4)^2+(y-4)^2)}
         \end{array}

the domain :math:`\set{D} =[-2,2]\times [-2,2]` and the integral:

.. math::
   I = \int_{\set{D}} f(x,y)\, dxdy.

Using Maple, we obtain the reference value:

.. math::
   I_{ref} = 3.51961338289448753812591427600

.. GENERATED FROM PYTHON SOURCE LINES 130-131

We first define the integrand :math:`f` and the domain :math:`\set{D}`.

.. GENERATED FROM PYTHON SOURCE LINES 131-140

.. code-block:: Python



    def kernel2(x):
        return [m.exp(-(x[0]**2 + x[1]**2)) + m.exp(-8 * ((x[0] - 4)**2 + (x[1] - 4)**2))]


    integrand = ot.PythonFunction(2, 1, kernel2)
    domain = ot.Interval([-2.0, -2.0], [6.0, 6.0])








.. GENERATED FROM PYTHON SOURCE LINES 141-142

We draw the iso-lines of the integrand function.

.. GENERATED FROM PYTHON SOURCE LINES 142-147

.. code-block:: Python

    g = integrand.draw([-3.0, -3.0], [7.0, 7.0])
    g.setTitle(r'Function $f(x,y) = e^{-(x^2+y^2)} + e^{-8((x-4)^2+(y-4)^2)} $')
    g.setXTitle('x')
    g.setYTitle('y')








.. GENERATED FROM PYTHON SOURCE LINES 148-150

To get the nodes used to approximate the integral, we need to use a :class:`~openturns.MemoizeFunction`
that stores all the calls to the function.

.. GENERATED FROM PYTHON SOURCE LINES 150-156

.. code-block:: Python

    integrand_memoized = ot.MemoizeFunction(integrand)
    I_value = integration_algo.integrate(integrand_memoized, domain)
    print('I = ', I_value[0])
    nodes = integrand_memoized.getInputHistory()
    print('Nodes : ', nodes)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    I =  3.5196013466116494
    Nodes :      0 : [  0        0       ]
        1 : [  0       -1.54919 ]
        2 : [  0        1.54919 ]
    ...
    30165 : [  3.48591  4.04688 ]
    30166 : [  3.48591  4.03477 ]
    30167 : [  3.48591  4.05898 ]




.. GENERATED FROM PYTHON SOURCE LINES 157-160

We can draw in blue the nodes on the graph that contains the iso-lines of the
function :math:`f`. We can see that the algorithm focuses on the nodes where the function
has fast variations.

.. GENERATED FROM PYTHON SOURCE LINES 160-169

.. code-block:: Python

    cloud_nodes = ot.Cloud(nodes)
    cloud_nodes.setPointStyle('dot')
    cloud_nodes.setColor('blue')

    g.add(cloud_nodes)
    g.setLegendPosition('')
    view = otv.View(g)





.. image-sg:: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_003.png
   :alt: Function $f(x,y) = e^{-(x^2+y^2)} + e^{-8((x-4)^2+(y-4)^2)} $
   :srcset: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 170-191

Case 3: The integration domain is complex.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We consider the function:

.. math::

   f : \begin{array}{lcl}
         \Rset^2 & \rightarrow & \Rset \\
         (x,y) & \rightarrow & \cos(2x) \sin(1.5y)
       \end{array}

the domain :math:`\set{D} = \{(x,y)\, |\, -2\pi \leq x \leq 2\pi, -2 - \cos(x) \leq y  \leq 2 + \cos(x) \}`
and the integral:

.. math::
   I = \int_{\set{D}} f(x,y)\, dxdy.

Using Maple, we obtain the reference value:

.. math::
   I_{ref} = -0.548768615494004063851543284777

.. GENERATED FROM PYTHON SOURCE LINES 193-194

We first define the integrand :math:`f` and the domain :math:`\set{D}`.

.. GENERATED FROM PYTHON SOURCE LINES 194-202

.. code-block:: Python



    def kernel3(x):
        return [m.cos(2.0 * x[0]) * m.cos(1.5 * x[1])]


    integrand = ot.PythonFunction(2, 1, kernel3)








.. GENERATED FROM PYTHON SOURCE LINES 203-213

The integration domain is defined by the two following functions:

.. math::

   x \rightarrow u(x) = 2 + \cos(x)

.. math::

   x \rightarrow  \ell(x) = -2 - \cos(x)


.. GENERATED FROM PYTHON SOURCE LINES 213-216

.. code-block:: Python

    upper_func = ot.SymbolicFunction(["x"], [" 2 + cos(x)"])
    lower_func = ot.SymbolicFunction(["x"], ["-2 - cos(x)"])








.. GENERATED FROM PYTHON SOURCE LINES 217-220

We draw the iso-lines of the integrand function in the domain of integration.
To do that, we define a new function which is the restriction
of the integrand function to the integration domain.

.. GENERATED FROM PYTHON SOURCE LINES 220-238

.. code-block:: Python



    def kernel3_insideDomain(x):
        low_x = lower_func([x[0]])[0]
        up_x = upper_func([x[0]])[0]
        if x[1] > low_x and x[1] < up_x :
            return kernel3(x)
        else:
            return [0.0]


    integrand_domain = ot.PythonFunction(2, 1, kernel3_insideDomain)
    a = 2 * m.pi
    b = 4.0
    # Here, we increase the default number of levels.
    ot.ResourceMap.SetAsUnsignedInteger("Contour-DefaultLevelsNumber", 30)
    g = integrand_domain.draw([-a, -b], [a, b])








.. GENERATED FROM PYTHON SOURCE LINES 239-240

We add the bounds of the domain :math:`\set{D}`.

.. GENERATED FROM PYTHON SOURCE LINES 240-255

.. code-block:: Python

    low_bound = lower_func.draw([-a, -b], [a, b]).getDrawable(0)
    up_bound = upper_func.draw([-a, -b], [a, b]).getDrawable(0)
    low_bound.setColor('red')
    low_bound.setLineWidth(2)
    up_bound.setColor('red')
    up_bound.setLineWidth(2)

    g.add(low_bound)
    g.add(up_bound)
    g.setTitle(r'Function $f(x,y) =  cos(2x)sin(1.5y)$')
    g.setXTitle('x')
    g.setYTitle('y')
    view = otv.View(g)
    # sphinx_gallery_thumbnail_number = 4




.. image-sg:: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_004.png
   :alt: Function $f(x,y) =  cos(2x)sin(1.5y)$
   :srcset: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 256-258

To get the nodes used to approximate the integral, we need to use a :class:`~openturns.MemoizeFunction`
that stores all the calls to the function.

.. GENERATED FROM PYTHON SOURCE LINES 258-268

.. code-block:: Python

    integrand_memoized = ot.MemoizeFunction(integrand)
    maximumSubIntervals = 4
    maximumError = 1e-4
    GKRule = ot.GaussKronrodRule(ot.GaussKronrodRule.G7K15)
    integration_algo = ot.IteratedQuadrature(ot.GaussKronrod(maximumSubIntervals, maximumError, GKRule))
    I_value = integration_algo.integrate(integrand_memoized, -a, a, [lower_func], [upper_func])
    print('I = ', I_value[0])
    nodes = integrand_memoized.getInputHistory()
    print('Nodes : ', nodes)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    I =  -0.5487686157122131
    Nodes :     0 : [ -3.14159    -0.5        ]
       1 : [ -3.14159    -0.995728   ]
       2 : [ -3.14159    -0.00427231 ]
    ...
    2697 : [  5.03878     1.63122    ]
    2698 : [  5.03878     0.919216   ]
    2699 : [  5.03878     1.40141    ]




.. GENERATED FROM PYTHON SOURCE LINES 269-272

We can superimpose the nodes on the graph with the iso-lines of the
function :math:`f`. We can see that the algorithm focuses on the nodes where
the function has fast variations.

.. GENERATED FROM PYTHON SOURCE LINES 272-280

.. code-block:: Python

    cloud_nodes = ot.Cloud(nodes)
    cloud_nodes.setPointStyle('dot')
    cloud_nodes.setColor('black')

    g.add(cloud_nodes)
    g.setLegendPosition('')
    view = otv.View(g)




.. image-sg:: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_005.png
   :alt: Function $f(x,y) =  cos(2x)sin(1.5y)$
   :srcset: /auto_numerical_methods/general_methods/images/sphx_glr_plot_estimate_integral_iterated_quadrature_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 281-282

Reset ResourceMap

.. GENERATED FROM PYTHON SOURCE LINES 282-284

.. code-block:: Python

    ot.ResourceMap.Reload()








.. GENERATED FROM PYTHON SOURCE LINES 285-286

Show all the graphs.

.. GENERATED FROM PYTHON SOURCE LINES 286-287

.. code-block:: Python

    view.ShowAll()








.. _sphx_glr_download_auto_numerical_methods_general_methods_plot_estimate_integral_iterated_quadrature.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_estimate_integral_iterated_quadrature.ipynb <plot_estimate_integral_iterated_quadrature.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_estimate_integral_iterated_quadrature.py <plot_estimate_integral_iterated_quadrature.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_estimate_integral_iterated_quadrature.zip <plot_estimate_integral_iterated_quadrature.zip>`
