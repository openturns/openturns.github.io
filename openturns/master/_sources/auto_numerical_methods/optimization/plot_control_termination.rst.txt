.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_numerical_methods_optimization_plot_control_termination.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_auto_numerical_methods_optimization_plot_control_termination.py:


Control algorithm termination
=============================

In this examples we are going to expose ways to control the termination of optimization and simulation algorithms using callbacks.



.. code-block:: default

    from __future__ import print_function
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    import math as m
    import time
    ot.Log.Show(ot.Log.NONE)








Define an event to compute a probability


.. code-block:: default

    myFunction = ot.SymbolicFunction(['E', 'F', 'L', 'I'], ['-F*L^3/(3.0*E*I)'])
    dim = myFunction.getInputDimension()
    mean = [50.0, 1.0, 10.0, 5.0]
    sigma = [1.0] * dim
    R = ot.IdentityMatrix(dim)
    myDistribution = ot.Normal(mean, sigma, R)
    vect = ot.RandomVector(myDistribution)
    output = ot.CompositeRandomVector(myFunction, vect)
    myEvent = ot.ThresholdEvent(output, ot.Less(), -3.0)








**Stop a FORM algorithm using a calls number limit**

A FORM algorithm termination can be controlled by the maximum number of iterations

of its underlying optimization solver, but not directly by a maximum number of evaluations.

Create the optimization algorithm


.. code-block:: default

    myCobyla = ot.Cobyla()
    myCobyla.setMaximumEvaluationNumber(400)
    myCobyla.setMaximumAbsoluteError(1.0e-10)
    myCobyla.setMaximumRelativeError(1.0e-10)
    myCobyla.setMaximumResidualError(1.0e-10)
    myCobyla.setMaximumConstraintError(1.0e-10)









Define the stopping criterion


.. code-block:: default

    def stop():
        return myFunction.getCallsNumber() > 100
    myCobyla.setStopCallback(stop)








Run FORM


.. code-block:: default

    myAlgo = ot.FORM(myCobyla, myEvent, mean)
    myAlgo.run()
    result = myAlgo.getResult()
    print('event probability:', result.getEventProbability())
    print('calls number:', myFunction.getCallsNumber())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    event probability: 0.15642619199519509
    calls number: 102




**Stop a simulation algorithm using a time limit**

Here we will create a callback to not exceed a specified simulation time.

Create simulation


.. code-block:: default

    experiment = ot.MonteCarloExperiment()
    myAlgo = ot.ProbabilitySimulationAlgorithm(myEvent, experiment)
    myAlgo.setMaximumOuterSampling(1000000)
    myAlgo.setMaximumCoefficientOfVariation(-1.0)








Define the stopping criterion


.. code-block:: default

    timer = ot.TimerCallback(0.01)
    myAlgo.setStopCallback(timer)








Run algorithm


.. code-block:: default

    myAlgo.run()
    result = myAlgo.getResult()
    print('event probability:', result.getProbabilityEstimate())
    print('calls number:', myFunction.getCallsNumber())




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    event probability: 0.1405379210079961
    calls number: 4229





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.015 seconds)


.. _sphx_glr_download_auto_numerical_methods_optimization_plot_control_termination.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_control_termination.py <plot_control_termination.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_control_termination.ipynb <plot_control_termination.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
