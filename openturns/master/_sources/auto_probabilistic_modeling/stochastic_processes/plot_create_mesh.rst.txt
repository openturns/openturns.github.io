
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/stochastic_processes/plot_create_mesh.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_mesh.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_stochastic_processes_plot_create_mesh.py:


Create a mesh
=============

.. GENERATED FROM PYTHON SOURCE LINES 6-13

.. code-block:: default

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    import math as m
    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 14-27

Creation of a regular grid
--------------------------

In this first part we demonstrate how to create a regular grid. Note that a regular grid is a particular mesh of :math:`\mathcal{D}=[0,T] \in \mathbb{R}`.

Here we assume it represents the time :math:`t` as it is often the case, but it can represent any physical quantity.

A regular time grid is a regular discretization of the interval :math:`[0, T] \in \mathbb{R}` into :math:`N` points, noted :math:`(t_0, \dots, t_{N-1})`.

The time grid can be defined using :math:`(t_{Min}, \Delta t, N)` where :math:`N` is the number of points in the time grid. :math:`\Delta t` the time step between two consecutive instants and :math:`t_0 = t_{Min}`. Then,  :math:`t_k = t_{Min} + k \Delta t` and :math:`t_{Max} = t_{Min} +  (N-1) \Delta t`.


Consider :math:`X: \Omega \times \mathcal{D} \rightarrow \mathbb{R}^d` a multivariate stochastic process of dimension :math:`d`,  where :math:`n=1`, :math:`\mathcal{D}=[0,T]` and :math:`t\in \mathcal{D}` is interpreted as a time stamp. Then the mesh associated to the process :math:`X` is a (regular) time grid.

.. GENERATED FROM PYTHON SOURCE LINES 30-31

We define a time grid from a starting time `tMin`, a time step `tStep` and a number of time steps `n`.

.. GENERATED FROM PYTHON SOURCE LINES 31-36

.. code-block:: default

    tMin = 0.
    tStep = 0.1
    n = 10
    time_grid = ot.RegularGrid(tMin, tStep, n)








.. GENERATED FROM PYTHON SOURCE LINES 37-38

We get the first and the last instants, the step and the number of points :

.. GENERATED FROM PYTHON SOURCE LINES 38-44

.. code-block:: default

    start = time_grid.getStart()
    step = time_grid.getStep()
    grid_size = time_grid.getN()
    end = time_grid.getEnd()
    print('start=', start, 'step=', step, 'grid_size=', grid_size, 'end=', end)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    start= 0.0 step= 0.1 grid_size= 10 end= 1.0




.. GENERATED FROM PYTHON SOURCE LINES 45-46

We draw the grid.

.. GENERATED FROM PYTHON SOURCE LINES 46-54

.. code-block:: default

    time_grid.setName('time')
    graph = time_grid.draw()
    graph.setTitle("Time grid")
    graph.setXTitle("t")
    graph.setYTitle("")
    view = viewer.View(graph)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_001.png
   :alt: Time grid
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 55-57

Creation of a mesh
------------------

.. GENERATED FROM PYTHON SOURCE LINES 59-66

In this paragraph we create a mesh :math:`\mathcal{M}` associated to a domain :math:`\mathcal{D} \in \mathbb{R}^n`.

A mesh is defined from vertices in :math:`\mathbb{R}^n` and a topology that connects the vertices: the simplices. The simplex :math:`Indices([i_1,\dots, i_{n+1}])` relies the vertices of index :math:`(i_1,\dots, i_{n+1})` in :math:`\mathbb{N}^n`. In dimension 1, a simplex is an interval :math:`Indices([i_1,i_2])`; in dimension 2, it is a triangle :math:`Indices([i_1,i_2, i_3])`.

The library enables to easily create a mesh which is a box of dimension :math:`d=1` or :math:`d=2` regularly meshed in all its directions, thanks to the object IntervalMesher.

Consider :math:`X: \Omega \times \mathcal{D} \rightarrow \mathbb{R}^d` a multivariate stochastic process of dimension :math:`d`, where :math:`\mathcal{D} \in \mathbb{R}^n`. The mesh :math:`\mathcal{M}` is a discretization of the domain :math:`\mathcal{D}`.

.. GENERATED FROM PYTHON SOURCE LINES 68-69

A  one dimensional mesh is created and represented by :

.. GENERATED FROM PYTHON SOURCE LINES 69-76

.. code-block:: default

    vertices = [[0.5], [1.5], [2.1], [2.7]]
    simplicies = [[0, 1], [1, 2], [2, 3]]
    mesh1D = ot.Mesh(vertices, simplicies)
    graph1 = mesh1D.draw()
    graph1.setTitle('One dimensional mesh')
    view = viewer.View(graph1)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_002.png
   :alt: One dimensional mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 77-78

We define a bidimensional mesh :

.. GENERATED FROM PYTHON SOURCE LINES 78-87

.. code-block:: default

    vertices = [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0],
                [1.5, 1.0], [2.0, 1.5], [0.5, 1.5]]
    simplicies = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [2, 4, 5], [0, 2, 5]]
    mesh2D = ot.Mesh(vertices, simplicies)
    graph2 = mesh2D.draw()
    graph2.setTitle('Bidimensional mesh')
    graph2.setLegendPosition('bottomright')
    view = viewer.View(graph2)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_003.png
   :alt: Bidimensional mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 88-90

We can also define a mesh which is a regularly meshed box in dimension 1 or 2.
We define the number of intervals in each direction of the box :

.. GENERATED FROM PYTHON SOURCE LINES 90-93

.. code-block:: default

    myIndices = [5, 10]
    myMesher = ot.IntervalMesher(myIndices)








.. GENERATED FROM PYTHON SOURCE LINES 94-95

We then create the mesh of the box :math:`[0, 2] \times [0, 4]` :

.. GENERATED FROM PYTHON SOURCE LINES 95-103

.. code-block:: default

    lowerBound = [0., 0.]
    upperBound = [2., 4.]
    myInterval = ot.Interval(lowerBound, upperBound)
    myMeshBox = myMesher.build(myInterval)
    mygraph3 = myMeshBox.draw()
    mygraph3.setTitle('Bidimensional mesh on a box')
    view = viewer.View(mygraph3)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_004.png
   :alt: Bidimensional mesh on a box
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 104-105

It is possible to perform a transformation on a regularly meshed box.

.. GENERATED FROM PYTHON SOURCE LINES 105-113

.. code-block:: default

    myIndices = [20, 20]
    mesher = ot.IntervalMesher(myIndices)
    # r in [1., 2.] and theta in (0., pi]
    lowerBound2 = [1.0, 0.0]
    upperBound2 = [2.0, m.pi]
    myInterval = ot.Interval(lowerBound2, upperBound2)
    meshBox2 = mesher.build(myInterval)








.. GENERATED FROM PYTHON SOURCE LINES 114-115

We define the mapping function and draw the transformation :

.. GENERATED FROM PYTHON SOURCE LINES 115-124

.. code-block:: default

    f = ot.SymbolicFunction(['r', 'theta'], ['r*cos(theta)', 'r*sin(theta)'])
    oldVertices = meshBox2.getVertices()
    newVertices = f(oldVertices)
    meshBox2.setVertices(newVertices)
    graphMappedBox = meshBox2.draw()
    graphMappedBox.setTitle('Mapped box mesh')
    view = viewer.View(graphMappedBox)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_005.png
   :alt: Mapped box mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 125-126

Finally we create a mesh of a heart in dimension 2.

.. GENERATED FROM PYTHON SOURCE LINES 126-168

.. code-block:: default

    def meshHeart(ntheta, nr):
        # First, build the nodes
        nodes = ot.Sample(0, 2)
        nodes.add([0.0, 0.0])
        for j in range(ntheta):
            theta = (m.pi * j) / ntheta
            if (abs(theta - 0.5 * m.pi) < 1e-10):
                rho = 2.0
            elif (abs(theta) < 1e-10) or (abs(theta-m.pi) < 1e-10):
                rho = 0.0
            else:
                absTanTheta = abs(m.tan(theta))
                rho = absTanTheta**(1.0 / absTanTheta) + m.sin(theta)
            cosTheta = m.cos(theta)
            sinTheta = m.sin(theta)
            for k in range(nr):
                tau = (k + 1.0) / nr
                r = rho * tau
                nodes.add([r * cosTheta, r * sinTheta - tau])
        # Second, build the triangles
        triangles = []
        # First heart
        for j in range(ntheta):
            triangles.append([0, 1 + j * nr, 1 + ((j + 1) % ntheta) * nr])
        # Other hearts
        for j in range(ntheta):
            for k in range(nr-1):
                i0 = k + 1 + j * nr
                i1 = k + 2 + j * nr
                i2 = k + 2 + ((j + 1) % ntheta) * nr
                i3 = k + 1 + ((j + 1) % ntheta) * nr
                triangles.append([i0, i1, i2 % (nr*ntheta)])
                triangles.append([i0, i2, i3 % (nr*ntheta)])
        return ot.Mesh(nodes, triangles)


    mesh4 = meshHeart(48, 16)
    graphMesh = mesh4.draw()
    graphMesh.setTitle('Bidimensional mesh')
    graphMesh.setLegendPosition('')
    view = viewer.View(graphMesh)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_006.png
   :alt: Bidimensional mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 169-170

Display figures

.. GENERATED FROM PYTHON SOURCE LINES 170-171

.. code-block:: default

    plt.show()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  2.399 seconds)


.. _sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_mesh.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_mesh.py <plot_create_mesh.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_mesh.ipynb <plot_create_mesh.ipynb>`
