
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/stochastic_processes/plot_create_and_manipulate_arma_process.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py:


Create and manipulate an ARMA process
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 6-8

In this example we first create an ARMA process and then manipulate it.


.. GENERATED FROM PYTHON SOURCE LINES 10-17

.. code-block:: default

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt

    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 18-49

Create an ARMA process
----------------------

In this example we are going to build an ARMA process defined by its linear recurrence coefficients.

The creation of an ARMA model requires the data of the AR and MA
coefficients which are:

-  a list of scalars in the unidmensional case :
   :math:`(a_1, \dots, a_p)` for the AR-coefficients and
   :math:`(b_1, \dots, b_q)` for the MA-coefficients

-  a list of square matrix
   :math:`(\underline{\underline{A}}_{\, 1}, \dots, \underline{\underline{A}}{\, _p})` for the
   AR-coefficients and
   :math:`(\underline{\underline{B}}_{\, 1}\, \dots, \underline{\underline{B}}_{\, q})` for the
   MA-coefficients

It also requires the definition of a white noise
:math:`\underline{\varepsilon}` that contains the same time grid as the
one of the process.
The current state of an ARMA model is characterized by its last
:math:`p` values and the last :math:`q` values of its white noise. It
is possible to get that state thanks to the methods *getState*.
It is possible to create an ARMA with a specific current state. That
specific current state is taken into account to generate possible
futurs but not to generate realizations (in order to respect the
stationarity property of the model).
At the creation step, we check whether the process
:math:`ARMA(p,q)` is stationnary.
When the process is not stationary, the user is warned by a message.

.. GENERATED FROM PYTHON SOURCE LINES 51-58

We build the 1D ARMA process defined by :

.. math::
   X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}

where the white noise :math:`E_t` is defined by :math:`E_t \approx \mathrm{Triangular}(a = -1, m = 0, b = 1)`.


.. GENERATED FROM PYTHON SOURCE LINES 60-61

The definition of the recurrence coefficients AR, MA (4,2) is simple :

.. GENERATED FROM PYTHON SOURCE LINES 61-65

.. code-block:: default

    myARCoef = ot.ARMACoefficients([0.4, 0.3, 0.2, 0.1])
    myMACoef = ot.ARMACoefficients([0.4, 0.3])









.. GENERATED FROM PYTHON SOURCE LINES 66-68

We build a regular time discretization of the interval [0,1] with 10 time steps.
We also set up the white noise distribution of the recurrence relation :

.. GENERATED FROM PYTHON SOURCE LINES 68-71

.. code-block:: default

    myTimeGrid = ot.RegularGrid(0.0, 0.1, 10)
    myWhiteNoise = ot.WhiteNoise(ot.Triangular(-1.0, 0.0, 1.0), myTimeGrid)








.. GENERATED FROM PYTHON SOURCE LINES 72-73

We are now ready to create the ARMA-process :

.. GENERATED FROM PYTHON SOURCE LINES 73-77

.. code-block:: default

    process = ot.ARMA(myARCoef, myMACoef, myWhiteNoise)
    print(process)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA(X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}, E_t ~ Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 78-103

ARMA process manipulation
-------------------------

In this paragraph we shall expose some of the services exposed by an :math:`ARMA(p,q)` object, namely :

-  its AR and MA coefficients thanks to the methods *getARCoefficients,
   getMACoefficients*,

-  its white noise thanks to the method *getWhiteNoise*, that contains
   the time grid of the process,

-  its current state, that is its last :math:`p` values and the last
   :math:`q` values of its white noise, thanks to the method *getState*,

-  a realization thanks to the method *getRealization* or a sample of realizations thanks to the method *getSample*,

-  a possible future of the model, which is a possible prolongation of
   the current state on the next :math:`n_{prol}` instants, thanks to
   the method *getFuture*.

-  :math:`n` possible futures of the model, which correspond to
   :math:`n` possible prolongations of the current state on the next
   :math:`n_{prol}` instants, thanks to the method
   *getFuture* (:math:`n_{prol}`, :math:`n`).


.. GENERATED FROM PYTHON SOURCE LINES 106-107

First we get the coefficients AR and MA of the recurrence :

.. GENERATED FROM PYTHON SOURCE LINES 107-110

.. code-block:: default

    print("AR coeff = ", process.getARCoefficients())
    print("MA coeff = ", process.getMACoefficients())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    AR coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]
    shift = 2
    [[ 0.2 ]]
    shift = 3
    [[ 0.1 ]]

    MA coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]





.. GENERATED FROM PYTHON SOURCE LINES 111-112

We check that the white noise is the one we have previously defined :

.. GENERATED FROM PYTHON SOURCE LINES 112-116

.. code-block:: default

    myWhiteNoise = process.getWhiteNoise()
    print(myWhiteNoise)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    WhiteNoise(Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 117-118

We generate a possible time series realization :

.. GENERATED FROM PYTHON SOURCE LINES 118-121

.. code-block:: default

    ts = process.getRealization()
    ts.setName("ARMA realization")








.. GENERATED FROM PYTHON SOURCE LINES 122-123

We draw this time series by specifying the wanted marginal index (only 0 is available here).

.. GENERATED FROM PYTHON SOURCE LINES 123-130

.. code-block:: default

    graph0 = ts.drawMarginal(0)
    graph0.setTitle("One ARMA realization")
    graph0.setXTitle("t")
    graph0.setYTitle(r"$X_t$")
    view = viewer.View(graph0)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.png
   :alt: One ARMA realization
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 131-134

Generate a k time series
k = 5
myProcessSample = process.getSample(k)

.. GENERATED FROM PYTHON SOURCE LINES 134-140

.. code-block:: default


    # Then get the current state of the ARMA
    # armaState = process.getState()
    # print("armaState = ")
    # print(armaState)








.. GENERATED FROM PYTHON SOURCE LINES 141-142

We draw a sample of size 6 : it is six different time series.

.. GENERATED FROM PYTHON SOURCE LINES 142-156

.. code-block:: default

    size = 6
    sample = process.getSample(size)
    graph = sample.drawMarginal(0)
    graph.setTitle("Six realizations of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = viewer.View(graph)
    # plt.show()

    # We can obtain the current state of the ARMA process :
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.png
   :alt: Six realizations of the ARMA process
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[-0.579445]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[0.391824]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[0.481961]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[0.0131063]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[0.53092]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[-0.0920367]




.. GENERATED FROM PYTHON SOURCE LINES 157-158

Note that if we use the process in the meantime and ask for the current state again, it will be different.

.. GENERATED FROM PYTHON SOURCE LINES 158-171

.. code-block:: default

    ts = process.getRealization()
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)


    # From the aforementioned `armaState`, we can get the last values of :math:`X_t` and the last values
    # of the white noise :math:`E_t`.
    myLastValues = armaState.getX()
    print(myLastValues)
    myLastEpsilonValues = armaState.getEpsilon()
    print(myLastEpsilonValues)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[0.0635381]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[-0.594203]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[0.740754]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[-0.178577]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[0.662273]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[-0.143989]
    0 : [  0.0635381 ]
    1 : [ -0.594203  ]
    2 : [  0.740754  ]
    3 : [ -0.178577  ]
    0 : [  0.662273 ]
    1 : [ -0.143989 ]




.. GENERATED FROM PYTHON SOURCE LINES 172-173

We have access to the number of iterations before getting a stationary state with

.. GENERATED FROM PYTHON SOURCE LINES 173-176

.. code-block:: default

    Ntherm = process.getNThermalization()
    print("ThermalValue : %d" % Ntherm)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ThermalValue : 75




.. GENERATED FROM PYTHON SOURCE LINES 177-178

This may be important to evaluate it with another precision epsilon :

.. GENERATED FROM PYTHON SOURCE LINES 178-183

.. code-block:: default

    epsilon = 1e-8
    newThermalValue = process.computeNThermalization(epsilon)
    print("newThermalValue : %d" % newThermalValue)
    process.setNThermalization(newThermalValue)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    newThermalValue : 38




.. GENERATED FROM PYTHON SOURCE LINES 184-185

An important feature of an ARMA process is the future prediction from its current state over the next# `Nit` instants, say Nit=20.

.. GENERATED FROM PYTHON SOURCE LINES 185-187

.. code-block:: default

    Nit = 21








.. GENERATED FROM PYTHON SOURCE LINES 188-189

First we specify a current state armaState and build the corresponding ARMA process `arma` :

.. GENERATED FROM PYTHON SOURCE LINES 189-203

.. code-block:: default

    arma = ot.ARMA(myARCoef, myMACoef, myWhiteNoise, armaState)

    # Then, we generate a possible future. The last instant was :math:`t=0.9` so the future starts at
    # :math:`t=1.0`. We represent the ARMA process with a solid line and its possible future as a dashed
    # curve.
    future = arma.getFuture(Nit)
    graph = future.drawMarginal(0)
    curve = graph.getDrawable(0)
    curve.setLineStyle("dashed")
    graph0.add(curve)
    graph0.setTitle("One ARMA realization and a possible future")
    view = viewer.View(graph0)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.png
   :alt: One ARMA realization and a possible future
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 204-205

It is of course possible to generate N different possible futures over the Nit next instants.

.. GENERATED FROM PYTHON SOURCE LINES 205-209

.. code-block:: default

    N = 6
    possibleFuture_N = arma.getFuture(Nit, N)
    possibleFuture_N.setName("Possible futures")








.. GENERATED FROM PYTHON SOURCE LINES 210-211

Here we only show the future.

.. GENERATED FROM PYTHON SOURCE LINES 211-218

.. code-block:: default

    graph = possibleFuture_N.drawMarginal(0)
    graph.setTitle("Six possible futures of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = viewer.View(graph)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.png
   :alt: Six possible futures of the ARMA process
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 219-220

Display all figures

.. GENERATED FROM PYTHON SOURCE LINES 220-221

.. code-block:: default

    plt.show()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.305 seconds)


.. _sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_and_manipulate_arma_process.py <plot_create_and_manipulate_arma_process.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_and_manipulate_arma_process.ipynb <plot_create_and_manipulate_arma_process.ipynb>`
