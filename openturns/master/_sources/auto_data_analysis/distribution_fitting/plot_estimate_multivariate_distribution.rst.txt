
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_data_analysis/distribution_fitting/plot_estimate_multivariate_distribution.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_data_analysis_distribution_fitting_plot_estimate_multivariate_distribution.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_data_analysis_distribution_fitting_plot_estimate_multivariate_distribution.py:


Estimate a multivariate distribution
====================================

.. GENERATED FROM PYTHON SOURCE LINES 6-14

In this example we are going to estimate a joint distribution from a multivariate sample by fitting marginals and finding a set of copulas.

While the estimation of marginals is quite straightforward, the estimation of the dependency structure takes several steps:

- find the dependent components
- estimate a copula on each dependent bloc
- assemble the estimated copulas


.. GENERATED FROM PYTHON SOURCE LINES 16-22

.. code-block:: default

    from __future__ import print_function
    import openturns as ot
    import math as m
    ot.Log.Show(ot.Log.NONE)
    ot.RandomGenerator.SetSeed(0)








.. GENERATED FROM PYTHON SOURCE LINES 23-24

generate some multivariate data to estimate, with correlation

.. GENERATED FROM PYTHON SOURCE LINES 24-31

.. code-block:: default

    cop1 = ot.AliMikhailHaqCopula(0.6)
    cop2 = ot.ClaytonCopula(2.5)
    copula = ot.ComposedCopula([cop1, cop2])
    marginals = [ot.Uniform(5.0, 6.0), ot.Arcsine(), ot.Normal(-40.0, 3.0), ot.Triangular(100.0, 150.0, 300.0)]
    distribution = ot.ComposedDistribution(marginals, copula)
    sample = distribution.getSample(10000).getMarginal([0, 2, 3, 1])








.. GENERATED FROM PYTHON SOURCE LINES 32-33

estimate marginals

.. GENERATED FROM PYTHON SOURCE LINES 33-44

.. code-block:: default

    dimension = sample.getDimension()
    marginalFactories = []
    for factory in ot.DistributionFactory.GetContinuousUniVariateFactories():
        if str(factory).startswith('Histogram'):
            # ~ non-parametric
            continue
        marginalFactories.append(factory)
    estimated_marginals = [ot.FittingTest.BestModelBIC(sample.getMarginal(i), marginalFactories)[0] for i in range(dimension)]
    estimated_marginals






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [class=Uniform name=Uniform dimension=1 a=5.00008 b=6, class=Normal name=Normal dimension=1 mean=class=Point name=Unnamed dimension=1 values=[-39.9413] sigma=class=Point name=Unnamed dimension=1 values=[3.04363] correlationMatrix=class=CorrelationMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[1], class=Triangular name=Triangular dimension=1 a=100.476 m=151.966 b=298.667, class=Beta name=Beta dimension=1 alpha=0.49567 beta=0.497672 a=-1.0002 b=1.0002]



.. GENERATED FROM PYTHON SOURCE LINES 45-46

Find connected components of a graph defined from its adjacency matrix

.. GENERATED FROM PYTHON SOURCE LINES 48-73

.. code-block:: default

    def find_neighbours(head, covariance, to_visit, visited):
        N = covariance.getDimension()
        visited[head] = 1
        to_visit.remove(head)
        current_component = [head]
        for i in to_visit:
            # If i is connected to head and has not yet been visited
            if covariance[head, i] > 0:
                # Add i to the current component
                component = find_neighbours(i, covariance, to_visit, visited)
                current_component += component
        return current_component

    def connected_components(covariance):
        N = covariance.getDimension()
        to_visit = list(range(N))
        visited = [0] * N
        all_components = []
        for head in range(N):
            if visited[head] == 0:
                component = find_neighbours(head, covariance, to_visit, visited)
                all_components.append(sorted(component))
        return all_components









.. GENERATED FROM PYTHON SOURCE LINES 74-78

Estimate the copula
-------------------

First find the dependent components : we compute the `Spearman` correlation

.. GENERATED FROM PYTHON SOURCE LINES 80-83

.. code-block:: default

    C = sample.computeSpearmanCorrelation()
    print(C)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [[  1           0.00263067  0.00518309  0.23953    ]
     [  0.00263067  1           0.736523   -0.00576173 ]
     [  0.00518309  0.736523    1          -0.0083771  ]
     [  0.23953    -0.00576173 -0.0083771   1          ]]




.. GENERATED FROM PYTHON SOURCE LINES 84-85

We filter and consider only significantly non-zero correlations.

.. GENERATED FROM PYTHON SOURCE LINES 87-93

.. code-block:: default

    epsilon = 1.0 / m.sqrt(sample.getSize())
    for j in range(dimension):
        for i in range(j):
            C[i, j] = 1.0 if abs(C[i, j]) > epsilon else 0.0
    print(C)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    [[ 1 0 0 1 ]
     [ 0 1 1 0 ]
     [ 0 1 1 0 ]
     [ 1 0 0 1 ]]




.. GENERATED FROM PYTHON SOURCE LINES 94-102

Note that we can apply the `HypothesisTest.Spearman` test. As the null hypothesis of the test is the `independence`, we must take the complementary of the binary measure as follow:

>>>   M = ot.SymmetricMatrix(dimension)
>>>   for i in range(dimension):
>>>       M[i,i] = 1
>>>       for j in range(i):
>>>           M[i, j] = 1 - ot.HypothesisTest.Spearman(sample[:,i], sample[:,j]).getBinaryQualityMeasure()


.. GENERATED FROM PYTHON SOURCE LINES 104-105

Now we find the independent blocs:

.. GENERATED FROM PYTHON SOURCE LINES 107-110

.. code-block:: default

    blocs = connected_components(C)
    blocs





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [[0, 3], [1, 2]]



.. GENERATED FROM PYTHON SOURCE LINES 111-114

For each dependent block, we estimate the most accurate non parameteric copula.

To do this, we first need to transform the sample in such a way as to keep the copula intact but make all marginal samples follow the uniform distribution on [0,1].

.. GENERATED FROM PYTHON SOURCE LINES 116-121

.. code-block:: default

    copula_sample = ot.Sample(sample.getSize(), sample.getDimension())
    copula_sample.setDescription(sample.getDescription())
    for index in range(sample.getDimension()):
        copula_sample[:, index] = estimated_marginals[index].computeCDF(sample[:, index])








.. GENERATED FROM PYTHON SOURCE LINES 122-132

.. code-block:: default

    copulaFactories = []
    for factory in ot.DistributionFactory.GetContinuousMultiVariateFactories():
        if not factory.build().isCopula():
            continue
        if factory.getImplementation().getClassName()=='BernsteinCopulaFactory':
            continue
        copulaFactories.append(factory)
    estimated_copulas = [ot.FittingTest.BestModelBIC(copula_sample.getMarginal(bloc), copulaFactories)[0] for bloc in blocs]
    estimated_copulas





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    [class=AliMikhailHaqCopula name=AliMikhailHaqCopula dimension=2 theta=0.601685, class=ClaytonCopula name=ClaytonCopula dimension=2 theta=2.45478]



.. GENERATED FROM PYTHON SOURCE LINES 133-134

Finally we assemble the copula

.. GENERATED FROM PYTHON SOURCE LINES 136-138

.. code-block:: default

    estimated_copula_perm = ot.ComposedCopula(estimated_copulas)








.. GENERATED FROM PYTHON SOURCE LINES 139-140

Take care of the order of each bloc vs the order of original components !

.. GENERATED FROM PYTHON SOURCE LINES 142-151

.. code-block:: default

    permutation = []
    for bloc in blocs:
        permutation.extend(bloc)
    inverse_permutation = [-1] * dimension
    for i in range(dimension):
        inverse_permutation[permutation[i]] = i
    estimated_copula = estimated_copula_perm.getMarginal(inverse_permutation)
    estimated_copula






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>MarginalDistribution(distribution=ComposedCopula(AliMikhailHaqCopula(theta = 0.601685), ClaytonCopula(theta = 2.45478)), indices=[0,2,3,1])</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 152-153

We build joint distribution from marginal distributions and dependency structure:

.. GENERATED FROM PYTHON SOURCE LINES 155-157

.. code-block:: default

    estimated_distribution = ot.ComposedDistribution(estimated_marginals, estimated_copula)
    estimated_distribution





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>ComposedDistribution(Uniform(a = 5.00008, b = 6), Normal(mu = -39.9413, sigma = 3.04363), Triangular(a = 100.476, m = 151.966, b = 298.667), Beta(alpha = 0.49567, beta = 0.497672, a = -1.0002, b = 1.0002), MarginalDistribution(distribution=ComposedCopula(AliMikhailHaqCopula(theta = 0.601685), ClaytonCopula(theta = 2.45478)), indices=[0,2,3,1]))</p>
    </div>
    <br />
    <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  43.131 seconds)


.. _sphx_glr_download_auto_data_analysis_distribution_fitting_plot_estimate_multivariate_distribution.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_estimate_multivariate_distribution.py <plot_estimate_multivariate_distribution.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_estimate_multivariate_distribution.ipynb <plot_estimate_multivariate_distribution.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
