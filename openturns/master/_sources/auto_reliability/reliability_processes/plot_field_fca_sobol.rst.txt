
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_reliability/reliability_processes/plot_field_fca_sobol.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_reliability_reliability_processes_plot_field_fca_sobol.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_reliability_reliability_processes_plot_field_fca_sobol.py:


Estimate Sobol indices on a field to point function
===================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-26

In this example, we are going to perform sensitivity analysis of an application that takes
fields as input and vectors as output from a sample of data:

.. math::
    h: \left|
      \begin{array}{ccl}
         \cM_N \times (\Rset^d)^N & \rightarrow & \Rset^p \\
         \mat{X} & \mapsto & \vect{Y}
      \end{array}
    \right.

This involves these steps:

- Generate some input/output data matching the application :math:`h`
- Run the :class:`~openturns.FieldToPointFunctionalChaosAlgorithm` class
- Validate the Karhunen-Loeve decompositions of the inputs
- Validate the chaos metamodel between the KL coefficients and the outputs
- Retrieve the Sobol' indices from :class:`openturns.FieldFunctionalChaosSobolIndices`


.. GENERATED FROM PYTHON SOURCE LINES 28-31

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as otv








.. GENERATED FROM PYTHON SOURCE LINES 32-34

First build a process to generate the input data.
We assemble a 4-d process from functional and Gaussian processes.

.. GENERATED FROM PYTHON SOURCE LINES 34-49

.. code-block:: Python

    T = 3.0
    NT = 32
    tg = ot.RegularGrid(0.0, T / NT, NT)
    f1 = ot.SymbolicFunction(["t"], ["sin(t)"])
    f2 = ot.SymbolicFunction(["t"], ["cos(t)^2"])
    coeff1_dist = ot.Normal([1.0] * 2, [0.6] * 2, ot.CorrelationMatrix(2))
    p1 = ot.FunctionalBasisProcess(coeff1_dist, ot.Basis([f1, f2]), tg)
    p2 = ot.GaussianProcess(ot.SquaredExponential([1.0], [T / 4.0]), tg)
    coeff3_dist = ot.JointDistribution([ot.Uniform(), ot.Normal()])
    f1 = ot.SymbolicFunction(["t"], ["1", "0"])
    f2 = ot.SymbolicFunction(["t"], ["0", "1"])
    p3 = ot.FunctionalBasisProcess(coeff3_dist, ot.Basis([f1, f2]))
    X = ot.AggregatedProcess([p1, p2, p3])
    X.setMesh(tg)








.. GENERATED FROM PYTHON SOURCE LINES 50-51

Draw some input trajectories from our process

.. GENERATED FROM PYTHON SOURCE LINES 51-56

.. code-block:: Python

    x = X.getSample(10)
    graph = x.drawMarginal(0)
    graph.setTitle(f"{x.getSize()} input trajectories")
    _ = otv.View(graph)




.. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_001.svg
   :alt: 10 input trajectories
   :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 57-58

Generate input realizations and the corresponding output from a Field->Point function

.. GENERATED FROM PYTHON SOURCE LINES 58-78

.. code-block:: Python



    class pyf2p(ot.OpenTURNSPythonFieldToPointFunction):
        def __init__(self, mesh):
            super(pyf2p, self).__init__(mesh, 4, 1)
            self.setInputDescription(["x1", "x2", "x3", "x4"])
            self.setOutputDescription(["y"])

        def _exec(self, X):
            Xs = ot.Sample(X)
            x1, x2, x3, x4 = Xs.computeMean()
            y = x1 + x2 + x3 - x4 + x1 * x2 - x3 * x4 - 0.1 * x1 * x2 * x3
            return [y]


    f = ot.FieldToPointFunction(pyf2p(tg))
    N = 1000
    x = X.getSample(N)
    y = f(x)








.. GENERATED FROM PYTHON SOURCE LINES 79-81

Run the field-vector algorithm that performs KL-decomposition of the inputs
and chaos learning between the KL coefficients and the output vectors

.. GENERATED FROM PYTHON SOURCE LINES 81-99

.. code-block:: Python

    algo = ot.FieldToPointFunctionalChaosAlgorithm(x, y)
    # 1. KL parameters
    algo.setCenteredSample(False)  # our input sample is not centered (default)
    algo.setThreshold(4e-2)  # we expect to explain 96% of variance
    algo.setRecompress(
        False
    )  # whether to re-truncate modes according to a global eigen value threshold across inputs (default)
    algo.setNbModes(10)  # max KL modes (default=unlimited)
    # 2. chaos parameters:
    bs = ot.ResourceMap.GetAsUnsignedInteger("FunctionalChaosAlgorithm-BasisSize")
    ot.ResourceMap.SetAsUnsignedInteger(
        "FunctionalChaosAlgorithm-BasisSize", N
    )  # chaos basis size
    ot.ResourceMap.SetAsBool("FunctionalChaosAlgorithm-Sparse", True)
    algo.run()
    ot.ResourceMap.SetAsUnsignedInteger("FunctionalChaosAlgorithm-BasisSize", bs)
    result = algo.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 100-102

Retrieve the eigen values of each KL decomposition:
we observe that each input process is represented by a different number of modes.

.. GENERATED FROM PYTHON SOURCE LINES 102-106

.. code-block:: Python

    kl_results = result.getInputKLResultCollection()
    n_modes = [len(res.getEigenvalues()) for res in kl_results]
    print(f"n_modes={n_modes}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    n_modes=[2, 3, 1, 1]




.. GENERATED FROM PYTHON SOURCE LINES 107-109

Retrieve the ratios of selected variance over cumulated variance:
we see that all 3 inputs are perfectly represented, and the 2nd input almost perfectly.

.. GENERATED FROM PYTHON SOURCE LINES 109-112

.. code-block:: Python

    ratios = [res.getSelectionRatio() for res in kl_results]
    print(f"ratios={ratios}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ratios=[1.0, 0.9851877006609379, 1.0, 1.0]




.. GENERATED FROM PYTHON SOURCE LINES 113-116

Graphically validate the KL decompositions:
we also see that the 2nd input appear to be less well represented than the others.
Note however that the 0.98 selected/cumulated variance ratio actually means it is very good.

.. GENERATED FROM PYTHON SOURCE LINES 116-124

.. code-block:: Python

    graphs = []
    for i in range(x.getDimension()):
        validation = ot.KarhunenLoeveValidation(x.getMarginal(i), kl_results[i])
        graph = validation.drawValidation().getGraph(0, 0)
        graph.setTitle(f"KL validation - marginal #{i} ratio={100.0 * ratios[i]:.2f} %")
        otv.View(graph)
        graphs.append(graph)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_002.svg
         :alt: KL validation - marginal #0 ratio=100.00 %
         :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_002.svg
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_003.svg
         :alt: KL validation - marginal #1 ratio=98.52 %
         :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_003.svg
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_004.svg
         :alt: KL validation - marginal #2 ratio=100.00 %
         :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_004.svg
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_005.svg
         :alt: KL validation - marginal #3 ratio=100.00 %
         :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_005.svg
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 125-127

On the 2nd marginal we can filter out the points inside the 99% level-set
to see that actually only a few points out of N are actually outliers.

.. GENERATED FROM PYTHON SOURCE LINES 127-146

.. code-block:: Python

    graph = graphs[1]
    data = graph.getDrawable(1).getData()
    normal = ot.NormalFactory().build(data)
    log_pdf = normal.computeLogPDF(data).asPoint()
    l_pair = [(log_pdf[i], data[i]) for i in range(len(data))]
    l_pair.sort(key=lambda t: t[0])
    index_bad = int(0.01 * len(data))  # here 0.01 = (100-99)%
    beta = l_pair[index_bad][0]
    gnorm = normal.drawLogPDF(data.getMin(), data.getMax())
    bad = [l_pair[i][1] for i in range(index_bad + 1)]
    c = ot.Cloud(bad)
    c.setPointStyle("bullet")
    graph.setDrawable(1, c)
    dr = gnorm.getDrawable(0)
    dr.setLevels([beta])
    dr.setLegend("99% level-set")
    graph.add(dr)
    _ = otv.View(graph)




.. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_006.svg
   :alt: KL validation - marginal #1 ratio=98.52 %
   :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_006.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 147-150

Graphically validate the chaos result:
we can see the points are very close to the diagonal; this means
approximated points are very close to the learning points.

.. GENERATED FROM PYTHON SOURCE LINES 150-161

.. code-block:: Python

    modes = result.getModesSample()
    metamodel = result.getFCEResult().getMetaModel()
    output = result.getOutputSample()
    metamodelPredictions = metamodel(modes)
    validation = ot.MetaModelValidation(output, metamodelPredictions)
    r2Score = validation.computeR2Score()
    print(f"R2={r2Score}")
    graph = validation.drawValidation()
    graph.setTitle(f"Chaos validation - R2={r2Score}")
    _ = otv.View(graph)




.. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_007.svg
   :alt: Chaos validation - R2=[0.999986]
   :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_007.svg
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    R2=[0.999986]




.. GENERATED FROM PYTHON SOURCE LINES 162-164

Perform an evaluation on a new realization and ensure the output
is close to the evaluation with the reference function

.. GENERATED FROM PYTHON SOURCE LINES 164-170

.. code-block:: Python

    metamodel = result.getFieldToPointMetaModel()
    x0 = X.getRealization()
    y0 = f(x0)
    y0hat = metamodel(x0)
    print(f"y0={y0} y0^={y0hat}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    y0=[6.01011] y0^=[6.00689]




.. GENERATED FROM PYTHON SOURCE LINES 171-173

Retrieve the first order Sobol' indices
The preponderant variables are x2, x4 whereas x1, x3 have a low influence on the output

.. GENERATED FROM PYTHON SOURCE LINES 173-177

.. code-block:: Python

    sensitivity = ot.FieldFunctionalChaosSobolIndices(result)
    sobol_0 = sensitivity.getFirstOrderIndices()
    print(f"first order={sobol_0}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    first order=[0.066632,0.441135,0.0953934,0.275428]




.. GENERATED FROM PYTHON SOURCE LINES 178-181

Retrieve the total Sorder obol' indices
The x3,x4 variables have total order indices significantly different than
their first order indices counterpart meaning they interact with other variables

.. GENERATED FROM PYTHON SOURCE LINES 181-184

.. code-block:: Python

    sobol_0t = sensitivity.getTotalOrderIndices()
    print(f"total order={sobol_0t}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    total order=[0.0902712,0.465189,0.193238,0.372786]




.. GENERATED FROM PYTHON SOURCE LINES 185-186

Draw the Sobol' indices

.. GENERATED FROM PYTHON SOURCE LINES 186-189

.. code-block:: Python

    graph = sensitivity.draw()
    view = otv.View(graph)




.. image-sg:: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_008.svg
   :alt: Sobol' indices
   :srcset: /auto_reliability/reliability_processes/images/sphx_glr_plot_field_fca_sobol_008.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 190-191

.. code-block:: Python

    otv.View.ShowAll()








.. _sphx_glr_download_auto_reliability_reliability_processes_plot_field_fca_sobol.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_field_fca_sobol.ipynb <plot_field_fca_sobol.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_field_fca_sobol.py <plot_field_fca_sobol.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_field_fca_sobol.zip <plot_field_fca_sobol.zip>`
