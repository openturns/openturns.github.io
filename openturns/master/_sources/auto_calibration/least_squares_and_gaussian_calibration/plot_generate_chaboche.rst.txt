
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_calibration/least_squares_and_gaussian_calibration/plot_generate_chaboche.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_calibration_least_squares_and_gaussian_calibration_plot_generate_chaboche.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_calibration_least_squares_and_gaussian_calibration_plot_generate_chaboche.py:


Generate observations of the Chaboche mechanical model
======================================================

In this example we present the simulation of noisy observations of the Chaboche model.
A detailed explanation of this mechanical law is presented :ref:`here <use-case-chaboche>`.
We show how to produce the observations that we use in the calibration
model of :doc:`Calibration of the Chaboche model
</auto_calibration/least_squares_and_gaussian_calibration/plot_calibration_chaboche>`.

Parameters to calibrate
-----------------------

The vector of parameters to calibrate is:

.. math::

   \theta = (R,C,\gamma).


The true values of the parameters are:

- :math:`R = 750\times 10^6`,
- :math:`C = 2750\times 10^6`,
- :math:`\gamma = 10`.

This is the set of *true* values that we wish to estimate with the calibration
methods.
In practical studies, these values are unknown.

Observations
------------

In order to create a calibration problem, we make the hypothesis that the
strain has the following distribution:

.. math::
   \epsilon \sim \mathcal{U}(0,0.07).

where :math:`\mathcal{U}` is the uniform distribution.
Moreover, we consider a Gaussian noise on the observed constraint:

.. math::
   \epsilon_\sigma \sim \mathcal{N} \left(0,10\times 10^6\right)


and we make the hypothesis that the observation errors are independent.
We set the number of observations to:

.. math::

   n = 10.


We generate a Monte-Carlo sample with size :math:`n`:

.. math::

   \sigma_i = g(\epsilon_i,R,C,\gamma) + (\epsilon_\sigma)_i,


for :math:`i = 1,..., n`.
The observations are the pairs :math:`\{(\epsilon_i,\sigma_i)\}_{i=1,...,n}`,
i.e. each observation is a couple made of the strain and the corresponding stress.

Variables
---------

In the particular situation where we want to calibrate this model, the following
list presents which variables are observed input variables, input calibrated
variables and observed output variables.

- :math:`\epsilon`: Input. Observed.
- :math:`R`, :math:`C`, :math:`\gamma` : Inputs. Calibrated.
- :math:`\sigma`: Output. Observed.

.. GENERATED FROM PYTHON SOURCE LINES 79-85

.. code-block:: default

    import openturns as ot
    import openturns.viewer as otv
    from openturns.usecases import chaboche_model

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 86-94

Generate the observations
-------------------------
In practice, we generally use a data set which has been obtained from
measurements.
In this example, we generate the data using noisy observations of the
physical model.
In the next part, we will calibrate the parameters using the calibration
algorithms.

.. GENERATED FROM PYTHON SOURCE LINES 96-97

Load the Chaboche model

.. GENERATED FROM PYTHON SOURCE LINES 99-103

.. code-block:: default

    cm = chaboche_model.ChabocheModel()
    print("Inputs:", cm.model.getInputDescription())
    print("Outputs:", cm.model.getOutputDescription())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Inputs: [Strain,R,C,Gamma]
    Outputs: [Sigma]




.. GENERATED FROM PYTHON SOURCE LINES 104-110

We see that there are four inputs: `Strain`, `R`, `C` and `Gamma` and one
output: `Sigma`.
The `Strain` is observed on input and the stress `Sigma` is observed on
output.
Using these observations, we want to estimate the parameters `R`, `C`
and `Gamma`.

.. GENERATED FROM PYTHON SOURCE LINES 112-113

We get the Chaboche model and the joint input distribution :

.. GENERATED FROM PYTHON SOURCE LINES 115-118

.. code-block:: default

    inputDistribution = cm.inputDistribution
    print("inputDistribution:", inputDistribution)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    inputDistribution: ComposedDistribution(Uniform(a = 0, b = 0.07), Dirac(point = [7.5e+08]), Dirac(point = [2.75e+09]), Dirac(point = [10]), IndependentCopula(dimension = 4))




.. GENERATED FROM PYTHON SOURCE LINES 119-125

Set the calibration parameters
------------------------------
In this part, we begin the calibration study.
Define the value of the reference values of the :math:`\theta` parameter.
In the Bayesian framework, this is called the mean of the *prior* Gaussian
distribution. In the data assimilation framework, this is called the *background*.

.. GENERATED FROM PYTHON SOURCE LINES 127-134

.. code-block:: default

    thetaTrue = [cm.trueR, cm.trueC, cm.trueGamma]
    print("theta True = ")
    print("    R = %.2f (MPa)" % (cm.trueR / 1.0e6))
    print("    C = %.2f (MPa)" % (cm.trueC / 1.0e6))
    print("    Gamma = %.4f" % (cm.trueGamma))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    theta True = 
        R = 750.00 (MPa)
        C = 2750.00 (MPa)
        Gamma = 10.0000




.. GENERATED FROM PYTHON SOURCE LINES 135-138

The following statement create the calibrated function from the model.
The calibrated parameters `R`, `C`, `Gamma` are at indices 1, 2, 3 in
the inputs arguments of the model.

.. GENERATED FROM PYTHON SOURCE LINES 140-143

.. code-block:: default

    calibratedIndices = [1, 2, 3]
    mycf = ot.ParametricFunction(cm.model, calibratedIndices, thetaTrue)








.. GENERATED FROM PYTHON SOURCE LINES 144-145

Create a regular grid of the strains and evaluate the corresponding outputs.

.. GENERATED FROM PYTHON SOURCE LINES 147-153

.. code-block:: default

    nbobs = 10
    step = (cm.strainMax - cm.strainMin) / (nbobs - 1)
    rg = ot.RegularGrid(cm.strainMin, step, nbobs)
    observedStrain = rg.getVertices()
    predictedStress = mycf(observedStrain)








.. GENERATED FROM PYTHON SOURCE LINES 154-157

Generate observation noise.
Here we consider a Gaussian observation noise, that we add
to the output of the model.

.. GENERATED FROM PYTHON SOURCE LINES 159-164

.. code-block:: default

    stressObservationNoiseSigma = 10.0e6  # (Pa)
    noiseSigma = ot.Normal(0.0, stressObservationNoiseSigma)
    sampleNoiseStress = noiseSigma.getSample(nbobs)
    observedStress = predictedStress + sampleNoiseStress








.. GENERATED FROM PYTHON SOURCE LINES 165-166

Gather the data into a sample.

.. GENERATED FROM PYTHON SOURCE LINES 168-173

.. code-block:: default

    data = ot.Sample(nbobs, 2)
    data[:, 0] = observedStrain
    data[:, 1] = observedStress
    print(data)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0 : [ 0           7.63202e+08 ]
    1 : [ 0.00777778  7.43351e+08 ]
    2 : [ 0.0155556   7.88254e+08 ]
    3 : [ 0.0233333   7.99952e+08 ]
    4 : [ 0.0311111   8.1744e+08  ]
    5 : [ 0.0388889   8.26747e+08 ]
    6 : [ 0.0466667   8.53887e+08 ]
    7 : [ 0.0544444   8.84789e+08 ]
    8 : [ 0.0622222   8.75788e+08 ]
    9 : [ 0.07        8.79769e+08 ]




.. GENERATED FROM PYTHON SOURCE LINES 174-175

Then we plot the model and compare it to the observations.

.. GENERATED FROM PYTHON SOURCE LINES 177-196

.. code-block:: default

    graph = ot.Graph("Model with true parameters", "Strain", "Stress (MPa)", True)
    # Plot the model
    curve = mycf.draw(cm.strainMin, cm.strainMax, 50).getDrawable(
        0
    )
    curve.setLegend("True model")
    curve.setLineStyle(ot.ResourceMap.GetAsString("CalibrationResult-ObservationLineStyle"))
    graph.add(curve)
    # Plot the noisy observations
    cloud = ot.Cloud(observedStrain, observedStress)
    cloud.setLegend("Observations")
    cloud.setPointStyle(
        ot.ResourceMap.GetAsString("CalibrationResult-ObservationPointStyle")
    )
    graph.add(cloud)
    graph.setColors(ot.Drawable.BuildDefaultPalette(2))
    graph.setLegendPosition("topleft")
    view = otv.View(graph)




.. image-sg:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_generate_chaboche_001.png
   :alt: Model with true parameters
   :srcset: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_generate_chaboche_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 197-201

We see that the observations are relatively noisy, but that the
trend is clear: this shows that it may be possible to fit the model.
At this point, we have a data set that we can use for calibration
and a model to calibrate.

.. GENERATED FROM PYTHON SOURCE LINES 201-203

.. code-block:: default


    otv.View.ShowAll()








.. _sphx_glr_download_auto_calibration_least_squares_and_gaussian_calibration_plot_generate_chaboche.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_generate_chaboche.py <plot_generate_chaboche.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_generate_chaboche.ipynb <plot_generate_chaboche.ipynb>`
