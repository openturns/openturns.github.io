
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_gpr_isotropic.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_gpr_isotropic.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_gpr_isotropic.py:


Gaussian Process Regression: use an isotropic covariance kernel
===============================================================

In typical machine learning applications, Gaussian process regression
surrogate models take several inputs,
and those inputs are usually heterogeneous
(e.g. in the :doc:`cantilever beam
</auto_meta_modeling/kriging_metamodel/plot_gpr_cantilever_beam>` use case,
inputs are various physical quantities).

In geostatistical applications however, inputs are typically spatial
coordinates, which means one can assume the output varies at the same rate
in all directions.
This calls for a specific kind of covariance kernel, represented
in the library by the :class:`~openturns.IsotropicCovarianceModel` class.

.. GENERATED FROM PYTHON SOURCE LINES 18-21

.. code-block:: Python


    # TODO : change reference to plot_gpr_cantilever_beam








.. GENERATED FROM PYTHON SOURCE LINES 22-25

Modeling temperature across a surface
-------------------------------------
In this example, we collect temperature data over a floorplan using sensors.

.. GENERATED FROM PYTHON SOURCE LINES 27-50

.. code-block:: Python

    import numpy as np
    import openturns as ot
    import openturns.experimental as otexp
    import matplotlib.pyplot as plt


    coordinates = ot.Sample(
        [
            [100.0, 100.0],
            [500.0, 100.0],
            [900.0, 100.0],
            [100.0, 350.0],
            [500.0, 350.0],
            [900.0, 350.0],
            [100.0, 600.0],
            [500.0, 600.0],
            [900.0, 600.0],
        ]
    )
    observations = ot.Sample(
        [[25.0], [25.0], [10.0], [20.0], [25.0], [20.0], [15.0], [25.0], [25.0]]
    )








.. GENERATED FROM PYTHON SOURCE LINES 51-52

Let us plot the data.

.. GENERATED FROM PYTHON SOURCE LINES 52-63

.. code-block:: Python


    # Extract coordinates.
    x = np.array(coordinates[:, 0])
    y = np.array(coordinates[:, 1])

    # Plot the data with a scatter plot and a color map.
    fig = plt.figure()
    plt.scatter(x, y, c=observations, cmap="viridis")
    plt.colorbar()
    plt.show()




.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_isotropic_001.svg
   :alt: plot gpr isotropic
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_isotropic_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 64-67

Because we are going to view several Gaussian Process Regression models in this example,
we use a function to automate the process of optimizing the scale parameter
and producing the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 67-103

.. code-block:: Python


    lower = 50.0
    upper = 1000.0


    def fitGPR(coordinates, observations, covarianceModel, basis):
        """
        Fit the parameters of a Gaussian Process Regression surrogate model.
        """
        # Set the starting scale for the optimization.
        scale_dimension = covarianceModel.getScale().getDimension()
        covarianceModel.setScale([upper] * scale_dimension)

        # Prepare to fit Gaussian process hyperparameters.
        fitter = otexp.GaussianProcessFitter(
            coordinates, observations, covarianceModel, basis
        )

        # Set the optimization bounds for the scale parameter to sensible values
        # given the data set.
        fitter.setOptimizationBounds(
            ot.Interval([lower] * scale_dimension, [upper] * scale_dimension)
        )

        # Fit the GP hyperparameters.
        fitter.run()
        fitter_result = fitter.getResult()

        # Based on the GP hyperparameters perform the regression.
        regression = otexp.GaussianProcessRegression(fitter_result)
        regression.run()
        result = regression.getResult()
        surrogate = result.getMetaModel()
        return result, surrogate









.. GENERATED FROM PYTHON SOURCE LINES 104-105

Let us define a helper function to plot Gaussian Process Regression predictions.

.. GENERATED FROM PYTHON SOURCE LINES 105-138

.. code-block:: Python



    def plotGPRPredictions(gprModel):
        """
        Plot the predictions of a Gaussian Process Regression surrogate model.
        """
        # Create the mesh of the box [0., 1000.] * [0., 700.]
        myInterval = ot.Interval([0.0, 0.0], [1000.0, 700.0])

        # Define the number of intervals in each direction of the box
        nx = 20
        ny = 20
        myIndices = [nx - 1, ny - 1]
        myMesher = ot.IntervalMesher(myIndices)
        myMeshBox = myMesher.build(myInterval)

        # Predict
        vertices = myMeshBox.getVertices()
        predictions = gprModel(vertices)

        # Format for plot
        X = np.array(vertices[:, 0]).reshape((ny, nx))
        Y = np.array(vertices[:, 1]).reshape((ny, nx))
        predictions_array = np.array(predictions).reshape((ny, nx))

        # Plot
        plt.figure()
        plt.pcolormesh(X, Y, predictions_array, shading="auto")
        plt.colorbar()
        plt.show()
        return









.. GENERATED FROM PYTHON SOURCE LINES 139-143

Predict with an anisotropic geometric covariance kernel
-------------------------------------------------------
In order to illustrate the usefulness of isotropic covariance kernels,
we first perform prediction with an anisotropic geometric kernel.

.. GENERATED FROM PYTHON SOURCE LINES 145-152

Keep in mind that, when there are more than one input dimension,
the :class:`~openturns.CovarianceModel` classes use a multidimensional
scale parameter :math:`\vect{\theta}`.
They are anisotropic geometric by default.

Our example has two input dimensions,
so :math:`\vect{\theta} = (\theta_1, \theta_2)`.

.. GENERATED FROM PYTHON SOURCE LINES 152-160

.. code-block:: Python



    inputDimension = 2
    basis = ot.ConstantBasisFactory(inputDimension).build()
    covarianceModel = ot.SquaredExponential(inputDimension)
    gpr_result, surrogate_model = fitGPR(coordinates, observations, covarianceModel, basis)
    plotGPRPredictions(surrogate_model)




.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_isotropic_002.svg
   :alt: plot gpr isotropic
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_isotropic_002.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 161-164

We see weird vertical columns on the plot.
How did this happen? Let us have a look at the optimized scale parameter
:math:`\hat{\vect{\theta}} = (\hat{\theta}_1, \hat{\theta}_2)`.

.. GENERATED FROM PYTHON SOURCE LINES 164-166

.. code-block:: Python


    print(gpr_result.getCovarianceModel().getScale())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [924.809,934.83]




.. GENERATED FROM PYTHON SOURCE LINES 167-168

The value of :math:`\hat{\theta}_1` is actually equal to the lower bound:

.. GENERATED FROM PYTHON SOURCE LINES 168-171

.. code-block:: Python


    print(lower)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    50.0




.. GENERATED FROM PYTHON SOURCE LINES 172-174

This means that temperatures are likely to vary a lot along the X axis
and much slower across the Y axis based on the observation data.

.. GENERATED FROM PYTHON SOURCE LINES 176-181

Predict with an isotropic covariance kernel
---------------------------------------------------
If we know that variations of the temperature are isotropic
(i.e. with no priviledged direction),
we can embed this information within the covariance kernel.

.. GENERATED FROM PYTHON SOURCE LINES 181-184

.. code-block:: Python


    isotropic = ot.IsotropicCovarianceModel(ot.SquaredExponential(), inputDimension)








.. GENERATED FROM PYTHON SOURCE LINES 185-190

The :class:`~openturns.IsotropicCovarianceModel` class creates an isotropic
version with a given input dimension of a :class:`~openturns.CovarianceModel`.
Because is isotropic, it only needs one scale parameter :math:`\theta_{iso}`
and it will make sure :math:`\theta_1 = \theta_2 = \theta_{iso}` at all times
during the optimization.

.. GENERATED FROM PYTHON SOURCE LINES 190-194

.. code-block:: Python


    gpr_result, surrogate_model = fitGPR(coordinates, observations, isotropic, basis)
    print(gpr_result.getCovarianceModel().getScale())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [900.2]




.. GENERATED FROM PYTHON SOURCE LINES 195-196

Prediction with the isotropic covariance kernel is much more satisfactory.

.. GENERATED FROM PYTHON SOURCE LINES 196-199

.. code-block:: Python


    # sphinx_gallery_thumbnail_number = 3
    plotGPRPredictions(surrogate_model)



.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_isotropic_003.svg
   :alt: plot gpr isotropic
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_isotropic_003.svg
   :class: sphx-glr-single-img






.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_gpr_isotropic.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_gpr_isotropic.ipynb <plot_gpr_isotropic.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_gpr_isotropic.py <plot_gpr_isotropic.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_gpr_isotropic.zip <plot_gpr_isotropic.zip>`
