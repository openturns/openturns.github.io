
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_kriging_sequential.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_sequential.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_kriging_sequential.py:


Sequentially adding new points to a kriging
===========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-7

In this example, we show how to sequentially add new points to a kriging in order to improve the predictivity of the metamodel. In order to create simple graphics, we consider a 1D function.

.. GENERATED FROM PYTHON SOURCE LINES 9-11

Create the function and the design of experiments
-------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 13-20

.. code-block:: default

    import openturns as ot
    from openturns.viewer import View
    import numpy as np
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 21-24

.. code-block:: default

    sampleSize = 4
    dimension = 1








.. GENERATED FROM PYTHON SOURCE LINES 25-26

Define the function.

.. GENERATED FROM PYTHON SOURCE LINES 28-30

.. code-block:: default

    g = ot.SymbolicFunction(['x'], ['0.5*x^2 + sin(2.5*x)'])








.. GENERATED FROM PYTHON SOURCE LINES 31-32

Create the design of experiments.

.. GENERATED FROM PYTHON SOURCE LINES 34-40

.. code-block:: default

    xMin = -0.9
    xMax = 1.9
    X_distr = ot.Uniform(xMin, xMax)
    X = ot.LHSExperiment(X_distr, sampleSize, False, False).generate()
    Y = g(X)








.. GENERATED FROM PYTHON SOURCE LINES 41-48

.. code-block:: default

    graph = g.draw(xMin, xMax)
    data = ot.Cloud(X, Y)
    data.setColor("red")
    graph.add(data)
    view = viewer.View(graph)





.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_001.png
   :alt: y0 as a function of x
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 49-51

Create the algorithms
---------------------

.. GENERATED FROM PYTHON SOURCE LINES 53-66

.. code-block:: default

    def createMyBasicKriging(X, Y):
        '''
        Create a kriging from a pair of X and Y samples.
        We use a 3/2 Mat√©rn covariance model and a constant trend.
        '''
        basis = ot.ConstantBasisFactory(dimension).build()
        covarianceModel = ot.MaternModel([1.0], 1.5)
        algo = ot.KrigingAlgorithm(X, Y, covarianceModel, basis)
        algo.run()
        krigResult = algo.getResult()
        return krigResult









.. GENERATED FROM PYTHON SOURCE LINES 67-76

.. code-block:: default

    def linearSample(xmin, xmax, npoints):
        '''Returns a sample created from a regular grid
        from xmin to xmax with npoints points.'''
        step = (xmax-xmin)/(npoints-1)
        rg = ot.RegularGrid(xmin, step, npoints)
        vertices = rg.getVertices()
        return vertices









.. GENERATED FROM PYTHON SOURCE LINES 77-93

.. code-block:: default

    def plot_kriging_bounds(vLow, vUp, n_test):
        '''
        From two lists containing the lower and upper bounds of the region,
        create a PolygonArray.
        '''
        palette = ot.Drawable.BuildDefaultPalette(2)
        myPaletteColor = palette[1]
        polyData = [[vLow[i], vLow[i+1], vUp[i+1], vUp[i]]
                    for i in range(n_test-1)]
        polygonList = [ot.Polygon(
            polyData[i], myPaletteColor, myPaletteColor) for i in range(n_test-1)]
        boundsPoly = ot.PolygonArray(polygonList)
        boundsPoly.setLegend("95% bounds")
        return boundsPoly









.. GENERATED FROM PYTHON SOURCE LINES 94-95

The following `sqrt` function will be used later to compute the standard deviation from the variance.

.. GENERATED FROM PYTHON SOURCE LINES 97-100

.. code-block:: default

    sqrt = ot.SymbolicFunction(["x"], ["sqrt(x)"])









.. GENERATED FROM PYTHON SOURCE LINES 101-164

.. code-block:: default

    def plotMyBasicKriging(krigResult, xMin, xMax, X, Y, level=0.95):
        '''
        Given a kriging result, plot the data, the kriging metamodel
        and a confidence interval.
        '''
        samplesize = X.getSize()
        meta = krigResult.getMetaModel()
        graphKriging = meta.draw(xMin, xMax)
        graphKriging.setLegends(["Kriging"])
        # Create a grid of points and evaluate the function and the kriging
        nbpoints = 50
        xGrid = linearSample(xMin, xMax, nbpoints)
        yFunction = g(xGrid)
        yKrig = meta(xGrid)
        # Compute the conditional covariance
        epsilon = ot.Sample(nbpoints, [1.e-8])
        conditionalVariance = krigResult.getConditionalMarginalVariance(
            xGrid)+epsilon
        conditionalSigma = sqrt(conditionalVariance)
        # Compute the quantile of the Normal distribution
        alpha = 1-(1-level)/2
        quantileAlpha = ot.DistFunc.qNormal(alpha)
        # Graphics of the bounds
        epsilon = 1.e-8
        dataLower = [yKrig[i, 0] - quantileAlpha * conditionalSigma[i, 0]
                     for i in range(nbpoints)]
        dataUpper = [yKrig[i, 0] + quantileAlpha * conditionalSigma[i, 0]
                     for i in range(nbpoints)]
        # Coordinates of the vertices of the Polygons
        vLow = [[xGrid[i, 0], dataLower[i]] for i in range(nbpoints)]
        vUp = [[xGrid[i, 0], dataUpper[i]] for i in range(nbpoints)]
        # Compute the Polygon graphics
        boundsPoly = plot_kriging_bounds(vLow, vUp, nbpoints)
        boundsPoly.setLegend("95% bounds")
        # Validate the kriging metamodel
        mmv = ot.MetaModelValidation(xGrid, yFunction, meta)
        Q2 = mmv.computePredictivityFactor()[0]
        # Plot the function
        graphFonction = ot.Curve(xGrid, yFunction)
        graphFonction.setLineStyle("dashed")
        graphFonction.setColor("magenta")
        graphFonction.setLineWidth(2)
        graphFonction.setLegend("Function")
        # Draw the X and Y observed
        cloudDOE = ot.Cloud(X, Y)
        cloudDOE.setPointStyle("circle")
        cloudDOE.setColor("red")
        cloudDOE.setLegend("Data")
        # Assemble the graphics
        graph = ot.Graph()
        graph.add(boundsPoly)
        graph.add(graphFonction)
        graph.add(cloudDOE)
        graph.add(graphKriging)
        graph.setLegendPosition("bottomright")
        graph.setAxes(True)
        graph.setGrid(True)
        graph.setTitle("Size = %d, Q2=%.2f%%" % (samplesize, 100*Q2))
        graph.setXTitle("X")
        graph.setYTitle("Y")
        return graph









.. GENERATED FROM PYTHON SOURCE LINES 165-166

We start by creating the initial kriging metamodel on the 4 points in the design of experiments.

.. GENERATED FROM PYTHON SOURCE LINES 168-173

.. code-block:: default

    krigResult = createMyBasicKriging(X, Y)
    graph = plotMyBasicKriging(krigResult, xMin, xMax, X, Y)
    view = viewer.View(graph)





.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_002.png
   :alt: Size = 4, Q2=96.34%
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 174-176

Sequentially add new points
---------------------------

.. GENERATED FROM PYTHON SOURCE LINES 178-179

The following function is the building block of the algorithm. It returns a new point which maximizes the conditional variance.

.. GENERATED FROM PYTHON SOURCE LINES 181-194

.. code-block:: default

    def getNewPoint(xMin, xMax, krigResult):
        '''
        Returns a new point to be added to the design of experiments.
        This point maximizes the conditional variance of the kriging.
        '''
        nbpoints = 50
        xGrid = linearSample(xMin, xMax, nbpoints)
        conditionalVariance = krigResult.getConditionalMarginalVariance(xGrid)
        iMaxVar = int(np.argmax(conditionalVariance))
        xNew = xGrid[iMaxVar, 0]
        xNew = ot.Point([xNew])
        return xNew








.. GENERATED FROM PYTHON SOURCE LINES 195-196

We first call `getNewPoint` to get a point to add to the design of experiments.

.. GENERATED FROM PYTHON SOURCE LINES 199-202

.. code-block:: default

    xNew = getNewPoint(xMin, xMax, krigResult)
    xNew






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[-0.9]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 203-204

Then we evaluate the function on the new point and add it to the training design of experiments.

.. GENERATED FROM PYTHON SOURCE LINES 206-210

.. code-block:: default

    yNew = g(xNew)
    X.add(xNew)
    Y.add(yNew)








.. GENERATED FROM PYTHON SOURCE LINES 211-212

We now plot the updated kriging.

.. GENERATED FROM PYTHON SOURCE LINES 214-215

sphinx_gallery_thumbnail_number = 3

.. GENERATED FROM PYTHON SOURCE LINES 215-220

.. code-block:: default

    krigResult = createMyBasicKriging(X, Y)
    graph = plotMyBasicKriging(krigResult, xMin, xMax, X, Y)
    graph.setTitle("Kriging #0")
    view = viewer.View(graph)




.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_003.png
   :alt: Kriging #0
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 221-222

The algorithm added a point to the right bound of the domain.

.. GENERATED FROM PYTHON SOURCE LINES 224-234

.. code-block:: default

    for krigingStep in range(5):
        xNew = getNewPoint(xMin, xMax, krigResult)
        yNew = g(xNew)
        X.add(xNew)
        Y.add(yNew)
        krigResult = createMyBasicKriging(X, Y)
        graph = plotMyBasicKriging(krigResult, xMin, xMax, X, Y)
        graph.setTitle("Kriging #%d " % (krigingStep + 1) + graph.getTitle())
        View(graph)




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_004.png
         :alt: Kriging #1 Size = 6, Q2=98.80%
         :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_004.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_005.png
         :alt: Kriging #2 Size = 7, Q2=99.72%
         :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_006.png
         :alt: Kriging #3 Size = 8, Q2=99.81%
         :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_006.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_007.png
         :alt: Kriging #4 Size = 9, Q2=99.89%
         :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_007.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_008.png
         :alt: Kriging #5 Size = 10, Q2=99.89%
         :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_kriging_sequential_008.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 235-238

We observe that the second added point is the left bound of the domain. The remaining points were added strictly inside the domain where the accuracy was drastically improved.

With only 10 points, the metamodel accuracy is already very good with a Q2 which is equal to 99.9%.

.. GENERATED FROM PYTHON SOURCE LINES 240-248

Conclusion
----------

The current example presents the naive implementation on the creation of a sequential design of experiments based on kriging. More pratical algorithms are presented in the following references.

* Mona Abtini. Plans pr√©dictifs √† taille fixe et s√©quentiels pour le krigeage (2008). Th√®se de doctorat de l'Universit√© de Lyon.
* C√©line Scheidt. Analyse statistique d‚Äôexp√©riences simul√©es : Mod√©lisation adaptative de r√©ponses non r√©guli√®res par krigeage et plans d‚Äôexp√©riences (2007). Th√®se pr√©sent√©e pour obtenir le grade de Docteur de l‚ÄôUniversit√© Louis Pasteur.
* David Ginsbourger. Sequential Design of Computer Experiments. Wiley StatsRef: Statistics Reference Online, Wiley (2018 )

.. GENERATED FROM PYTHON SOURCE LINES 248-250

.. code-block:: default


    View.ShowAll()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.678 seconds)


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_sequential.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_kriging_sequential.py <plot_kriging_sequential.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_kriging_sequential.ipynb <plot_kriging_sequential.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
