
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_kriging_beam_arbitrary_trend.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:


Configuring an arbitrary trend in Kriging
=========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-16

The goal of this example is to show how to configure an arbitrary trend in a Kriging metamodel.

In general, any collection of multivariate functions can be used as the
`basis` argument of a `KrigingAlgorithm`.
In practice, it might not be convenient to create a multivariate basis and
this is why we sometimes create it by tensorization of univariate functions.
In this example, we first use Legendre polynomials as our univariate functions,
then we create an orthogonal polynomial basis corresponding to the input marginals.

For this purpose, we use the :ref:`cantilever beam <use-case-cantilever-beam>` example.

.. GENERATED FROM PYTHON SOURCE LINES 18-20

Definition of the model
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 22-28

.. code-block:: default

    from openturns.usecases import cantilever_beam
    import openturns as ot

    ot.RandomGenerator.SetSeed(0)
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 29-30

We load the cantilever beam use case

.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: default

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 33-34

We load the function (model) which evaluates the output Y depending on the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 34-36

.. code-block:: default

    model = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 37-38

Then we define the distribution of the input random vector.

.. GENERATED FROM PYTHON SOURCE LINES 38-41

.. code-block:: default

    dimension = cb.dim  # number of inputs
    myDistribution = cb.distribution








.. GENERATED FROM PYTHON SOURCE LINES 42-44

Create the design of experiments
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 46-49

We consider a simple Monte-Carlo sampling as a design of experiments.
This is why we generate an input sample using the `getSample` method of the distribution.
Then we evaluate the output using the `model` function.

.. GENERATED FROM PYTHON SOURCE LINES 51-55

.. code-block:: default

    sampleSize_train = 20
    X_train = myDistribution.getSample(sampleSize_train)
    Y_train = model(X_train)








.. GENERATED FROM PYTHON SOURCE LINES 56-62

Create the Legendre basis
-------------------------

We first create a Legendre basis of univariate polynomials. In order to convert then into multivariate polynomials, we use a linear enumerate function.

The `LegendreFactory` class creates Legendre polynomials.

.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: default

    univariateFactory = ot.LegendreFactory()








.. GENERATED FROM PYTHON SOURCE LINES 67-68

This factory corresponds to the `Uniform` distribution in the [-1,1] interval.

.. GENERATED FROM PYTHON SOURCE LINES 70-72

.. code-block:: default

    univariateFactory.getMeasure()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>Uniform(a = -1, b = 1)</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 73-74

This interval does not correspond to the interval on which the input marginals are defined (we will come back to this topic later), but this will, anyway, create a consistent trend for the kriging.

.. GENERATED FROM PYTHON SOURCE LINES 76-78

.. code-block:: default

    polyColl = [univariateFactory] * dimension








.. GENERATED FROM PYTHON SOURCE LINES 79-82

.. code-block:: default

    enumerateFunction = ot.LinearEnumerateFunction(dimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 83-90

.. code-block:: default

    functions = []
    numberOfTrendCoefficients = 12
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    (1.73205 * x0) * (1.73205 * x1)
    (1.73205 * x0) * (1.73205 * x2)
    (1.73205 * x0) * (1.73205 * x3)
    -1.11803 + 3.3541 * x1^2
    (1.73205 * x1) * (1.73205 * x2)
    (1.73205 * x1) * (1.73205 * x3)




.. GENERATED FROM PYTHON SOURCE LINES 91-93

.. code-block:: default

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 94-96

Create the metamodel
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 98-103

In order to create the kriging metamodel, we first select a constant trend
with the `ConstantBasisFactory` class.
Then we use a squared exponential covariance model.
Finally, we use the `KrigingAlgorithm` class to create the kriging metamodel,
taking the training sample, the covariance model and the trend basis as input arguments.

.. GENERATED FROM PYTHON SOURCE LINES 105-107

.. code-block:: default

    covarianceModel = ot.SquaredExponential([1.0] * dimension, [1.0])








.. GENERATED FROM PYTHON SOURCE LINES 108-113

.. code-block:: default

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 114-115

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 117-119

.. code-block:: default

    result.getTrendCoefficients()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50]#12</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 120-121

We see that the number of coefficients in the trend corresponds to the number of functions in the basis.

.. GENERATED FROM PYTHON SOURCE LINES 123-125

.. code-block:: default

    result.getCovarianceModel()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>SquaredExponential(scale=[1,1,0.163904,0.01], amplitude=[0.0316491])</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 126-128

The `SquaredExponential` model has one amplitude coefficient and 4 scale coefficients.
This is because this covariance model is anisotropic : each of the 4 input variables is associated with its own scale coefficient.

.. GENERATED FROM PYTHON SOURCE LINES 130-132

Create an orthogonal multivariate polynomial factory
----------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 134-141

In order to create a Legendre basis which better corresponds to the input marginals, we could consider the orthogonal basis which would be associated to uniform marginals.
To compute the bounds of these uniform distributions, we may consider the 1% and 99% quantiles of each marginal.

There is, however, a simpler way to proceed. We can simply orthogonalize the input marginals and create the orthogonal polynomial basis corresponding to the inputs.
This corresponds to the method we would use in the polynomial chaos.

We first create the polynomial basis which corresponds to the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 143-145

.. code-block:: default

    multivariateBasis = ot.OrthogonalProductPolynomialFactory([cb.E, cb.F, cb.L, cb.II])








.. GENERATED FROM PYTHON SOURCE LINES 146-147

Then we create the multivariate basis which has maximum degree equal to 2.

.. GENERATED FROM PYTHON SOURCE LINES 149-154

.. code-block:: default

    totalDegree = 2
    enumerateFunction = multivariateBasis.getEnumerateFunction()
    numberOfTrendCoefficients = enumerateFunction.getStrataCumulatedCardinal(totalDegree)
    numberOfTrendCoefficients





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    15



.. GENERATED FROM PYTHON SOURCE LINES 155-161

.. code-block:: default

    functions = []
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    (1.73205 * x0) * (1.73205 * x1)
    (1.73205 * x0) * (1.73205 * x2)
    (1.73205 * x0) * (1.73205 * x3)
    -1.11803 + 3.3541 * x1^2
    (1.73205 * x1) * (1.73205 * x2)
    (1.73205 * x1) * (1.73205 * x3)
    -1.11803 + 3.3541 * x2^2
    (1.73205 * x2) * (1.73205 * x3)
    -1.11803 + 3.3541 * x3^2




.. GENERATED FROM PYTHON SOURCE LINES 162-164

.. code-block:: default

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 165-170

.. code-block:: default

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 171-172

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 174-176

.. code-block:: default

    result.getTrendCoefficients()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50,1.39896e-44,7.63508e-52,-7.60276e-46]#15</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 177-188

Conclusion
----------

The trend that we have configured corresponds to the basis that we would have used in a full polynomial chaos computed with least squares.

Other extensions of this work would be:

* to use a Fourier basis with `FourierSeriesFactory`,
* wavelets with `HaarWaveletFactory`,

or any other univariate factory.


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_kriging_beam_arbitrary_trend.py <plot_kriging_beam_arbitrary_trend.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_kriging_beam_arbitrary_trend.ipynb <plot_kriging_beam_arbitrary_trend.ipynb>`
