
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_kriging_beam_arbitrary_trend.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:


Configuring an arbitrary trend in Kriging
=========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-11

The goal of this example is to show how to configure an arbitrary trend in a Kriging metamodel.

In general, any collection of multivariate functions can be used as the `basis` argument of a `KrigingAlgorithm`. In practice, it might not be convenient to create a multivariate basis and this is why we sometimes create it by tensorization of univariate functions. In this example, we first use Legendre polynomials as our univariate functions, then we create an orthogonal polynomial basis corresponding to the input marginals.

For this purpose, we use the :ref:`cantilever beam <use-case-cantilever-beam>` example.

.. GENERATED FROM PYTHON SOURCE LINES 13-15

Definition of the model
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 17-24

.. code-block:: default

    from openturns.usecases import cantilever_beam
    from matplotlib import pylab as plt
    import openturns.viewer as viewer
    import openturns as ot
    ot.RandomGenerator.SetSeed(0)
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 25-26

We load the cantilever beam use case

.. GENERATED FROM PYTHON SOURCE LINES 26-28

.. code-block:: default

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 29-30

We load the function (model) which evaluates the output Y depending on the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: default

    model = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 33-34

Then we define the distribution of the input random vector.

.. GENERATED FROM PYTHON SOURCE LINES 34-37

.. code-block:: default

    dimension = cb.dim  # number of inputs
    myDistribution = cb.distribution








.. GENERATED FROM PYTHON SOURCE LINES 38-40

Create the design of experiments
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 42-43

We consider a simple Monte-Carlo sampling as a design of experiments. This is why we generate an input sample using the `getSample` method of the distribution. Then we evaluate the output using the `model` function.

.. GENERATED FROM PYTHON SOURCE LINES 45-49

.. code-block:: default

    sampleSize_train = 20
    X_train = myDistribution.getSample(sampleSize_train)
    Y_train = model(X_train)








.. GENERATED FROM PYTHON SOURCE LINES 50-56

Create the Legendre basis
-------------------------

We first create a Legendre basis of univariate polynomials. In order to convert then into multivariate polynomials, we use a linear enumerate function.

The `LegendreFactory` class creates Legendre polynomials.

.. GENERATED FROM PYTHON SOURCE LINES 58-60

.. code-block:: default

    univariateFactory = ot.LegendreFactory()








.. GENERATED FROM PYTHON SOURCE LINES 61-62

This factory corresponds to the `Uniform` distribution in the [-1,1] interval.

.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: default

    univariateFactory.getMeasure()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>Uniform(a = -1, b = 1)</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 67-68

This interval does not correspond to the interval on which the input marginals are defined (we will come back to this topic later), but this will, anyway, create a consistent trend for the kriging.

.. GENERATED FROM PYTHON SOURCE LINES 70-72

.. code-block:: default

    polyColl = [univariateFactory]*dimension








.. GENERATED FROM PYTHON SOURCE LINES 73-77

.. code-block:: default

    enumerateFunction = ot.LinearEnumerateFunction(dimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(
        polyColl, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 78-85

.. code-block:: default

    functions = []
    numberOfTrendCoefficients = 12
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    (1.73205 * x0) * (1.73205 * x1)
    (1.73205 * x0) * (1.73205 * x2)
    (1.73205 * x0) * (1.73205 * x3)
    -1.11803 + 3.3541 * x1^2
    (1.73205 * x1) * (1.73205 * x2)
    (1.73205 * x1) * (1.73205 * x3)




.. GENERATED FROM PYTHON SOURCE LINES 86-88

.. code-block:: default

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 89-91

Create the metamodel
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 93-94

In order to create the kriging metamodel, we first select a constant trend with the `ConstantBasisFactory` class. Then we use a squared exponential covariance model. Finally, we use the `KrigingAlgorithm` class to create the kriging metamodel, taking the training sample, the covariance model and the trend basis as input arguments.

.. GENERATED FROM PYTHON SOURCE LINES 96-98

.. code-block:: default

    covarianceModel = ot.SquaredExponential([1.]*dimension, [1.0])








.. GENERATED FROM PYTHON SOURCE LINES 99-104

.. code-block:: default

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 105-106

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 108-110

.. code-block:: default

    result.getTrendCoefficients()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [class=Point name=Unnamed dimension=12 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50]]



.. GENERATED FROM PYTHON SOURCE LINES 111-112

We see that the number of coefficients in the trend corresponds to the number of functions in the basis.

.. GENERATED FROM PYTHON SOURCE LINES 114-116

.. code-block:: default

    result.getCovarianceModel()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>SquaredExponential(scale=[1,1,1,1], amplitude=[0.0316491])</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 117-118

The `SquaredExponential` model has one amplitude coefficient and 4 scale coefficients. This is because this covariance model is anisotropic : each of the 4 input variables is associated with its own scale coefficient.

.. GENERATED FROM PYTHON SOURCE LINES 120-122

Create an orthogonal multivariate polynomial factory
----------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 124-129

In order to create a Legendre basis which better corresponds to the input marginals, we could consider the orthogonal basis which would be associated to uniform marginals. To compute the bounds of these uniform distributions, we may consider the 1% and 99% quantiles of each marginal.

There is, however, a simpler way to proceed. We can simply orthogonalize the input marginals and create the orthogonal polynomial basis corresponding to the inputs. This corresponds to the method we would use in the polynomial chaos.

We first create the polynomial basis which corresponds to the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 131-134

.. code-block:: default

    multivariateBasis = ot.OrthogonalProductPolynomialFactory(
        [cb.E, cb.F, cb.L, cb.I])








.. GENERATED FROM PYTHON SOURCE LINES 135-136

Then we create the multivariate basis which has maximum degree equal to 2.

.. GENERATED FROM PYTHON SOURCE LINES 138-144

.. code-block:: default

    totalDegree = 2
    enumerateFunction = multivariateBasis.getEnumerateFunction()
    numberOfTrendCoefficients = enumerateFunction.getStrataCumulatedCardinal(
        totalDegree)
    numberOfTrendCoefficients





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    15



.. GENERATED FROM PYTHON SOURCE LINES 145-151

.. code-block:: default

    functions = []
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    (1.73205 * x0) * (1.73205 * x1)
    (1.73205 * x0) * (1.73205 * x2)
    (1.73205 * x0) * (1.73205 * x3)
    -1.11803 + 3.3541 * x1^2
    (1.73205 * x1) * (1.73205 * x2)
    (1.73205 * x1) * (1.73205 * x3)
    -1.11803 + 3.3541 * x2^2
    (1.73205 * x2) * (1.73205 * x3)
    -1.11803 + 3.3541 * x3^2




.. GENERATED FROM PYTHON SOURCE LINES 152-154

.. code-block:: default

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 155-160

.. code-block:: default

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 161-162

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 164-166

.. code-block:: default

    result.getTrendCoefficients()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    [class=Point name=Unnamed dimension=15 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50,1.39896e-44,7.63508e-52,-7.60276e-46]]



.. GENERATED FROM PYTHON SOURCE LINES 167-178

Conclusion
----------

The trend that we have configured corresponds to the basis that we would have used in a full polynomial chaos computed with least squares.

Other extensions of this work would be:

* to use a Fourier basis with `FourierSeriesFactory`,
* wavelets with `HaarWaveletFactory`,

or any other univariate factory.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.039 seconds)


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example


    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_kriging_beam_arbitrary_trend.py <plot_kriging_beam_arbitrary_trend.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_kriging_beam_arbitrary_trend.ipynb <plot_kriging_beam_arbitrary_trend.ipynb>`
