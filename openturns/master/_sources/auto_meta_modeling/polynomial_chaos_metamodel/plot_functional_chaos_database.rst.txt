
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/polynomial_chaos_metamodel/plot_functional_chaos_database.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_database.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_database.py:


Create a full or sparse polynomial chaos expansion
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-17

In this example we create a global approximation of a model using
polynomial chaos expansion based on a design of experiments.
The goal of this example is to show how we can create a full or
sparse polynomial chaos expansion depending on our needs
and depending on the number of observations we have.
In general, we should have more observations than parameters to estimate.
This is why a sparse polynomial chaos may be interesting:
by carefully selecting the coefficients we estimate,
we may reduce overfitting and increase the predictions of the
metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 19-23

.. code-block:: Python

    import openturns as ot

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 24-26

Define the model
~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 28-29

Create the function.

.. GENERATED FROM PYTHON SOURCE LINES 29-33

.. code-block:: Python

    myModel = ot.SymbolicFunction(
        ["x1", "x2", "x3", "x4"], ["1 + x1 * x2 + 2 * x3^2 + x4^4"]
    )








.. GENERATED FROM PYTHON SOURCE LINES 34-35

Create a multivariate distribution.

.. GENERATED FROM PYTHON SOURCE LINES 35-39

.. code-block:: Python

    distribution = ot.JointDistribution(
        [ot.Normal(), ot.Uniform(), ot.Gamma(2.75, 1.0), ot.Beta(2.5, 1.0, -1.0, 2.0)]
    )








.. GENERATED FROM PYTHON SOURCE LINES 40-46

In order to create the PCE, we can specify the distribution of the
input parameters.
If not known, statistical inference can be used to select a possible
candidate, and fitting tests can validate such an hypothesis.
Please read :doc:`Fit a distribution from an input sample </auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_build_distribution>`
for an example of this method.

.. GENERATED FROM PYTHON SOURCE LINES 48-50

Create a training sample
~~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 52-53

Create a pair of input and output samples.

.. GENERATED FROM PYTHON SOURCE LINES 53-57

.. code-block:: Python

    sampleSize = 250
    inputSample = distribution.getSample(sampleSize)
    outputSample = myModel(inputSample)








.. GENERATED FROM PYTHON SOURCE LINES 58-60

Build the orthogonal basis
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 62-64

In the next cell, we create the univariate orthogonal polynomial basis
for each marginal.

.. GENERATED FROM PYTHON SOURCE LINES 64-72

.. code-block:: Python

    inputDimension = inputSample.getDimension()
    coll = [
        ot.StandardDistributionPolynomialFactory(distribution.getMarginal(i))
        for i in range(inputDimension)
    ]
    enumerateFunction = ot.LinearEnumerateFunction(inputDimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(coll, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 73-74

We can achieve the same result using :class:`~openturns.OrthogonalProductPolynomialFactory`.

.. GENERATED FROM PYTHON SOURCE LINES 74-82

.. code-block:: Python

    marginalDistributionCollection = [
        distribution.getMarginal(i) for i in range(inputDimension)
    ]
    multivariateBasis = ot.OrthogonalProductPolynomialFactory(
        marginalDistributionCollection
    )
    multivariateBasis






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <ul>
      <li>dimension: 4</li>
      <li>enumerate function: class=LinearEnumerateFunction dimension=4</li>
    </ul>

    <table>
      <tr>
        <th>Index</th>
        <th>Name</th>
        <th>Distribution</th>
        <th>Univariate polynomial</th>
      </tr>
      <tr>
        <td>0</td>
        <td>X0</td>
        <td>Normal</td>
        <td>HermiteFactory</td>
      </tr>
      <tr>
        <td>1</td>
        <td>X1</td>
        <td>Uniform</td>
        <td>LegendreFactory</td>
      </tr>
      <tr>
        <td>2</td>
        <td>X2</td>
        <td>Gamma</td>
        <td>LaguerreFactory</td>
      </tr>
      <tr>
        <td>3</td>
        <td>X3</td>
        <td>Beta</td>
        <td>JacobiFactory</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 83-85

Create a full PCE
~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 87-99

Create the algorithm.
We compute the basis size from the total degree.
The next lines use the :class:`~openturns.LeastSquaresStrategy` class
with default parameters (the default is the
:class:`~openturns.PenalizedLeastSquaresAlgorithmFactory` class).
This creates a full polynomial chaos expansion, i.e.
we keep all the candidate coefficients produced by the enumeration
rule.
In order to create a sparse polynomial chaos expansion, we
must use the :class:`~openturns.LeastSquaresMetaModelSelectionFactory`
class instead.


.. GENERATED FROM PYTHON SOURCE LINES 99-111

.. code-block:: Python

    totalDegree = 3
    candidateBasisSize = enumerateFunction.getBasisSizeFromTotalDegree(totalDegree)
    print("Candidate basis size = ", candidateBasisSize)
    adaptiveStrategy = ot.FixedStrategy(productBasis, candidateBasisSize)
    projectionStrategy = ot.LeastSquaresStrategy()
    algo = ot.FunctionalChaosAlgorithm(
        inputSample, outputSample, distribution, adaptiveStrategy, projectionStrategy
    )
    algo.run()
    result = algo.getResult()
    result





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Candidate basis size =  35


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 4</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 4</li>
      <li>transformation: 4 -> 4</li>
      <li>inverse transformation: 4 -> 4</li>
      <li>orthogonal basis dimension: 4</li>
      <li>indices size: 35</li>
      <li>relative errors: [2.26941e-05]</li>
      <li>residuals: [0.0089091]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0,0,0,0]</td>
        <td>26.08317</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[1,0,0,0]</td>
        <td>-0.02540023</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[0,1,0,0]</td>
        <td>-0.01380014</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[0,0,1,0]</td>
        <td>24.89413</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[0,0,0,1]</td>
        <td>4.040553</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[2,0,0,0]</td>
        <td>0.007059757</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[1,1,0,0]</td>
        <td>0.5895518</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[1,0,1,0]</td>
        <td>-0.008400891</td>
      </tr>
      <tr>
        <th>8</th>
        <td>[1,0,0,1]</td>
        <td>0.02450532</td>
      </tr>
      <tr>
        <th>9</th>
        <td>[0,2,0,0]</td>
        <td>0.008954192</td>
      </tr>
      <tr>
        <th>10</th>
        <td>[0,1,1,0]</td>
        <td>-0.00215072</td>
      </tr>
      <tr>
        <th>11</th>
        <td>[0,1,0,1]</td>
        <td>0.01408033</td>
      </tr>
      <tr>
        <th>12</th>
        <td>[0,0,2,0]</td>
        <td>9.088042</td>
      </tr>
      <tr>
        <th>13</th>
        <td>[0,0,1,1]</td>
        <td>-0.0572859</td>
      </tr>
      <tr>
        <th>14</th>
        <td>[0,0,0,2]</td>
        <td>2.287212</td>
      </tr>
      <tr>
        <th>15</th>
        <td>[3,0,0,0]</td>
        <td>-0.01999314</td>
      </tr>
      <tr>
        <th>16</th>
        <td>[2,1,0,0]</td>
        <td>7.618952e-05</td>
      </tr>
      <tr>
        <th>17</th>
        <td>[2,0,1,0]</td>
        <td>0.01140419</td>
      </tr>
      <tr>
        <th>18</th>
        <td>[2,0,0,1]</td>
        <td>-0.03011612</td>
      </tr>
      <tr>
        <th>19</th>
        <td>[1,2,0,0]</td>
        <td>-0.01500872</td>
      </tr>
      <tr>
        <th>20</th>
        <td>[1,1,1,0]</td>
        <td>-0.00551678</td>
      </tr>
      <tr>
        <th>21</th>
        <td>[1,1,0,1]</td>
        <td>-0.007163227</td>
      </tr>
      <tr>
        <th>22</th>
        <td>[1,0,2,0]</td>
        <td>-0.008944125</td>
      </tr>
      <tr>
        <th>23</th>
        <td>[1,0,1,1]</td>
        <td>0.008481172</td>
      </tr>
      <tr>
        <th>24</th>
        <td>[1,0,0,2]</td>
        <td>-0.03645592</td>
      </tr>
      <tr>
        <th>25</th>
        <td>[0,3,0,0]</td>
        <td>0.00766976</td>
      </tr>
      <tr>
        <th>26</th>
        <td>[0,2,1,0]</td>
        <td>-0.00758906</td>
      </tr>
      <tr>
        <th>27</th>
        <td>[0,2,0,1]</td>
        <td>-0.030007</td>
      </tr>
      <tr>
        <th>28</th>
        <td>[0,1,2,0]</td>
        <td>-0.03395878</td>
      </tr>
      <tr>
        <th>29</th>
        <td>[0,1,1,1]</td>
        <td>-0.008614518</td>
      </tr>
      <tr>
        <th>30</th>
        <td>[0,1,0,2]</td>
        <td>-0.02172966</td>
      </tr>
      <tr>
        <th>31</th>
        <td>[0,0,3,0]</td>
        <td>0.009836214</td>
      </tr>
      <tr>
        <th>32</th>
        <td>[0,0,2,1]</td>
        <td>-0.00516466</td>
      </tr>
      <tr>
        <th>33</th>
        <td>[0,0,1,2]</td>
        <td>0.07378972</td>
      </tr>
      <tr>
        <th>34</th>
        <td>[0,0,0,3]</td>
        <td>1.124837</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 112-113

Get the number of coefficients in the PCE.

.. GENERATED FROM PYTHON SOURCE LINES 113-116

.. code-block:: Python

    selectedBasisSizeFull = result.getIndices().getSize()
    print("Selected basis size = ", selectedBasisSizeFull)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Selected basis size =  35




.. GENERATED FROM PYTHON SOURCE LINES 117-120

We see that the number of coefficients in the selected basis is
equal to the number of coefficients in the candidate basis.
This is, indeed, a *full* PCE.

.. GENERATED FROM PYTHON SOURCE LINES 122-124

Use the PCE
~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 126-127

Get the metamodel function.

.. GENERATED FROM PYTHON SOURCE LINES 127-129

.. code-block:: Python

    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 130-132

In order to evaluate the metamodel on a single point, we just
use it as any other :class:`openturns.Function`.

.. GENERATED FROM PYTHON SOURCE LINES 132-136

.. code-block:: Python

    xPoint = distribution.getMean()
    yPoint = metamodel(xPoint)
    print("Value at ", xPoint, " is ", yPoint)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Value at  [0,0,2.75,1.14286]  is  [17.7155]




.. GENERATED FROM PYTHON SOURCE LINES 137-138

Print residuals.

.. GENERATED FROM PYTHON SOURCE LINES 138-140

.. code-block:: Python

    result.getResiduals()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=1 values=[0.0089091]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 141-144

Based on these results, we may want to validate our metamodel.
More details on this topic are presented in
:doc:`Validate a polynomial chaos </auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_draw_validation>`.

.. GENERATED FROM PYTHON SOURCE LINES 146-148

Create a sparse PCE
~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 150-154

In order to create a sparse polynomial chaos expansion, we
use the :class:`~openturns.LeastSquaresMetaModelSelectionFactory`
class instead.


.. GENERATED FROM PYTHON SOURCE LINES 154-167

.. code-block:: Python

    totalDegree = 6
    candidateBasisSize = enumerateFunction.getBasisSizeFromTotalDegree(totalDegree)
    print("Candidate basis size = ", candidateBasisSize)
    adaptiveStrategy = ot.FixedStrategy(productBasis, candidateBasisSize)
    selectionAlgorithm = ot.LeastSquaresMetaModelSelectionFactory()
    projectionStrategy = ot.LeastSquaresStrategy(selectionAlgorithm)
    algo = ot.FunctionalChaosAlgorithm(
        inputSample, outputSample, distribution, adaptiveStrategy, projectionStrategy
    )
    algo.run()
    result = algo.getResult()
    result





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Candidate basis size =  210


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 4</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 4</li>
      <li>transformation: 4 -> 4</li>
      <li>inverse transformation: 4 -> 4</li>
      <li>orthogonal basis dimension: 4</li>
      <li>indices size: 10</li>
      <li>relative errors: [7.3654e-33]</li>
      <li>residuals: [1.30458e-15]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0,0,0,0]</td>
        <td>26.11651</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[0,0,1,0]</td>
        <td>24.87469</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[0,0,0,1]</td>
        <td>3.974438</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[1,1,0,0]</td>
        <td>0.5773503</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[0,0,2,0]</td>
        <td>9.082951</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[0,0,0,2]</td>
        <td>2.419672</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[0,0,0,3]</td>
        <td>0.9657677</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[0,0,0,4]</td>
        <td>0.2409653</td>
      </tr>
      <tr>
        <th>8</th>
        <td>[0,5,0,0]</td>
        <td>3.964189e-16</td>
      </tr>
      <tr>
        <th>9</th>
        <td>[0,5,0,1]</td>
        <td>-9.238795e-16</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 168-169

Get the number of coefficients in the PCE.

.. GENERATED FROM PYTHON SOURCE LINES 169-172

.. code-block:: Python

    selectedBasisSizeSparse = result.getIndices().getSize()
    print("Selected basis size = ", selectedBasisSizeSparse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Selected basis size =  10




.. GENERATED FROM PYTHON SOURCE LINES 173-177

We see that the number of selected coefficients is lower than
the number of candidate coefficients.
This may reduce overfitting and can produce a PCE with more
accurate predictions.


.. _sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_database.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_functional_chaos_database.ipynb <plot_functional_chaos_database.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_functional_chaos_database.py <plot_functional_chaos_database.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_functional_chaos_database.zip <plot_functional_chaos_database.zip>`
