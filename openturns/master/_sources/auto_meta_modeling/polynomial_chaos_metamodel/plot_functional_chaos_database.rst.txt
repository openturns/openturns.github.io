
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/polynomial_chaos_metamodel/plot_functional_chaos_database.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_database.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_database.py:


Create a full or sparse polynomial chaos expansion
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-16

In this example we create a global approximation of a model using
polynomial chaos expansion based on a design of experiment.
The goal of this example is to show how we can create a full or
sparse polynomial chaos expansion depending on our needs
and depending on the number of observations we have.
In general, we should have more observations than parameters to estimate.
This is why a sparse polynomial chaos may be interesting:
by carefully selecting the coefficients we estimate,
we may reduce overfitting and increase the predictions of the
metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 18-22

.. code-block:: Python

    import openturns as ot

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 23-25

Define the model
~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 27-28

Create the function.

.. GENERATED FROM PYTHON SOURCE LINES 28-32

.. code-block:: Python

    myModel = ot.SymbolicFunction(
        ["x1", "x2", "x3", "x4"], ["1 + x1 * x2 + 2 * x3^2 + x4^4"]
    )








.. GENERATED FROM PYTHON SOURCE LINES 33-34

Create a multivariate distribution.

.. GENERATED FROM PYTHON SOURCE LINES 34-38

.. code-block:: Python

    distribution = ot.JointDistribution(
        [ot.Normal(), ot.Uniform(), ot.Gamma(2.75, 1.0), ot.Beta(2.5, 1.0, -1.0, 2.0)]
    )








.. GENERATED FROM PYTHON SOURCE LINES 39-45

In order to create the PCE, we can specify the distribution of the
input parameters.
If not known, statistical inference can be used to select a possible
candidate, and fitting tests can validate such an hypothesis.
Please read :doc:`Fit a distribution from an input sample </auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_build_distribution>`
for an example of this method.

.. GENERATED FROM PYTHON SOURCE LINES 47-49

Create a training sample
~~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 51-52

Create a pair of input and output samples.

.. GENERATED FROM PYTHON SOURCE LINES 52-56

.. code-block:: Python

    sampleSize = 250
    inputSample = distribution.getSample(sampleSize)
    outputSample = myModel(inputSample)








.. GENERATED FROM PYTHON SOURCE LINES 57-59

Build the orthogonal basis
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 61-63

In the next cell, we create the univariate orthogonal polynomial basis
for each marginal.

.. GENERATED FROM PYTHON SOURCE LINES 63-71

.. code-block:: Python

    inputDimension = inputSample.getDimension()
    coll = [
        ot.StandardDistributionPolynomialFactory(distribution.getMarginal(i))
        for i in range(inputDimension)
    ]
    enumerateFunction = ot.LinearEnumerateFunction(inputDimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(coll, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 72-73

We can achieve the same result using :class:`~openturns.OrthogonalProductPolynomialFactory`.

.. GENERATED FROM PYTHON SOURCE LINES 73-81

.. code-block:: Python

    marginalDistributionCollection = [
        distribution.getMarginal(i) for i in range(inputDimension)
    ]
    multivariateBasis = ot.OrthogonalProductPolynomialFactory(
        marginalDistributionCollection
    )
    multivariateBasis






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <ul>
      <li>dimension: 4</li>
      <li>enumerate function: class=LinearEnumerateFunction dimension=4</li>
    </ul>

    <table>
      <tr>
        <th>Index</th>
        <th>Name</th>
        <th>Distribution</th>
        <th>Univariate polynomial</th>
      </tr>
      <tr>
        <td>0</td>
        <td>X0</td>
        <td>Normal</td>
        <td>HermiteFactory</td>
      </tr>
      <tr>
        <td>1</td>
        <td>X1</td>
        <td>Uniform</td>
        <td>LegendreFactory</td>
      </tr>
      <tr>
        <td>2</td>
        <td>X2</td>
        <td>Gamma</td>
        <td>LaguerreFactory</td>
      </tr>
      <tr>
        <td>3</td>
        <td>X3</td>
        <td>Beta</td>
        <td>JacobiFactory</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 82-84

Create a full PCE
~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 86-98

Create the algorithm.
We compute the basis size from the total degree.
The next lines use the :class:`~openturns.LeastSquaresStrategy` class
with default parameters (the default is the
:class:`~openturns.PenalizedLeastSquaresAlgorithmFactory` class).
This creates a full polynomial chaos expansion, i.e.
we keep all the candidate coefficients produced by the enumeration
rule.
In order to create a sparse polynomial chaos expansion, we
must use the :class:`~openturns.LeastSquaresMetaModelSelectionFactory`
class instead.


.. GENERATED FROM PYTHON SOURCE LINES 98-110

.. code-block:: Python

    totalDegree = 3
    candidateBasisSize = enumerateFunction.getBasisSizeFromTotalDegree(totalDegree)
    print("Candidate basis size = ", candidateBasisSize)
    adaptiveStrategy = ot.FixedStrategy(productBasis, candidateBasisSize)
    projectionStrategy = ot.LeastSquaresStrategy()
    algo = ot.FunctionalChaosAlgorithm(
        inputSample, outputSample, distribution, adaptiveStrategy, projectionStrategy
    )
    algo.run()
    result = algo.getResult()
    result





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Candidate basis size =  35


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 4</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 4</li>
      <li>transformation: 4 -> 4</li>
      <li>inverse transformation: 4 -> 4</li>
      <li>orthogonal basis dimension: 4</li>
      <li>indices size: 35</li>
      <li>relative errors: [1.91443e-05]</li>
      <li>residuals: [0.00768439]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0,0,0,0]</td>
        <td>26.07054</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[1,0,0,0]</td>
        <td>0.005458772</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[0,1,0,0]</td>
        <td>0.01069302</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[0,0,1,0]</td>
        <td>24.85165</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[0,0,0,1]</td>
        <td>4.105235</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[2,0,0,0]</td>
        <td>0.01051751</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[1,1,0,0]</td>
        <td>0.5656151</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[1,0,1,0]</td>
        <td>0.0003161565</td>
      </tr>
      <tr>
        <th>8</th>
        <td>[1,0,0,1]</td>
        <td>-0.005942105</td>
      </tr>
      <tr>
        <th>9</th>
        <td>[0,2,0,0]</td>
        <td>-0.02140947</td>
      </tr>
      <tr>
        <th>10</th>
        <td>[0,1,1,0]</td>
        <td>-0.005452391</td>
      </tr>
      <tr>
        <th>11</th>
        <td>[0,1,0,1]</td>
        <td>0.001980089</td>
      </tr>
      <tr>
        <th>12</th>
        <td>[0,0,2,0]</td>
        <td>9.075136</td>
      </tr>
      <tr>
        <th>13</th>
        <td>[0,0,1,1]</td>
        <td>0.01523126</td>
      </tr>
      <tr>
        <th>14</th>
        <td>[0,0,0,2]</td>
        <td>2.220908</td>
      </tr>
      <tr>
        <th>15</th>
        <td>[3,0,0,0]</td>
        <td>-0.00255535</td>
      </tr>
      <tr>
        <th>16</th>
        <td>[2,1,0,0]</td>
        <td>0.01926361</td>
      </tr>
      <tr>
        <th>17</th>
        <td>[2,0,1,0]</td>
        <td>0.01397505</td>
      </tr>
      <tr>
        <th>18</th>
        <td>[2,0,0,1]</td>
        <td>-0.008977227</td>
      </tr>
      <tr>
        <th>19</th>
        <td>[1,2,0,0]</td>
        <td>-0.008034152</td>
      </tr>
      <tr>
        <th>20</th>
        <td>[1,1,1,0]</td>
        <td>-0.002454137</td>
      </tr>
      <tr>
        <th>21</th>
        <td>[1,1,0,1]</td>
        <td>0.01818699</td>
      </tr>
      <tr>
        <th>22</th>
        <td>[1,0,2,0]</td>
        <td>-0.01312425</td>
      </tr>
      <tr>
        <th>23</th>
        <td>[1,0,1,1]</td>
        <td>0.04339037</td>
      </tr>
      <tr>
        <th>24</th>
        <td>[1,0,0,2]</td>
        <td>0.02127018</td>
      </tr>
      <tr>
        <th>25</th>
        <td>[0,3,0,0]</td>
        <td>-0.02201107</td>
      </tr>
      <tr>
        <th>26</th>
        <td>[0,2,1,0]</td>
        <td>-0.007270399</td>
      </tr>
      <tr>
        <th>27</th>
        <td>[0,2,0,1]</td>
        <td>0.02590905</td>
      </tr>
      <tr>
        <th>28</th>
        <td>[0,1,2,0]</td>
        <td>0.009492473</td>
      </tr>
      <tr>
        <th>29</th>
        <td>[0,1,1,1]</td>
        <td>0.0004814135</td>
      </tr>
      <tr>
        <th>30</th>
        <td>[0,1,0,2]</td>
        <td>-0.003427854</td>
      </tr>
      <tr>
        <th>31</th>
        <td>[0,0,3,0]</td>
        <td>-0.007708822</td>
      </tr>
      <tr>
        <th>32</th>
        <td>[0,0,2,1]</td>
        <td>0.008938562</td>
      </tr>
      <tr>
        <th>33</th>
        <td>[0,0,1,2]</td>
        <td>-0.03256179</td>
      </tr>
      <tr>
        <th>34</th>
        <td>[0,0,0,3]</td>
        <td>1.184</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 111-112

Get the number of coefficients in the PCE.

.. GENERATED FROM PYTHON SOURCE LINES 112-115

.. code-block:: Python

    selectedBasisSizeFull = result.getIndices().getSize()
    print("Selected basis size = ", selectedBasisSizeFull)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Selected basis size =  35




.. GENERATED FROM PYTHON SOURCE LINES 116-119

We see that the number of coefficients in the selected basis is
equal to the number of coefficients in the candidate basis.
This is, indeed, a *full* PCE.

.. GENERATED FROM PYTHON SOURCE LINES 121-123

Use the PCE
~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 125-126

Get the metamodel function.

.. GENERATED FROM PYTHON SOURCE LINES 126-128

.. code-block:: Python

    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 129-131

In order to evaluate the metamodel on a single point, we just
use it as any other :class:`openturns.Function`.

.. GENERATED FROM PYTHON SOURCE LINES 131-135

.. code-block:: Python

    xPoint = distribution.getMean()
    yPoint = metamodel(xPoint)
    print("Value at ", xPoint, " is ", yPoint)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Value at  [0,0,2.75,1.14286]  is  [17.7496]




.. GENERATED FROM PYTHON SOURCE LINES 136-137

Print residuals.

.. GENERATED FROM PYTHON SOURCE LINES 137-139

.. code-block:: Python

    result.getResiduals()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=1 values=[0.00768439]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 140-143

Based on these results, we may want to validate our metamodel.
More details on this topic are presented in
:doc:`Validate a polynomial chaos </auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_draw_validation>`.

.. GENERATED FROM PYTHON SOURCE LINES 145-147

Create a sparse PCE
~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 149-153

In order to create a sparse polynomial chaos expansion, we
use the :class:`~openturns.LeastSquaresMetaModelSelectionFactory`
class instead.


.. GENERATED FROM PYTHON SOURCE LINES 153-166

.. code-block:: Python

    totalDegree = 6
    candidateBasisSize = enumerateFunction.getBasisSizeFromTotalDegree(totalDegree)
    print("Candidate basis size = ", candidateBasisSize)
    adaptiveStrategy = ot.FixedStrategy(productBasis, candidateBasisSize)
    selectionAlgorithm = ot.LeastSquaresMetaModelSelectionFactory()
    projectionStrategy = ot.LeastSquaresStrategy(selectionAlgorithm)
    algo = ot.FunctionalChaosAlgorithm(
        inputSample, outputSample, distribution, adaptiveStrategy, projectionStrategy
    )
    algo.run()
    result = algo.getResult()
    result





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Candidate basis size =  210


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 4</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 4</li>
      <li>transformation: 4 -> 4</li>
      <li>inverse transformation: 4 -> 4</li>
      <li>orthogonal basis dimension: 4</li>
      <li>indices size: 9</li>
      <li>relative errors: [1.41643e-31]</li>
      <li>residuals: [1.36867e-15]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0,0,0,0]</td>
        <td>26.11651</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[0,0,1,0]</td>
        <td>24.87469</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[0,0,0,1]</td>
        <td>3.974438</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[1,1,0,0]</td>
        <td>0.5773503</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[0,0,2,0]</td>
        <td>9.082951</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[0,0,0,2]</td>
        <td>2.419672</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[0,0,0,3]</td>
        <td>0.9657677</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[0,0,0,4]</td>
        <td>0.2409653</td>
      </tr>
      <tr>
        <th>8</th>
        <td>[1,2,2,1]</td>
        <td>7.502192e-15</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 167-168

Get the number of coefficients in the PCE.

.. GENERATED FROM PYTHON SOURCE LINES 168-171

.. code-block:: Python

    selectedBasisSizeSparse = result.getIndices().getSize()
    print("Selected basis size = ", selectedBasisSizeSparse)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Selected basis size =  9




.. GENERATED FROM PYTHON SOURCE LINES 172-176

We see that the number of selected coefficients is lower than
the number of candidate coefficients.
This may reduce overfitting and can produce a PCE with more
accurate predictions.


.. _sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_database.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_functional_chaos_database.ipynb <plot_functional_chaos_database.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_functional_chaos_database.py <plot_functional_chaos_database.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_functional_chaos_database.zip <plot_functional_chaos_database.zip>`
