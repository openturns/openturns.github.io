
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_cantilever_beam_integration.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_cantilever_beam_integration.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_cantilever_beam_integration.py:


Create a polynomial chaos metamodel by integration on the cantilever beam
=========================================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-9

In this example, we create a polynomial chaos metamodel by integration on the :ref:`cantilever beam <use-case-cantilever-beam>` example.

In order to do this, we use the `GaussProductExperiment` class.

.. GENERATED FROM PYTHON SOURCE LINES 11-18

.. code-block:: default

    from openturns.usecases import cantilever_beam as cantilever_beam
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 19-20

We first load the model from the usecases module :

.. GENERATED FROM PYTHON SOURCE LINES 20-22

.. code-block:: default

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 23-24

In this example we consider all marginals independent. They are defined in the `CantileverBeam` data class as well as an independent distribution :

.. GENERATED FROM PYTHON SOURCE LINES 24-30

.. code-block:: default

    dist_E = cb.E
    dist_F = cb.F
    dist_L = cb.L
    dist_I = cb.I
    myDistribution = cb.independentDistribution








.. GENERATED FROM PYTHON SOURCE LINES 31-34

.. code-block:: default

    dim_input = cb.dim  # dimension of the input
    dim_output = 1  # dimension of the output








.. GENERATED FROM PYTHON SOURCE LINES 35-36

We load the model :

.. GENERATED FROM PYTHON SOURCE LINES 36-38

.. code-block:: default

    g = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 39-41

Create a polynomial chaos decomposition
---------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 43-44

We create the multivariate polynomial basis by tensorization of the univariate polynomials and the default linear enumerate rule.

.. GENERATED FROM PYTHON SOURCE LINES 46-49

.. code-block:: default

    multivariateBasis = ot.OrthogonalProductPolynomialFactory(
        [dist_E, dist_F, dist_L, dist_I])








.. GENERATED FROM PYTHON SOURCE LINES 50-51

Generate an training sample of size N with MC simulation.

.. GENERATED FROM PYTHON SOURCE LINES 53-57

.. code-block:: default

    N = 50  # size of the experimental design
    inputTrain = myDistribution.getSample(N)
    outputTrain = g(inputTrain)








.. GENERATED FROM PYTHON SOURCE LINES 58-59

We select the `FixedStrategy` truncation rule, which corresponds to using the first `P` polynomials of the polynomial basis. In this case, we select `P` using the `getStrataCumulatedCardinal` method, so that all polynomials with total degree lower or equal to 5 are used.

.. GENERATED FROM PYTHON SOURCE LINES 61-67

.. code-block:: default

    totalDegree = 5
    enumfunc = multivariateBasis.getEnumerateFunction()
    P = enumfunc.getStrataCumulatedCardinal(totalDegree)
    adaptiveStrategy = ot.FixedStrategy(multivariateBasis, P)
    adaptiveStrategy






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>class=FixedStrategy derived from class=AdaptiveStrategyImplementation maximumDimension=126</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 68-69

We see that the number of polynomials is equal to 126. This will lead to the computation of 126 coefficients.

.. GENERATED FROM PYTHON SOURCE LINES 71-74

We now set the method used to compute the coefficients; we select the integration method.

We begin by getting the standard measure associated with the multivariate polynomial basis. We see that the range of the `Beta` distribution has been standardized into the [-1,1] interval. This is the same for the `Uniform` distribution and the second `Beta` distribution.

.. GENERATED FROM PYTHON SOURCE LINES 76-79

.. code-block:: default

    distributionMu = multivariateBasis.getMeasure()
    distributionMu






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>ComposedDistribution(Beta(alpha = 0.9, beta = 3.5, a = -1, b = 1), LogNormal(muLog = 5.69881, sigmaLog = 0.0997513, gamma = 0), Uniform(a = -1, b = 1), Beta(alpha = 2.5, beta = 4, a = -1, b = 1), IndependentCopula(dimension = 4))</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 80-83

.. code-block:: default

    marginalDegrees = [4] * dim_input
    experiment = ot.GaussProductExperiment(distributionMu, marginalDegrees)








.. GENERATED FROM PYTHON SOURCE LINES 84-85

We can see the size of the associated design of experiments.

.. GENERATED FROM PYTHON SOURCE LINES 87-89

.. code-block:: default

    experiment.generate().getSize()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    256



.. GENERATED FROM PYTHON SOURCE LINES 90-91

The choice of the `GaussProductExperiment` rule leads to 256 evaluations of the model.

.. GENERATED FROM PYTHON SOURCE LINES 93-95

.. code-block:: default

    projectionStrategy = ot.IntegrationStrategy(experiment)








.. GENERATED FROM PYTHON SOURCE LINES 96-97

We can now create the functional chaos.

.. GENERATED FROM PYTHON SOURCE LINES 99-103

.. code-block:: default

    chaosalgo = ot.FunctionalChaosAlgorithm(
        g, myDistribution, adaptiveStrategy, projectionStrategy)
    chaosalgo.run()








.. GENERATED FROM PYTHON SOURCE LINES 104-106

Get the result


.. GENERATED FROM PYTHON SOURCE LINES 108-110

.. code-block:: default

    result = chaosalgo.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 111-112

The `getMetaModel` method returns the metamodel function.

.. GENERATED FROM PYTHON SOURCE LINES 114-116

.. code-block:: default

    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 117-119

Validate the metamodel
----------------------

.. GENERATED FROM PYTHON SOURCE LINES 121-122

Generate a validation sample (which is independent of the training sample).

.. GENERATED FROM PYTHON SOURCE LINES 124-128

.. code-block:: default

    n_valid = 1000
    inputTest = myDistribution.getSample(n_valid)
    outputTest = g(inputTest)








.. GENERATED FROM PYTHON SOURCE LINES 129-130

The `MetaModelValidation` class validates the metamodel based on a validation sample.

.. GENERATED FROM PYTHON SOURCE LINES 132-134

.. code-block:: default

    val = ot.MetaModelValidation(inputTest, outputTest, metamodel)








.. GENERATED FROM PYTHON SOURCE LINES 135-136

Compute the :math:`Q^2` predictivity coefficient

.. GENERATED FROM PYTHON SOURCE LINES 138-141

.. code-block:: default

    Q2 = val.computePredictivityFactor()[0]
    Q2





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.9999977826876493



.. GENERATED FROM PYTHON SOURCE LINES 142-143

Plot the observed versus the predicted outputs.

.. GENERATED FROM PYTHON SOURCE LINES 145-149

.. code-block:: default

    graph = val.drawValidation()
    graph.setTitle("Q2=%.2f%%" % (Q2*100))
    view = viewer.View(graph)




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_001.png
   :alt: Q2=100.00%
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 150-152

Sensitivity analysis
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 154-155

Retrieve Sobol' sensitivity measures associated to the polynomial chaos decomposition of the model.

.. GENERATED FROM PYTHON SOURCE LINES 157-160

.. code-block:: default

    chaosSI = ot.FunctionalChaosSobolIndices(result)
    print(chaosSI.summary())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

     input dimension: 4
     output dimension: 1
     basis size: 126
     mean: [0.170691]
     std-dev: [0.0203241]
    ------------------------------------------------------------
    Index   | Multi-indice                  | Part of variance  
    ------------------------------------------------------------
          2 | [0,1,0,0]                     | 0.70534
          4 | [0,0,0,1]                     | 0.164639
          3 | [0,0,1,0]                     | 0.0813041
          1 | [1,0,0,0]                     | 0.0448651
    ------------------------------------------------------------


    ------------------------------------------------------------
    Component | Sobol index            | Sobol total index      
    ------------------------------------------------------------
            0 | 0.044908               | 0.0455157             
            1 | 0.70534                | 0.708258              
            2 | 0.0813125              | 0.0823703             
            3 | 0.165174               | 0.167125              
    ------------------------------------------------------------






.. GENERATED FROM PYTHON SOURCE LINES 161-169

.. code-block:: default

    first_order = [chaosSI.getSobolIndex(i) for i in range(dim_input)]
    total_order = [chaosSI.getSobolTotalIndex(i) for i in range(dim_input)]
    input_names = g.getInputDescription()
    graph = ot.SobolIndicesAlgorithm.DrawSobolIndices(
        input_names, first_order, total_order)
    view = viewer.View(graph)

    plt.show()



.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_002.png
   :alt: Sobol' indices
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 170-174

Conclusion
----------

We see that the coefficients are particularily well computed since the Q2 coefficient is excellent (perfect ?), even with a relatively limited amount of simulation (256 points).


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.176 seconds)


.. _sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_cantilever_beam_integration.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_chaos_cantilever_beam_integration.py <plot_chaos_cantilever_beam_integration.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_chaos_cantilever_beam_integration.ipynb <plot_chaos_cantilever_beam_integration.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
