
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_conditional_expectation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_conditional_expectation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_conditional_expectation.py:


Conditional expectation of a polynomial chaos expansion
=======================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-11

In this example, we compute the conditional expectation of a polynomial
chaos expansion of the :ref:`Ishigami function <use-case-ishigami>` using
the :meth:`~openturns.FunctionalChaosResult.getConditionalExpectation`
method.

.. GENERATED FROM PYTHON SOURCE LINES 14-42

Introduction
~~~~~~~~~~~~
Let :math:`\inputDim \in \Nset`
be the dimension of the input random vector.
Let :math:`\Expect{\inputRV} \in \Rset^\inputDim`
be the mean of the input random vector :math:`\inputRV`.
Let :math:`\model` be the physical model:

.. math::
    \model : \Rset^\inputDim \rightarrow \Rset.

Given :math:`\vect{u} \subseteq \{1, ..., \inputDim\}` a group
of input variables, we want to create a new function :math:`\widehat{\model}`:

.. math::
    \widehat{\model}: \Rset^{|\vect{u}|} \rightarrow \Rset

where :math:`|\vect{u}| = \operatorname{card}(\vect{u})` is the
number of variables in the group.

In this example, we experiment two different ways to reduce the
input dimension of a polynomial chaos expansion:

- the parametric function,
- the conditional expectation.

The goal of this page is to see how we can create these
functions and the difference between them.

.. GENERATED FROM PYTHON SOURCE LINES 44-77

Parametric function
~~~~~~~~~~~~~~~~~~~

The simplest method to reduce the dimension of the input
is to set some input variables to constant values.
In this example, all marginal inputs, except those in
the conditioning indices are set to the mean of the input random vector.

Let :math:`\overline{\vect{u}}` be the complementary set of input
marginal indices such that :math:`\vect{u}` and :math:`\overline{\vect{u}}`
form a disjoint partition of the full set of variable indices:

.. math::

    \vect{u} \; \dot{\cup} \; \overline{\vect{u}} = \{1, ..., \inputDim\}.

The parametric function with reduced dimension is:

.. math::

  \widehat{\model}(\inputReal_{\vect{u}})
  = \model\left(\inputReal_{\vect{u}},
           \inputReal_{\overline{\vect{u}}}
           = \Expect{\inputRV_{\overline{\vect{u}}}}\right)

for any :math:`\inputReal_{\vect{u}} \in \Rset^{|\vect{u}|}`.
The previous function is a parametric function based on the function :math:`\model`
where the parameter is :math:`\Expect{\inputRV_{\overline{\vect{u}}}}`.
Assuming that the input random vector has an independent copula,
computing :math:`\Expect{\inputRV_{\overline{\vect{u}}}}`
can be done by selecting the corresponding indices in :math:`\Expect{\inputRV}`.
This function can be created using the :class:`~openturns.ParametricFunction`
class.

.. GENERATED FROM PYTHON SOURCE LINES 79-94

Parametric PCE
~~~~~~~~~~~~~~

If the physical model is a PCE, then the associated parametric model is also a
PCE.
Its coefficients and the associated functional basis can be computed from
the original PCE.
A significant fact, however, is that the coefficients of the parametric
PCE are *not* the ones of the original PCE: the coefficients of the parametric
PCE have to be multiplied by factors which depend on the
value of the discarded basis functions on the parameter vector.
This feature is not currently available in the library.
However, we present it below as this derivation is interesting
to understand why the conditional expectation may behave
differently from the corresponding parametric PCE.

.. GENERATED FROM PYTHON SOURCE LINES 96-118

Let :math:`\cJ^P \subseteq \Nset^{\inputDim}` be the set of
multi-indices corresponding to the truncated polynomial chaos expansion
up to the :math:`P`-th coefficient.
Let :math:`h` be the PCE in the standard space:

.. math::

    h(\standardReal) = \sum_{\vect{\alpha} \in \cJ^P}
        a_{\vect{\alpha}} \psi_{\vect{\alpha}}(\standardReal).

Let :math:`\vect{u} \subseteq \{1, ..., \inputDim\}` be a group of variables,
let :math:`\overline{\vect{u}}` be its complementary set such that

.. math::

    \vect{u} \; \dot{\cup} \; \overline{\vect{u}} = \{1, ..., \inputDim\}

i.e. the groups :math:`\vect{u}` and :math:`\overline{\vect{u}}` create a disjoint partition
of the set :math:`\{1, ..., \inputDim\}`.
Let :math:`|\vect{u}| \in \Nset` be the number of elements
in the group :math:`\vect{u}`.
Hence, we have :math:`|\vect{u}| + |\overline{\vect{u}}| = \inputDim`.

.. GENERATED FROM PYTHON SOURCE LINES 120-151

Let :math:`\standardReal_{\vect{u}}^{(0)} \in \Rset^{|\vect{u}|}`
be a given point.
We are interested in the function :

.. math::

    \widehat{h}(\standardReal_{\overline{\vect{u}}})
    = h\left(\standardReal_{\overline{\vect{u}}},
    \standardReal_{\vect{u}}^{(0)}\right)

for any :math:`\standardReal_{\overline{\vect{u}}} \in \Rset^{|\overline{\vect{u}}|}`.
We assume that the polynomial basis are defined by the tensor product:

.. math::

    \psi_{\vect{\alpha}}\left(\standardReal\right)
    = \prod_{i = 1}^{\inputDim}
    \pi_{\alpha_i}^{(i)}\left(\standardReal\right)

for any :math:`\standardReal \in \standardInputSpace`
where :math:`\pi_{\alpha_i}^{(i)}` is the polynomial of degree
:math:`\alpha_i` of the :math:`i`-th input standard variable.

Let :math:`\vect{u} = (u_i)_{i = 1, ..., |\vect{u}|}` denote the components of the
group :math:`\vect{u}` where :math:`|\vect{u}|` is the number of elements in the group.
Similarly, let :math:`\overline{\vect{u}} = (\overline{u}_i)_{i = 1, ..., |\overline{\vect{u}}|}` denote the
components of the complementary group :math:`\overline{\vect{u}}`.
The components of :math:`\standardReal \in \Rset^{\inputDim}`
which are in the group :math:`\vect{u}` are :math:`\left(z_{u_i}^{(0)}\right)_{i = 1, ..., |\vect{u}|}`
and the complementary components are
:math:`\left(z_{\overline{u}_i}\right)_{i = 1, ..., |\overline{\vect{u}}|}`.

.. GENERATED FROM PYTHON SOURCE LINES 153-174

Let :math:`\overline{\psi}_{\overline{\vect{\alpha}}}` be the reduced polynomial:

.. math::
   :label: PCE_CE_1

    \overline{\psi}_{\overline{\vect{\alpha}}}(z_{\overline{\vect{u}}})
    = \left(\prod_{i = 1}^{|\overline{\vect{u}}|}
       \pi_{\alpha_{\overline{u}_i}}^{(\overline{u}_i)}
       \left(\standardReal_{\overline{u}_i}\right) \right)

where :math:`\overline{\vect{\alpha}} \in \Nset^{|\vect{u}|}` is the reduced multi-index
defined from the multi-index :math:`\vect{\alpha}\in \Nset^{\inputDim}`
by the equation:

.. math::

    \overline{\alpha}_i = \alpha_{\overline{u}_i}

for :math:`i = 1, ..., |\overline{\vect{u}}|`.
The components of the reduced multi-index :math:`\overline{\vect{\alpha}}` which corresponds
to the components of the multi-index given by the complementary group :math:`|\vect{u}|`.

.. GENERATED FROM PYTHON SOURCE LINES 176-220

We must then gather the reduced multi-indices.
Let :math:`\overline{\cJ}^P` be the set of unique reduced multi-indices:

.. math::
   :label: PCE_CE_2

    \overline{\cJ}^P = \left\{\overline{\vect{\alpha}} \in \Nset^{|\vect{u}|}
    \; | \; \vect{\alpha} \in \cJ^P\right\}.

For any reduced multi-index :math:`\overline{\vect{\alpha}} \in \overline{\cJ}^P`
of dimension :math:`|\overline{\vect{u}}|`,
we note :math:`\cJ_{\overline{\vect{\alpha}}}^P`
the set of corresponding (un-reduced) multi-indices of
dimension :math:`\inputDim`:

.. math::
   :label: PCE_CE_3

    \cJ_{\overline{\vect{\alpha}}}^P
    = \left\{\vect{\alpha} \in \cJ^P \; |\; \overline{\alpha}_i
    = \alpha_{\overline{u}_i}, \; i = 1, ..., |\overline{\vect{u}}|\right\}.

Each aggregated coefficient :math:`\overline{a}_{\overline{\vect{\alpha}}} \in \Rset`
is defined by the equation:

.. math::
   :label: PCE_CE_5

    \overline{a}_{\overline{\vect{\alpha}}}
    = \sum_{\vect{\alpha} \in \cJ^P_{\overline{\vect{\alpha}}}}
    a_{\vect{\alpha}} \left(\prod_{i = 1}^{|\vect{u}|}
    \pi_{\alpha_{u_i}}^{(u_i)}\left(\standardReal_{u_i}^{(0)}\right) \right).

Finally:

.. math::
   :label: PCE_CE_4

    \widehat{h}(\standardReal_{\overline{\vect{u}}})
    = \sum_{\overline{\vect{\alpha}} \in \overline{\cJ}^P}
    \overline{a}_{\overline{\vect{\alpha}}}
    \overline{\psi}(z_{\overline{\vect{u}}})

for any :math:`\standardReal_{\overline{\vect{u}}} \in \Rset^{|\overline{\vect{u}}|}`.

.. GENERATED FROM PYTHON SOURCE LINES 222-229

The method is the following.

- Create the reduced polynomial basis from equation :eq:`PCE_CE_1`.
- Create the list of reduced multi-indices from the equation :eq:`PCE_CE_2`, and, for each
  reduced multi-index, the list of corresponding multi-indices from the equation :eq:`PCE_CE_3`.
- Aggregate the coefficients from the equation :eq:`PCE_CE_5`.
- The parametric PCE is defined by the equation :eq:`PCE_CE_4`.

.. GENERATED FROM PYTHON SOURCE LINES 231-253

Conditional expectation
~~~~~~~~~~~~~~~~~~~~~~~

One method to reduce the input dimension of a function is to
consider its conditional expectation.
The conditional expectation function is:

.. math::

  \widehat{\model}(\inputReal_{\vect{u}})
  = \Expect{\model(\inputReal)
           \; | \; \inputRV_{\vect{u}}
           = \inputReal_{\vect{u}}}

for any :math:`\inputReal_{\vect{u}} \in \Rset^{|\vect{u}|}`.
In general, there is no dedicated method to create such a conditional expectation
in the library.
We can, however, efficiently compute the conditional expectation of a polynomial
chaos expansion.
In turn, this conditional chaos expansion (PCE) is a polynomial chaos expansion
which can be computed using the :meth:`~openturns.FunctionalChaosResult.getConditionalExpectation`
method from the :class:`~openturns.FunctionalChaosResult` class.

.. GENERATED FROM PYTHON SOURCE LINES 255-257

Create the PCE
~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 259-264

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as otv
    from openturns.usecases import ishigami_function
    import matplotlib.pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 265-267

The next function creates a parametric PCE based on a
given PCE and a set of indices.

.. GENERATED FROM PYTHON SOURCE LINES 270-312

.. code-block:: Python

    def meanParametricPCE(chaosResult, indices):
        """
        Return the parametric PCE of Y with given input marginals set to the mean.

        All marginal inputs, except those in the conditioning indices
        are set to the mean of the input random vector.

        The resulting function is :

        g(xu) = PCE(xu, xnotu = E[Xnotu])

        where xu is the input vector of conditioning indices,
        xnotu is the input vector fixed indices and
        E[Xnotu] is the expectation of the random vector of the components
        not in u.

        Parameters
        ----------
        chaosResult: ot.FunctionalChaosResult(inputDimension)
            The polynomial chaos expansion.
        indices: ot.Indices()
            The indices of the input variables which are set to constant values.

        Returns
        -------
        parametricPCEFunction : ot.ParametricFunction(reducedInputDimension, outputDimension)
            The parametric PCE.
            The reducedInputDimension is equal to inputDimension - indices.getSize().
        """
        inputDistribution = chaosResult.getDistribution()
        if not inputDistribution.hasIndependentCopula():
            raise ValueError(
                "The input distribution has a copula" "which is not independent"
            )
        # Create the parametric function
        pceFunction = chaosResult.getMetaModel()
        xMean = inputDistribution.getMean()
        referencePoint = xMean[indices]
        parametricPCEFunction = ot.ParametricFunction(pceFunction, indices, referencePoint)
        return parametricPCEFunction









.. GENERATED FROM PYTHON SOURCE LINES 313-314

The next function creates a sparse PCE using least squares.

.. GENERATED FROM PYTHON SOURCE LINES 317-371

.. code-block:: Python

    def computeSparseLeastSquaresFunctionalChaos(
        inputTrain,
        outputTrain,
        multivariateBasis,
        basisSize,
        distribution,
        sparse=True,
    ):
        """
        Create a sparse polynomial chaos based on least squares.

        * Uses the enumerate rule in multivariateBasis.
        * Uses the LeastSquaresStrategy to compute the coefficients based on
          least squares.
        * Uses LeastSquaresMetaModelSelectionFactory to use the LARS selection method.
        * Uses FixedStrategy in order to keep all the coefficients that the
          LARS method selected.

        Parameters
        ----------
        inputTrain : ot.Sample
            The input design of experiments.
        outputTrain : ot.Sample
            The output design of experiments.
        multivariateBasis : ot.Basis
            The multivariate chaos basis.
        basisSize : int
            The size of the function basis.
        distribution : ot.Distribution.
            The distribution of the input variable.
        sparse: bool
            If True, create a sparse PCE.

        Returns
        -------
        result : ot.PolynomialChaosResult
            The estimated polynomial chaos.
        """
        if sparse:
            selectionAlgorithm = ot.LeastSquaresMetaModelSelectionFactory()
        else:
            selectionAlgorithm = ot.PenalizedLeastSquaresAlgorithmFactory()
        projectionStrategy = ot.LeastSquaresStrategy(
            inputTrain, outputTrain, selectionAlgorithm
        )
        adaptiveStrategy = ot.FixedStrategy(multivariateBasis, basisSize)
        chaosAlgorithm = ot.FunctionalChaosAlgorithm(
            inputTrain, outputTrain, distribution, adaptiveStrategy, projectionStrategy
        )
        chaosAlgorithm.run()
        chaosResult = chaosAlgorithm.getResult()
        return chaosResult









.. GENERATED FROM PYTHON SOURCE LINES 372-375

In the next cell, we create a training sample from the
Ishigami test function.
We choose a sample size equal to 1000.

.. GENERATED FROM PYTHON SOURCE LINES 377-386

.. code-block:: Python

    ot.Log.Show(ot.Log.NONE)
    ot.RandomGenerator.SetSeed(0)
    im = ishigami_function.IshigamiModel()
    input_names = im.inputDistribution.getDescription()
    sampleSize = 1000
    inputSample = im.inputDistribution.getSample(sampleSize)
    outputSample = im.model(inputSample)









.. GENERATED FROM PYTHON SOURCE LINES 387-391

We then create a sparce PCE of the Ishigami function using
a candidate basis up to the total degree equal to 12.
This leads to 455 candidate coefficients.
The coefficients are computed from least squares.

.. GENERATED FROM PYTHON SOURCE LINES 393-399

.. code-block:: Python

    multivariateBasis = ot.OrthogonalProductPolynomialFactory([im.X1, im.X2, im.X3])
    totalDegree = 12
    enumerateFunction = multivariateBasis.getEnumerateFunction()
    basisSize = enumerateFunction.getBasisSizeFromTotalDegree(totalDegree)
    print("Basis size = ", basisSize)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Basis size =  455




.. GENERATED FROM PYTHON SOURCE LINES 400-403

Finally, we create the PCE.
Only 61 coefficients are selected by the :class:`~openturns.LARS`
algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 405-416

.. code-block:: Python

    chaosResult = computeSparseLeastSquaresFunctionalChaos(
        inputSample,
        outputSample,
        multivariateBasis,
        basisSize,
        im.inputDistribution,
    )
    print("Selected basis size = ", chaosResult.getIndices().getSize())
    chaosResult






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Selected basis size =  61


.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 3</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 3</li>
      <li>transformation: 3 -> 3</li>
      <li>inverse transformation: 3 -> 3</li>
      <li>orthogonal basis dimension: 3</li>
      <li>indices size: 61</li>
      <li>relative errors: [4.89182e-12]</li>
      <li>residuals: [7.23589e-06]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0,0,0]</td>
        <td>3.500001</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[1,0,0]</td>
        <td>1.625402</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[0,2,0]</td>
        <td>-0.5947211</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[0,1,1]</td>
        <td>2.244114e-05</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[3,0,0]</td>
        <td>-1.290657</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[2,0,1]</td>
        <td>1.914665e-05</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[1,0,2]</td>
        <td>1.372414</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[0,4,0]</td>
        <td>-1.952288</td>
      </tr>
      <tr>
        <th>8</th>
        <td>[5,0,0]</td>
        <td>0.1949093</td>
      </tr>
      <tr>
        <th>9</th>
        <td>[3,0,2]</td>
        <td>-1.089753</td>
      </tr>
      <tr>
        <th>10</th>
        <td>[1,3,1]</td>
        <td>-2.098461e-05</td>
      </tr>
      <tr>
        <th>11</th>
        <td>[1,0,4]</td>
        <td>0.409178</td>
      </tr>
      <tr>
        <th>12</th>
        <td>[0,0,5]</td>
        <td>-1.356673e-05</td>
      </tr>
      <tr>
        <th>13</th>
        <td>[3,1,2]</td>
        <td>2.218517e-05</td>
      </tr>
      <tr>
        <th>14</th>
        <td>[0,6,0]</td>
        <td>1.357391</td>
      </tr>
      <tr>
        <th>15</th>
        <td>[0,5,1]</td>
        <td>1.855673e-05</td>
      </tr>
      <tr>
        <th>16</th>
        <td>[7,0,0]</td>
        <td>-0.01269673</td>
      </tr>
      <tr>
        <th>17</th>
        <td>[5,0,2]</td>
        <td>0.1645622</td>
      </tr>
      <tr>
        <th>18</th>
        <td>[3,0,4]</td>
        <td>-0.3249152</td>
      </tr>
      <tr>
        <th>19</th>
        <td>[1,6,0]</td>
        <td>2.081846e-05</td>
      </tr>
      <tr>
        <th>20</th>
        <td>[0,6,1]</td>
        <td>-1.670324e-05</td>
      </tr>
      <tr>
        <th>21</th>
        <td>[0,4,3]</td>
        <td>1.955348e-05</td>
      </tr>
      <tr>
        <th>22</th>
        <td>[0,1,6]</td>
        <td>-2.26534e-05</td>
      </tr>
      <tr>
        <th>23</th>
        <td>[8,0,0]</td>
        <td>-2.0694e-05</td>
      </tr>
      <tr>
        <th>24</th>
        <td>[7,0,1]</td>
        <td>-1.31889e-05</td>
      </tr>
      <tr>
        <th>25</th>
        <td>[3,4,1]</td>
        <td>1.171583e-05</td>
      </tr>
      <tr>
        <th>26</th>
        <td>[3,2,3]</td>
        <td>-2.385403e-05</td>
      </tr>
      <tr>
        <th>27</th>
        <td>[3,0,5]</td>
        <td>-2.743217e-05</td>
      </tr>
      <tr>
        <th>28</th>
        <td>[2,2,4]</td>
        <td>-1.903593e-05</td>
      </tr>
      <tr>
        <th>29</th>
        <td>[1,4,3]</td>
        <td>-1.483565e-05</td>
      </tr>
      <tr>
        <th>30</th>
        <td>[0,8,0]</td>
        <td>-0.3394026</td>
      </tr>
      <tr>
        <th>31</th>
        <td>[9,0,0]</td>
        <td>0.0004335569</td>
      </tr>
      <tr>
        <th>32</th>
        <td>[7,0,2]</td>
        <td>-0.01072566</td>
      </tr>
      <tr>
        <th>33</th>
        <td>[5,0,4]</td>
        <td>0.04904866</td>
      </tr>
      <tr>
        <th>34</th>
        <td>[2,2,5]</td>
        <td>-1.028609e-05</td>
      </tr>
      <tr>
        <th>35</th>
        <td>[2,0,7]</td>
        <td>2.864731e-05</td>
      </tr>
      <tr>
        <th>36</th>
        <td>[0,3,6]</td>
        <td>-3.216074e-05</td>
      </tr>
      <tr>
        <th>37</th>
        <td>[5,1,4]</td>
        <td>-1.880647e-05</td>
      </tr>
      <tr>
        <th>38</th>
        <td>[5,0,5]</td>
        <td>5.10031e-06</td>
      </tr>
      <tr>
        <th>39</th>
        <td>[3,3,4]</td>
        <td>-1.418323e-05</td>
      </tr>
      <tr>
        <th>40</th>
        <td>[2,7,1]</td>
        <td>-2.560594e-05</td>
      </tr>
      <tr>
        <th>41</th>
        <td>[2,5,3]</td>
        <td>2.569984e-05</td>
      </tr>
      <tr>
        <th>42</th>
        <td>[2,2,6]</td>
        <td>-1.644522e-05</td>
      </tr>
      <tr>
        <th>43</th>
        <td>[1,8,1]</td>
        <td>1.349855e-05</td>
      </tr>
      <tr>
        <th>44</th>
        <td>[1,6,3]</td>
        <td>-1.703189e-05</td>
      </tr>
      <tr>
        <th>45</th>
        <td>[0,10,0]</td>
        <td>0.04590642</td>
      </tr>
      <tr>
        <th>46</th>
        <td>[0,9,1]</td>
        <td>2.539924e-05</td>
      </tr>
      <tr>
        <th>47</th>
        <td>[0,7,3]</td>
        <td>-2.121373e-05</td>
      </tr>
      <tr>
        <th>48</th>
        <td>[11,0,0]</td>
        <td>-3.13448e-05</td>
      </tr>
      <tr>
        <th>49</th>
        <td>[9,0,2]</td>
        <td>0.0003350317</td>
      </tr>
      <tr>
        <th>50</th>
        <td>[8,3,0]</td>
        <td>8.887562e-06</td>
      </tr>
      <tr>
        <th>51</th>
        <td>[7,0,4]</td>
        <td>-0.003227748</td>
      </tr>
      <tr>
        <th>52</th>
        <td>[2,8,1]</td>
        <td>-1.699461e-05</td>
      </tr>
      <tr>
        <th>53</th>
        <td>[1,9,1]</td>
        <td>-2.116077e-05</td>
      </tr>
      <tr>
        <th>54</th>
        <td>[0,0,11]</td>
        <td>-8.784313e-06</td>
      </tr>
      <tr>
        <th>55</th>
        <td>[6,0,6]</td>
        <td>1.656321e-05</td>
      </tr>
      <tr>
        <th>56</th>
        <td>[3,1,8]</td>
        <td>-2.322927e-05</td>
      </tr>
      <tr>
        <th>57</th>
        <td>[2,2,8]</td>
        <td>1.572452e-05</td>
      </tr>
      <tr>
        <th>58</th>
        <td>[1,2,9]</td>
        <td>2.925562e-05</td>
      </tr>
      <tr>
        <th>59</th>
        <td>[0,12,0]</td>
        <td>-0.003970248</td>
      </tr>
      <tr>
        <th>60</th>
        <td>[0,0,12]</td>
        <td>-1.01054e-05</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 417-421

In order to see the structure of the data, we create a grid of
plots which shows all projections of :math:`Y` versus :math:`X_i`
for :math:`i = 1, 2, 3`.
We see that the Ishigami function is particularly non linear.

.. GENERATED FROM PYTHON SOURCE LINES 423-428

.. code-block:: Python

    grid = ot.VisualTest.DrawPairsXY(inputSample, outputSample)
    grid.setTitle(f"n = {sampleSize}")
    view = otv.View(grid, figure_kw={"figsize": (8.0, 3.0)})
    plt.subplots_adjust(wspace=0.4, bottom=0.25)




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_conditional_expectation_001.png
   :alt: n = 1000
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_conditional_expectation_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 429-438

Parametric function
~~~~~~~~~~~~~~~~~~~

We now create the parametric function where :math:`X_i` is free
and the other variables are set to their mean values.
We can show that a parametric PCE is, again, a PCE.
The library does not currently implement this feature.
In the next cell, we create it from the `meanParametricPCE` we defined
previously.

.. GENERATED FROM PYTHON SOURCE LINES 440-444

Create different parametric functions for the PCE.
In the next cell, we create the parametric PCE function
where :math:`X_1` is active while :math:`X_2` and :math:`X_3` are
set to their mean values.

.. GENERATED FROM PYTHON SOURCE LINES 444-449

.. code-block:: Python

    indices = [1, 2]
    parametricPCEFunction = meanParametricPCE(chaosResult, indices)
    print(parametricPCEFunction.getInputDimension())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1




.. GENERATED FROM PYTHON SOURCE LINES 450-458

Now that we know how the `meanParametricPCE` works, we loop over
the input marginal indices and consider the three functions
:math:`\widehat{\model}_1(\inputReal_1)`,
:math:`\widehat{\model}_2(\inputReal_2)` and
:math:`\widehat{\model}_3(\inputReal_3)`.
For each marginal index `i`, we we plot the output :math:`Y`
against the input marginal :math:`X_i` of the sample.
Then we plot the parametric function depending on :math:`X_i`.

.. GENERATED FROM PYTHON SOURCE LINES 460-505

.. code-block:: Python

    inputDimension = im.inputDistribution.getDimension()
    npPoints = 100
    inputRange = im.inputDistribution.getRange()
    inputLowerBound = inputRange.getLowerBound()
    inputUpperBound = inputRange.getUpperBound()
    # Create the palette with transparency
    palette = ot.Drawable().BuildDefaultPalette(2)
    firstColor = palette[0]
    r, g, b, a = ot.Drawable.ConvertToRGBA(firstColor)
    newAlpha = 64
    newColor = ot.Drawable.ConvertFromRGBA(r, g, b, newAlpha)
    palette[0] = newColor
    grid = ot.VisualTest.DrawPairsXY(inputSample, outputSample)
    reducedBasisSize = chaosResult.getCoefficients().getSize()
    grid.setTitle(
        f"n = {sampleSize}, total degree = {totalDegree}, "
        f"basis = {basisSize}, selected = {reducedBasisSize}"
    )
    for i in range(inputDimension):
        graph = grid.getGraph(0, i)
        graph.setLegends(["Data"])
        graph.setXTitle(f"$x_{1 + i}$")
        # Set all indices except i
        indices = list(range(inputDimension))
        indices.pop(i)
        parametricPCEFunction = meanParametricPCE(chaosResult, indices)
        xiMin = inputLowerBound[i]
        xiMax = inputUpperBound[i]
        curve = parametricPCEFunction.draw(xiMin, xiMax, npPoints).getDrawable(0)
        curve.setLineWidth(2.0)
        curve.setLegend(r"$PCE(x_i, x_{-i} = \mathbb{E}[X_{-i}])$")
        graph.add(curve)
        if i < inputDimension - 1:
            graph.setLegends([""])
        graph.setColors(palette)
        grid.setGraph(0, i, graph)

    grid.setLegendPosition("topright")
    view = otv.View(
        grid,
        figure_kw={"figsize": (8.0, 3.0)},
        legend_kw={"bbox_to_anchor": (1.0, 1.0), "loc": "upper left"},
    )
    plt.subplots_adjust(wspace=0.4, right=0.7, bottom=0.25)




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_conditional_expectation_002.png
   :alt: n = 1000, total degree = 12, basis = 455, selected = 61
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_conditional_expectation_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 506-511

We see that the parametric function is located within each cloud, but
sometimes seems a little vertically on the edges of the data.
More precisely, the function represents well how :math:`Y` depends
on :math:`X_2`, but does not seem to represent well how :math:`Y`
depends on :math:`X_1` or :math:`X_3`.

.. GENERATED FROM PYTHON SOURCE LINES 513-515

Conditional expectation
~~~~~~~~~~~~~~~~~~~~~~~

.. GENERATED FROM PYTHON SOURCE LINES 517-519

In the next cell, we create the conditional expectation function
:math:`\Expect{\model(\inputReal) \; | \; \inputRV_1 = \inputReal_1}`.

.. GENERATED FROM PYTHON SOURCE LINES 521-524

.. code-block:: Python

    conditionalPCE = chaosResult.getConditionalExpectation([0])
    conditionalPCE






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 1</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 1</li>
      <li>transformation: 1 -> 1</li>
      <li>inverse transformation: 1 -> 1</li>
      <li>orthogonal basis dimension: 1</li>
      <li>indices size: 8</li>
      <li>relative errors: [4.89182e-12]</li>
      <li>residuals: [7.23589e-06]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0]</td>
        <td>3.500001</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[1]</td>
        <td>1.625402</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[3]</td>
        <td>-1.290657</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[5]</td>
        <td>0.1949093</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[7]</td>
        <td>-0.01269673</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[8]</td>
        <td>-2.0694e-05</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[9]</td>
        <td>0.0004335569</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[11]</td>
        <td>-3.13448e-05</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 525-531

On output, we see that the result is, again, a PCE.
Moreover, a subset of the previous coefficients are presented in this
conditional expectation: only multi-indices which involve
:math:`X_1` are presented (and the other marginal components are removed).
We observe that the value of the coefficients are unchanged with respect to the
previous PCE.

.. GENERATED FROM PYTHON SOURCE LINES 533-535

In the next cell, we create the conditional expectation function
:math:`\Expect{\model(\inputReal) \; | \; \inputRV_2 = \inputReal_2, \inputRV_3 = \inputReal_3}`.

.. GENERATED FROM PYTHON SOURCE LINES 537-540

.. code-block:: Python

    conditionalPCE = chaosResult.getConditionalExpectation([1, 2])
    conditionalPCE






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosResult
    <ul>
      <li>input dimension: 2</li>
      <li>output dimension: 1</li>
      <li>distribution dimension: 2</li>
      <li>transformation: 2 -> 2</li>
      <li>inverse transformation: 2 -> 2</li>
      <li>orthogonal basis dimension: 2</li>
      <li>indices size: 18</li>
      <li>relative errors: [4.89182e-12]</li>
      <li>residuals: [7.23589e-06]</li>
    </ul>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Coeff.</th>
      </tr>
      <tr>
        <th>0</th>
        <td>[0,0]</td>
        <td>3.500001</td>
      </tr>
      <tr>
        <th>1</th>
        <td>[2,0]</td>
        <td>-0.5947211</td>
      </tr>
      <tr>
        <th>2</th>
        <td>[1,1]</td>
        <td>2.244114e-05</td>
      </tr>
      <tr>
        <th>3</th>
        <td>[4,0]</td>
        <td>-1.952288</td>
      </tr>
      <tr>
        <th>4</th>
        <td>[0,5]</td>
        <td>-1.356673e-05</td>
      </tr>
      <tr>
        <th>5</th>
        <td>[6,0]</td>
        <td>1.357391</td>
      </tr>
      <tr>
        <th>6</th>
        <td>[5,1]</td>
        <td>1.855673e-05</td>
      </tr>
      <tr>
        <th>7</th>
        <td>[6,1]</td>
        <td>-1.670324e-05</td>
      </tr>
      <tr>
        <th>8</th>
        <td>[4,3]</td>
        <td>1.955348e-05</td>
      </tr>
      <tr>
        <th>9</th>
        <td>[1,6]</td>
        <td>-2.26534e-05</td>
      </tr>
      <tr>
        <th>10</th>
        <td>[8,0]</td>
        <td>-0.3394026</td>
      </tr>
      <tr>
        <th>11</th>
        <td>[3,6]</td>
        <td>-3.216074e-05</td>
      </tr>
      <tr>
        <th>12</th>
        <td>[10,0]</td>
        <td>0.04590642</td>
      </tr>
      <tr>
        <th>13</th>
        <td>[9,1]</td>
        <td>2.539924e-05</td>
      </tr>
      <tr>
        <th>14</th>
        <td>[7,3]</td>
        <td>-2.121373e-05</td>
      </tr>
      <tr>
        <th>15</th>
        <td>[0,11]</td>
        <td>-8.784313e-06</td>
      </tr>
      <tr>
        <th>16</th>
        <td>[12,0]</td>
        <td>-0.003970248</td>
      </tr>
      <tr>
        <th>17</th>
        <td>[0,12]</td>
        <td>-1.01054e-05</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 541-542

We see that the conditional PCE has input dimension 2.

.. GENERATED FROM PYTHON SOURCE LINES 545-547

In the next cell, we compare the parametric PCE and the conditional
expectation of the PCE.

.. GENERATED FROM PYTHON SOURCE LINES 547-602

.. code-block:: Python


    # sphinx_gallery_thumbnail_number = 3
    inputDimension = im.inputDistribution.getDimension()
    npPoints = 100
    inputRange = im.inputDistribution.getRange()
    inputLowerBound = inputRange.getLowerBound()
    inputUpperBound = inputRange.getUpperBound()
    # Create the palette with transparency
    palette = ot.Drawable().BuildDefaultPalette(3)
    firstColor = palette[0]
    r, g, b, a = ot.Drawable.ConvertToRGBA(firstColor)
    newAlpha = 64
    newColor = ot.Drawable.ConvertFromRGBA(r, g, b, newAlpha)
    palette[0] = newColor
    grid = ot.VisualTest.DrawPairsXY(inputSample, outputSample)
    grid.setTitle(f"n = {sampleSize}, total degree = {totalDegree}")
    for i in range(inputDimension):
        graph = grid.getGraph(0, i)
        graph.setLegends(["Data"])
        graph.setXTitle(f"$x_{1 + i}$")
        xiMin = inputLowerBound[i]
        xiMax = inputUpperBound[i]
        # Set all indices except i to the mean
        indices = list(range(inputDimension))
        indices.pop(i)
        parametricPCEFunction = meanParametricPCE(chaosResult, indices)
        # Draw the parametric function
        curve = parametricPCEFunction.draw(xiMin, xiMax, npPoints).getDrawable(0)
        curve.setLineWidth(2.0)
        curve.setLineStyle("dashed")
        curve.setLegend(r"$PCE\left(x_i, x_{-i} = \mathbb{E}[X_{-i}]\right)$")
        graph.add(curve)
        # Compute conditional expectation given Xi
        conditionalPCE = chaosResult.getConditionalExpectation([i])
        print(f"i = {i}")
        print(conditionalPCE)
        conditionalPCEFunction = conditionalPCE.getMetaModel()
        curve = conditionalPCEFunction.draw(xiMin, xiMax, npPoints).getDrawable(0)
        curve.setLineWidth(2.0)
        curve.setLegend(r"$\mathbb{E}\left[PCE | X_i = x_i\right]$")
        graph.add(curve)
        if i < inputDimension - 1:
            graph.setLegends([""])
        graph.setColors(palette)
        # Set the graph into the grid
        grid.setGraph(0, i, graph)

    grid.setLegendPosition("topright")
    view = otv.View(
        grid,
        figure_kw={"figsize": (8.0, 3.0)},
        legend_kw={"bbox_to_anchor": (1.0, 1.0), "loc": "upper left"},
    )
    plt.subplots_adjust(wspace=0.4, right=0.7, bottom=0.25)




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_conditional_expectation_003.png
   :alt: n = 1000, total degree = 12
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_conditional_expectation_003.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    i = 0
    FunctionalChaosResult
    - input dimension=1
    - output dimension=1
    - distribution dimension=1
    - transformation=1 -> 1
    - inverse transformation=1 -> 1
    - orthogonal basis dimension=1
    - indices size=8
    - relative errors=[4.89182e-12]
    - residuals=[7.23589e-06]
    - is least squares=true
    - is model selection=false

    | Index | Multi-index   | Coefficient   |
    |-------|---------------|---------------|
    |     0 | [0]           | 3.5           |
    |     1 | [1]           | 1.6254        |
    |     2 | [3]           | -1.29066      |
    |     3 | [5]           | 0.194909      |
    |     4 | [7]           | -0.0126967    |
    |     5 | [8]           | -2.0694e-05   |
    |     6 | [9]           | 0.000433557   |
    |     7 | [11]          | -3.13448e-05  |

    i = 1
    FunctionalChaosResult
    - input dimension=1
    - output dimension=1
    - distribution dimension=1
    - transformation=1 -> 1
    - inverse transformation=1 -> 1
    - orthogonal basis dimension=1
    - indices size=7
    - relative errors=[4.89182e-12]
    - residuals=[7.23589e-06]
    - is least squares=true
    - is model selection=false

    | Index | Multi-index   | Coefficient   |
    |-------|---------------|---------------|
    |     0 | [0]           | 3.5           |
    |     1 | [2]           | -0.594721     |
    |     2 | [4]           | -1.95229      |
    |     3 | [6]           | 1.35739       |
    |     4 | [8]           | -0.339403     |
    |     5 | [10]          | 0.0459064     |
    |     6 | [12]          | -0.00397025   |

    i = 2
    FunctionalChaosResult
    - input dimension=1
    - output dimension=1
    - distribution dimension=1
    - transformation=1 -> 1
    - inverse transformation=1 -> 1
    - orthogonal basis dimension=1
    - indices size=4
    - relative errors=[4.89182e-12]
    - residuals=[7.23589e-06]
    - is least squares=true
    - is model selection=false

    | Index | Multi-index   | Coefficient   |
    |-------|---------------|---------------|
    |     0 | [0]           | 3.5           |
    |     1 | [5]           | -1.35667e-05  |
    |     2 | [11]          | -8.78431e-06  |
    |     3 | [12]          | -1.01054e-05  |





.. GENERATED FROM PYTHON SOURCE LINES 603-605

We see that the conditional expectation of the PCE is a better
approximation of the data set than the parametric PCE.

.. GENERATED FROM PYTHON SOURCE LINES 607-624

Conclusion
~~~~~~~~~~

In this example, we have seen how to compute the conditional
expectation of a PCE.
We have seen that this function is a good approximation of the Ishigami
function when we reduce the input dimension.
We have also seen that the parametric PCE might be a poor
approximation of the Ishigami function.
This is because the parametric PCE depends on the particular value
that we have chosen to create the parametric function.

The fact that the conditional expectation of the PCE is a
good approximation of the function when we reduce the input dimension
is a consequence of a theorem which states that the
conditional expectation is the best approximation of the
function in the least squares sense (see [girardin2018]_ page 79).

.. GENERATED FROM PYTHON SOURCE LINES 626-627

.. code-block:: Python

    otv.View.ShowAll()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 13.560 seconds)


.. _sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_conditional_expectation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_chaos_conditional_expectation.ipynb <plot_chaos_conditional_expectation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_chaos_conditional_expectation.py <plot_chaos_conditional_expectation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_chaos_conditional_expectation.zip <plot_chaos_conditional_expectation.zip>`
