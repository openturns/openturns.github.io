
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/polynomial_chaos_metamodel/plot_functional_chaos_advanced_ctors.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_advanced_ctors.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_advanced_ctors.py:


Advanced polynomial chaos construction
======================================

.. GENERATED FROM PYTHON SOURCE LINES 7-12

In this example we are going to expose advanced elements in the construction of a polynomial chaos algorithm:

- construction of the multivariate orthonormal basis,
- truncature strategy of the multivariate orthonormal basis,
- evaluation strategy of the approximation coefficients.

.. GENERATED FROM PYTHON SOURCE LINES 14-29

In this example, we consider the following function :math:`\mathbb{R}^4 \rightarrow \mathbb{R}`:

.. math::
   g(\mathbf{x}) = 1+x_1 x_2 + 2 x_3^2+x_4^4


for any :math:`x_1,x_2,x_3,x_4\in\mathbb{R}`.

We assume that the inputs have Normal, uniform, gamma and beta distributions :

.. math::
   X_1 \sim \mathcal{N}(0,1), \qquad X_2 \sim \mathcal{U}(-1,1), \qquad X_3 \sim \mathcal{G}(2.75,1), \qquad X_4 \sim \mathcal{B}(2.5,1,-1,2),


and :math:`X_1`, :math:`X_2`, :math:`X_3` and :math:`X_4` are independent.

.. GENERATED FROM PYTHON SOURCE LINES 31-33

Define the model and the input distribution
-------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 35-39

.. code-block:: Python

    import openturns as ot

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 40-42

.. code-block:: Python

    model = ot.SymbolicFunction(["x1", "x2", "x3", "x4"], ["1+x1*x2 + 2*x3^2+x4^4"])








.. GENERATED FROM PYTHON SOURCE LINES 43-44

Create a distribution of dimension 4.

.. GENERATED FROM PYTHON SOURCE LINES 46-50

.. code-block:: Python

    distribution = ot.JointDistribution(
        [ot.Normal(), ot.Uniform(), ot.Gamma(2.75, 1.0), ot.Beta(2.5, 1.0, -1.0, 2.0)]
    )








.. GENERATED FROM PYTHON SOURCE LINES 51-54

.. code-block:: Python

    inputDimension = distribution.getDimension()
    inputDimension





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    4



.. GENERATED FROM PYTHON SOURCE LINES 55-57

STEP 1: Construction of the multivariate orthonormal basis
----------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 59-60

Create the univariate polynomial family collection which regroups the polynomial families for each direction.

.. GENERATED FROM PYTHON SOURCE LINES 62-64

.. code-block:: Python

    polyColl = ot.PolynomialFamilyCollection(inputDimension)








.. GENERATED FROM PYTHON SOURCE LINES 65-66

We could use the Krawtchouk and Charlier families (for discrete distributions).

.. GENERATED FROM PYTHON SOURCE LINES 68-71

.. code-block:: Python

    polyColl[0] = ot.KrawtchoukFactory()
    polyColl[1] = ot.CharlierFactory()








.. GENERATED FROM PYTHON SOURCE LINES 72-74

We could also use the automatic selection of the polynomial which corresponds to the distribution:
this is done with the :class:`~openturns.StandardDistributionPolynomialFactory` class.

.. GENERATED FROM PYTHON SOURCE LINES 76-80

.. code-block:: Python

    for i in range(inputDimension):
        marginal = distribution.getMarginal(i)
        polyColl[i] = ot.StandardDistributionPolynomialFactory(marginal)








.. GENERATED FROM PYTHON SOURCE LINES 81-82

In our specific case, we use specific polynomial factories.

.. GENERATED FROM PYTHON SOURCE LINES 84-90

.. code-block:: Python

    polyColl[0] = ot.HermiteFactory()
    polyColl[1] = ot.LegendreFactory()
    polyColl[2] = ot.LaguerreFactory(2.75)
    # Parameter for the Jacobi factory : 'Probabilty' encoded with 1
    polyColl[3] = ot.JacobiFactory(2.5, 3.5, 1)








.. GENERATED FROM PYTHON SOURCE LINES 91-92

Create the enumeration function.

.. GENERATED FROM PYTHON SOURCE LINES 94-95

The first possibility is to use the :class:`~openturns.LinearEnumerateFunction`.

.. GENERATED FROM PYTHON SOURCE LINES 97-101

.. code-block:: Python

    enumerateFunction = ot.LinearEnumerateFunction(inputDimension)
    multivariateBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction)
    multivariateBasis






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <ul>
      <li>dimension: 4</li>
      <li>enumerate function: class=LinearEnumerateFunction dimension=4</li>
    </ul>

    <table>
      <tr>
        <th>Index</th>
        <th>Name</th>
        <th>Distribution</th>
        <th>Univariate polynomial</th>
      </tr>
      <tr>
        <td>0</td>
        <td>X0</td>
        <td>Normal</td>
        <td>HermiteFactory</td>
      </tr>
      <tr>
        <td>1</td>
        <td>X1</td>
        <td>Uniform</td>
        <td>LegendreFactory</td>
      </tr>
      <tr>
        <td>2</td>
        <td>X2</td>
        <td>Gamma</td>
        <td>LaguerreFactory</td>
      </tr>
      <tr>
        <td>3</td>
        <td>X3</td>
        <td>Beta</td>
        <td>JacobiFactory</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 102-103

Another possibility is to use the :class:`~openturns.HyperbolicAnisotropicEnumerateFunction`, which gives less weight to interactions.

.. GENERATED FROM PYTHON SOURCE LINES 105-108

.. code-block:: Python

    q = 0.4
    enumerateFunction = ot.HyperbolicAnisotropicEnumerateFunction(inputDimension, q)








.. GENERATED FROM PYTHON SOURCE LINES 109-110

Create the multivariate orthonormal basis which is the Cartesian product of the univariate basis.

.. GENERATED FROM PYTHON SOURCE LINES 112-115

.. code-block:: Python

    multivariateBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction)
    multivariateBasis






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <ul>
      <li>dimension: 4</li>
      <li>enumerate function: class=HyperbolicAnisotropicEnumerateFunction derived from class=HyperbolicAnisotropicEnumerateFunction dimension=4 q=0.4 weights=class=Point name=Unnamed dimension=4 values=[1,1,1,1]</li>
    </ul>

    <table>
      <tr>
        <th>Index</th>
        <th>Name</th>
        <th>Distribution</th>
        <th>Univariate polynomial</th>
      </tr>
      <tr>
        <td>0</td>
        <td>X0</td>
        <td>Normal</td>
        <td>HermiteFactory</td>
      </tr>
      <tr>
        <td>1</td>
        <td>X1</td>
        <td>Uniform</td>
        <td>LegendreFactory</td>
      </tr>
      <tr>
        <td>2</td>
        <td>X2</td>
        <td>Gamma</td>
        <td>LaguerreFactory</td>
      </tr>
      <tr>
        <td>3</td>
        <td>X3</td>
        <td>Beta</td>
        <td>JacobiFactory</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 116-118

Ask how many basis terms there are in the 6-th strata.
In the special case of the linear enumerate function this is also the strata with all the multi-indices of total degree 5.

.. GENERATED FROM PYTHON SOURCE LINES 118-121

.. code-block:: Python

    k = 5
    enumerateFunction.getStrataCardinal(k)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    4



.. GENERATED FROM PYTHON SOURCE LINES 122-123

Ask how many basis multi-indices have total degrees lower or equal to k=5.

.. GENERATED FROM PYTHON SOURCE LINES 123-125

.. code-block:: Python

    enumerateFunction.getBasisSizeFromTotalDegree(k)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    27



.. GENERATED FROM PYTHON SOURCE LINES 126-127

Give the k-th term of the multivariate basis. To calculate its degree, add the integers.

.. GENERATED FROM PYTHON SOURCE LINES 127-130

.. code-block:: Python

    k = 5
    enumerateFunction(k)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    [2,0,0,0]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 131-132

Build a term of the basis as a Function. Generally, we do not need to construct manually any term, all terms are constructed automatically by a strategy of construction of the basis.

.. GENERATED FROM PYTHON SOURCE LINES 134-138

.. code-block:: Python

    i = 5
    Psi_i = multivariateBasis.build(i)
    Psi_i






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    -0.707107 + 0.707107 <span>&#215;</span> x0<sup>2</sup>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 139-140

Get the measure mu associated to the multivariate basis.

.. GENERATED FROM PYTHON SOURCE LINES 142-145

.. code-block:: Python

    distributionStandard = multivariateBasis.getMeasure()
    distributionStandard






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    JointDistribution
    <ul>
      <li>name=JointDistribution</li>
      <li>dimension: 4</li>
      <li>description=[X0,X1,X2,X3]
      <li>copula: IndependentCopula(dimension = 4)</li>
    </ul>

    <table>
      <tr>
        <th>Index</th>
        <th>Variable</th>
        <th>Distribution</th>
      </tr>
      <tr>
        <td>0</td>
        <td>X0</td>
        <td>Normal(mu = 0, sigma = 1)</td>
      </tr>
      <tr>
        <td>1</td>
        <td>X1</td>
        <td>Uniform(a = -1, b = 1)</td>
      </tr>
      <tr>
        <td>2</td>
        <td>X2</td>
        <td>Gamma(k = 3.75, lambda = 1, gamma = 0)</td>
      </tr>
      <tr>
        <td>3</td>
        <td>X3</td>
        <td>Beta(alpha = 2.5, beta = 1, a = -1, b = 1)</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 146-148

STEP 2: Truncature strategy of the multivariate orthonormal basis
-----------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 150-151

FixedStrategy : all the polynomials of degree lower or equal to 2 which corresponds to the 15 first ones.

.. GENERATED FROM PYTHON SOURCE LINES 153-156

.. code-block:: Python

    p = 15
    truncatureBasisStrategy = ot.FixedStrategy(multivariateBasis, p)








.. GENERATED FROM PYTHON SOURCE LINES 157-160

CleaningStrategy : among the `maximumConsideredTerms = 500` first polynomials, those which have the `mostSignificant = 50` most significant contributions
with significance criterion `significanceFactor` equal to :math:`10^{-4}`
The `True` boolean indicates if we are interested in the online monitoring of the current basis update (removed or added coefficients).

.. GENERATED FROM PYTHON SOURCE LINES 162-169

.. code-block:: Python

    maximumConsideredTerms = 500
    mostSignificant = 50
    significanceFactor = 1.0e-4
    truncatureBasisStrategy_2 = ot.CleaningStrategy(
        multivariateBasis, maximumConsideredTerms, mostSignificant, significanceFactor
    )








.. GENERATED FROM PYTHON SOURCE LINES 170-172

STEP 3: Evaluation strategy of the approximation coefficients
-------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 174-175

The technique illustrated is the Least Squares technique where the points come from a design of experiments. Here : the Monte-Carlo sampling technique.

.. GENERATED FROM PYTHON SOURCE LINES 177-181

.. code-block:: Python

    sampleSize = 100
    evaluationCoeffStrategy = ot.LeastSquaresStrategy()
    experiment = ot.MonteCarloExperiment(distribution, sampleSize)








.. GENERATED FROM PYTHON SOURCE LINES 182-183

You can specify the approximation algorithm. This is the algorithm that generates a sequence of basis using Least Angle Regression.

.. GENERATED FROM PYTHON SOURCE LINES 185-187

.. code-block:: Python

    basisSequenceFactory = ot.LARS()








.. GENERATED FROM PYTHON SOURCE LINES 188-189

This algorithm estimates the empirical error on each sub-basis using Leave One Out strategy.

.. GENERATED FROM PYTHON SOURCE LINES 191-199

.. code-block:: Python

    fittingAlgorithm = ot.CorrectedLeaveOneOut()
    # Finally the metamodel selection algorithm embbeded in LeastSquaresStrategy
    approximationAlgorithm = ot.LeastSquaresMetaModelSelectionFactory(
        basisSequenceFactory, fittingAlgorithm
    )
    evaluationCoeffStrategy_2 = ot.LeastSquaresStrategy(approximationAlgorithm)
    experiment_2 = experiment








.. GENERATED FROM PYTHON SOURCE LINES 200-201

Try integration.

.. GENERATED FROM PYTHON SOURCE LINES 201-205

.. code-block:: Python

    marginalSizes = [2] * inputDimension
    evaluationCoeffStrategy_3 = ot.IntegrationStrategy()
    experiment_3 = ot.GaussProductExperiment(distribution, marginalSizes)








.. GENERATED FROM PYTHON SOURCE LINES 206-208

Evaluate design of experiments.
For the Gauss product we need to specify the non-uniform weights.

.. GENERATED FROM PYTHON SOURCE LINES 208-211

.. code-block:: Python

    X, W = experiment.generateWithWeights()
    Y = model(X)








.. GENERATED FROM PYTHON SOURCE LINES 212-221

STEP 4: Creation of the Functional Chaos Algorithm
--------------------------------------------------

The :class:`~openturns.FunctionalChaosAlgorithm` class combines

* the model : `model`,
* the distribution of the input random vector : `distribution`,
* the truncature strategy of the multivariate basis,
* and the evaluation strategy of the coefficients.

.. GENERATED FROM PYTHON SOURCE LINES 223-226

.. code-block:: Python

    polynomialChaosAlgorithm = ot.FunctionalChaosAlgorithm(
        X, W, Y, distribution, truncatureBasisStrategy, evaluationCoeffStrategy
    )








.. _sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_functional_chaos_advanced_ctors.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_functional_chaos_advanced_ctors.ipynb <plot_functional_chaos_advanced_ctors.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_functional_chaos_advanced_ctors.py <plot_functional_chaos_advanced_ctors.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_functional_chaos_advanced_ctors.zip <plot_functional_chaos_advanced_ctors.zip>`
