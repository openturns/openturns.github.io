.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_reliability_sensitivity_reliability_plot_strong_maximum_test.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_auto_reliability_sensitivity_reliability_plot_strong_maximum_test.py:


Strong Maximum Test design point validation
===========================================

In this example we are going to validate a FORM estimation using the Strong Maximum Test.

The Strong Maximum Test helps to evaluate the quality of the design point
resulting from the optimization algorithm. It checks whether the design point computed is:

- the **true** design point, which means a global maximum point,
- a **strong** design point, which means that there is no other local maximum
  located on the event boundary and which likelihood is slightly inferior to the design point one.

This verification is very important in order to give sense to the FORM and SORM approximations.

We briefly recall here the main principles of the test.
The objective is to detect all the points :math:`\tilde{P}^*` in the ball of radius
:math:`R_{\varepsilon} = \beta(1+\delta_{\varepsilon})` which are potentially the
real design point (case of :math:`\tilde{P}_2^*`) or which contribution to :math:`P_f` is
not negligeable as regards the approximations Form and Sorm (case of :math:`\tilde{P}_1^*`).
The contribution of a point is considered as negligeable when its likelihood in
the :math:`U`-space is more than :math:`\varepsilon`-times lesser than the design point one.
The radius :math:`R_{\varepsilon}` is the distance to the :math:`U`-space center upon which
points are considered as negligeable in the evaluation of :math:`P_f`.



.. code-block:: default

    from __future__ import print_function
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    ot.Log.Show(ot.Log.NONE)








Create the model Y = x1 + 2*x2


.. code-block:: default

    model = ot.SymbolicFunction(["x1", "x2"], ["x1+2*x2"])

    # Create the input distribution and random vector X
    inputDist = ot.Normal(2)
    inputDist.setDescription(['X1', 'X2'])

    inputVector = ot.RandomVector(inputDist)

    # Create the output random vector Y=model(X)
    output = ot.CompositeRandomVector(model, inputVector)
    output.setName("MyOutputY")








Create the physical event Y > 4


.. code-block:: default

    threshold = 4
    myEvent = ot.ThresholdEvent(output, ot.Greater(), threshold)

    # Create the associated standard event in the standard space
    myStandardEvent = ot.StandardEvent(myEvent)








First : FORM analyses to get the design point


.. code-block:: default

    myCobyla = ot.Cobyla()
    myStartingPoint = inputDist.getMean()
    myAlgoFORM = ot.FORM(myCobyla, myEvent, myStartingPoint)
    myAlgoFORM.run()
    FORMResult = myAlgoFORM.getResult()
    standardSpaceDesignPoint = FORMResult.getStandardSpaceDesignPoint()








Fix the importance level epsilon of the test
Care : 0<epsilon<1


.. code-block:: default

    importanceLevel = 0.15

    # Fix the accuracy level tau of the test
    # Care : tau >0
    # It is recommended that tau <4
    accuracyLevel = 3.0

    # Fix the confidence level (1-q) of the test
    confidenceLevel = 0.99

    # Create the Strong Maximum Test
    # CARE : the event must be declared in the standard space
    # 1. From the confidenceLevel parameter
    mySMT_CL = ot.StrongMaximumTest(myStandardEvent, standardSpaceDesignPoint,  importanceLevel, accuracyLevel,  confidenceLevel)

    # 2. Or from the  maximum number of points sampling the sphere
    pointsNumber = 1000
    mySMT_PN = ot.StrongMaximumTest(myStandardEvent, standardSpaceDesignPoint,  importanceLevel, accuracyLevel,  pointsNumber)

    # Perform the test
    mySMT_CL.run()
    mySMT_PN.run()

    # Get (or evaluate) the confidence level
    # associated to the number of points used to sample the sphere
    print('Confidence level = ', mySMT_CL.getConfidenceLevel())

    # Get (or evaluate) the number of points used to sample the sphere
    # associated the confidence level used
    print('Points Number = ', mySMT_CL.getPointNumber())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Confidence level =  0.99
    Points Number =  13





.. code-block:: default


    # Get all the points verifying the event  and outside the design point vicinity
    # Get also the values of limit state function at these points
    potentialDesignPoints = mySMT_CL.getFarDesignPointVerifyingEventPoints()
    values = mySMT_CL.getFarDesignPointVerifyingEventValues()
    print('Potential design points = ', potentialDesignPoints)
    print('Model values = ', values)

    # Get all the points verifying the event and inside the design point vicinity
    # Get also the values of limit state function at these points
    vicinityDesignPoint = mySMT_CL.getNearDesignPointVerifyingEventPoints()
    values = mySMT_CL.getNearDesignPointVerifyingEventValues()
    print('Points verifying the Event in the vicinity of the design points = ', vicinityDesignPoint)
    print('Model values = ', values)

    # Get all the points not verifying the event and outside the design point vicinity
    # Get also the values of limit state function at these points
    farSecurityPoints = mySMT_CL.getFarDesignPointViolatingEventPoints()
    values = mySMT_CL.getFarDesignPointViolatingEventValues()
    print('Points NOT verifying the Event outside the vicinity of the design points = ', farSecurityPoints)
    print('Model values = ', values)

    # Get  all the points not verifying the event and inside the design point vicinity
    # Get also the values of limit state function at these points
    vicinitySecurityPoints = mySMT_CL.getNearDesignPointViolatingEventPoints()
    values = mySMT_CL.getNearDesignPointViolatingEventValues()
    print('Points NOT verifying the Event outside the vicinity of the design points = ', vicinitySecurityPoints)
    print('Model values = ', values)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Potential design points =  
    Model values =  
    Points verifying the Event in the vicinity of the design points =  0 : [ -0.616487  4.31244  ]
    1 : [ -2.44039   3.60855  ]
    2 : [  1.76083   3.98455  ]
    3 : [ -0.957835  4.24967  ]
    4 : [  4.35576  -0.067273 ]
    5 : [ -1.2843    4.16266  ]
    6 : [  3.78191   2.16202  ]
    Model values =      [ y0      ]
    0 : [ 8.00839 ]
    1 : [ 4.77671 ]
    2 : [ 9.72993 ]
    3 : [ 7.54151 ]
    4 : [ 4.22121 ]
    5 : [ 7.04102 ]
    6 : [ 8.10595 ]
    Points NOT verifying the Event outside the vicinity of the design points =  0 : [ -4.25094  -0.952178 ]
    1 : [  1.88644  -3.92664  ]
    2 : [ -2.90383   3.24729  ]
    3 : [ -3.87129   1.99756  ]
    4 : [ -1.79512  -3.96922  ]
    5 : [ -4.10827   1.44888  ]
    Model values =      [ y0        ]
    0 : [ -6.1553   ]
    1 : [ -5.96685  ]
    2 : [  3.59075  ]
    3 : [  0.123834 ]
    4 : [ -9.73356  ]
    5 : [ -1.21052  ]
    Points NOT verifying the Event outside the vicinity of the design points =  
    Model values =  





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.006 seconds)


.. _sphx_glr_download_auto_reliability_sensitivity_reliability_plot_strong_maximum_test.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_strong_maximum_test.py <plot_strong_maximum_test.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_strong_maximum_test.ipynb <plot_strong_maximum_test.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
