
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_reliability_sensitivity/reliability/plot_event_system.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_reliability_sensitivity_reliability_plot_event_system.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_reliability_sensitivity_reliability_plot_event_system.py:


System events: unions or intersections of events
================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-22

This example illustrates system events, which are defined as unions or intersections of other events. We will show how to estimate their probability both with Monte-Carlo sampling (using the class `ProbabilitySimulationAlgorithm`) and with a first order approximation (using the class `SystemFORM`).

**Intersection**

The event defined as the intersection of several events is realized when all sub-events occurs:

.. math::
   E_{sys} = \bigcap_{i=1}^N E_i

**Union**

The event defined as the union of several events is realized when at least one sub-event occurs:

.. math::
   E_{sys} = \bigcup_{i=1}^N E_i


.. GENERATED FROM PYTHON SOURCE LINES 24-30

.. code-block:: default

    from __future__ import print_function
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 31-32

For system events, we always have to use the same root cause. 

.. GENERATED FROM PYTHON SOURCE LINES 34-38

.. code-block:: default

    dim = 2
    distribution = ot.Normal(dim)
    X = ot.RandomVector(distribution)








.. GENERATED FROM PYTHON SOURCE LINES 39-40

Define some basic events E1, E2 and E3. 

.. GENERATED FROM PYTHON SOURCE LINES 42-54

.. code-block:: default

    f1 = ot.SymbolicFunction(['x0', 'x1'], ['x0'])
    f2 = ot.SymbolicFunction(['x0', 'x1'], ['x1'])
    f3 = ot.SymbolicFunction(['x0', 'x1'], ['x0+x1'])

    Y1 = ot.CompositeRandomVector(f1, X)
    Y2 = ot.CompositeRandomVector(f2, X)
    Y3 = ot.CompositeRandomVector(f3, X)

    e1 = ot.ThresholdEvent(Y1, ot.Less(), 0.0)  # E1 <=> x0<0
    e2 = ot.ThresholdEvent(Y2, ot.Greater(), 0.0) # E2 <=> x1>0
    e3 = ot.ThresholdEvent(Y3, ot.Greater(), 0.0) # E3 <=> x0+x1>0








.. GENERATED FROM PYTHON SOURCE LINES 55-56

Define the intersection E3=E1 AND E2. 

.. GENERATED FROM PYTHON SOURCE LINES 58-60

.. code-block:: default

    e4 = ot.IntersectionEvent([e1, e2])








.. GENERATED FROM PYTHON SOURCE LINES 61-62

Approximate probability of that event: :math:`\approx 1/4`. 

.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: default

    e4.getSample(10000).computeMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[0.253]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 67-68

Define the union E4=E1 OR E2. 

.. GENERATED FROM PYTHON SOURCE LINES 70-72

.. code-block:: default

    e5 = ot.UnionEvent([e1, e2])








.. GENERATED FROM PYTHON SOURCE LINES 73-74

Approximate probability of that event: :math:`\approx ~3/4`. 

.. GENERATED FROM PYTHON SOURCE LINES 76-78

.. code-block:: default

    e5.getSample(10000).computeMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[0.7472]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 79-80

It supports recursion: define E7=E1 OR (E1 AND E3). 

.. GENERATED FROM PYTHON SOURCE LINES 82-85

.. code-block:: default

    e7 = ot.UnionEvent([e1, ot.IntersectionEvent([e2, e3])])
    print(e3.isComposite())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    True




.. GENERATED FROM PYTHON SOURCE LINES 86-88

With Monte-Carlo algorithm
--------------------------

.. GENERATED FROM PYTHON SOURCE LINES 90-91

Of course, we can use simulation algorithms. 

.. GENERATED FROM PYTHON SOURCE LINES 93-102

.. code-block:: default

    experiment = ot.MonteCarloExperiment()
    algo = ot.ProbabilitySimulationAlgorithm(e7, experiment)
    algo.setMaximumOuterSampling(2500)
    algo.setBlockSize(4)
    algo.setMaximumCoefficientOfVariation(-1.0)
    algo.run()
    result = algo.getResult()
    result.getProbabilityEstimate()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.7479999999999998



.. GENERATED FROM PYTHON SOURCE LINES 103-109

SystemFORM
----------

`SystemFORM` is an approximation method suitable for system events.

The event must be in its disjunctive normal form (union of intersections, or a single intersection).

.. GENERATED FROM PYTHON SOURCE LINES 111-112

root cause

.. GENERATED FROM PYTHON SOURCE LINES 112-124

.. code-block:: default

    dim = 5
    mean = [200.0] * dim
    mean[-1] = 60
    mean[-2] = 60
    sigma = [30.0] * dim
    sigma[-1] = 15.0
    R = ot.CorrelationMatrix(dim)
    for i in range(dim):
        for j in range(i):
            R[i, j] = 0.5
    dist = ot.Normal(mean, sigma, R)








.. GENERATED FROM PYTHON SOURCE LINES 125-126

leaf events

.. GENERATED FROM PYTHON SOURCE LINES 126-134

.. code-block:: default

    X = ot.RandomVector(dist)
    inputs = ['M1', 'M2', 'M3', 'M4', 'M5']
    e0 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(inputs, ['M1-M2+M4']), X), ot.Less(), 0.0)
    e1 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(inputs, ['M2+2*M3-M4']), X), ot.Less(), 0.0)
    e2 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(inputs, ['2*M3-2*M4-M5']), X), ot.Less(), 0.0)
    e3 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(inputs, ['-(M1+M2+M4+M5-5*10.0)']), X), ot.Less(), 0.0)
    e4 = ot.ThresholdEvent(ot.CompositeRandomVector(ot.SymbolicFunction(inputs, ['-(M2+2*M3+M4-5*40.0)']), X), ot.Less(), 0.0)








.. GENERATED FROM PYTHON SOURCE LINES 135-136

system event in DNF form (union of intersections)

.. GENERATED FROM PYTHON SOURCE LINES 136-138

.. code-block:: default

    event = ot.UnionEvent([ot.IntersectionEvent([e0, e3, e4]), ot.IntersectionEvent([e2, e3, e4])])








.. GENERATED FROM PYTHON SOURCE LINES 139-140

compute probability with basic sampling

.. GENERATED FROM PYTHON SOURCE LINES 140-142

.. code-block:: default

    event.getSample(10000).computeMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[0.0828]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 143-144

Run systemFORM.

.. GENERATED FROM PYTHON SOURCE LINES 146-157

.. code-block:: default

    solver = ot.AbdoRackwitz()
    solver.setMaximumIterationNumber(1000)
    solver.setMaximumAbsoluteError(1.0e-3)
    solver.setMaximumRelativeError(1.0e-3)
    solver.setMaximumResidualError(1.0e-3)
    solver.setMaximumConstraintError(1.0e-3)

    algo = ot.SystemFORM(solver, event, mean)
    algo.run()
    result = algo.getResult()
    result.getEventProbability()




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    0.07883551213326333




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.260 seconds)


.. _sphx_glr_download_auto_reliability_sensitivity_reliability_plot_event_system.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_event_system.py <plot_event_system.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_event_system.ipynb <plot_event_system.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
