
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_reliability_sensitivity/central_dispersion/plot_central_tendency.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_reliability_sensitivity_central_dispersion_plot_central_tendency.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_reliability_sensitivity_central_dispersion_plot_central_tendency.py:


Analyse the central tendency of a cantilever beam
=================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-10

In this example we perform a central tendency analysis of a random variable Y using the various methods available.
We consider the :ref:`cantilever beam <use-case-cantilever-beam>` example and show
how to use the `TaylorExpansionMoments` and `ExpectationSimulationAlgorithm` classes.

.. GENERATED FROM PYTHON SOURCE LINES 12-19

.. code-block:: Python

    from openturns.usecases import cantilever_beam
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 20-21

We first load the data class from the usecases module :

.. GENERATED FROM PYTHON SOURCE LINES 21-23

.. code-block:: Python

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 24-28

We want to create the random variable of interest :math:`Y=g(X)` where :math:`g(.)` is the physical model and :math:`X` is the input vectors.

We create the input parameters distribution and make a random vector.
For the sake of this example, we consider an independent copula.

.. GENERATED FROM PYTHON SOURCE LINES 28-33

.. code-block:: Python


    distribution = ot.JointDistribution([cb.E, cb.F, cb.L, cb.II])
    X = ot.RandomVector(distribution)
    X.setDescription(["E", "F", "L", "I"])








.. GENERATED FROM PYTHON SOURCE LINES 34-35

`f` is the cantilever beam model :

.. GENERATED FROM PYTHON SOURCE LINES 35-37

.. code-block:: Python

    f = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 38-39

The random variable of interest Y is then

.. GENERATED FROM PYTHON SOURCE LINES 39-42

.. code-block:: Python

    Y = ot.CompositeRandomVector(f, X)
    Y.setDescription("Y")








.. GENERATED FROM PYTHON SOURCE LINES 43-45

Taylor expansion
----------------

.. GENERATED FROM PYTHON SOURCE LINES 47-48

Perform Taylor approximation to get the expected value of Y and the importance factors.

.. GENERATED FROM PYTHON SOURCE LINES 50-62

.. code-block:: Python

    taylor = ot.TaylorExpansionMoments(Y)
    taylor_mean_fo = taylor.getMeanFirstOrder()
    taylor_mean_so = taylor.getMeanSecondOrder()
    taylor_cov = taylor.getCovariance()
    taylor_if = taylor.getImportanceFactors()
    print("model evaluation calls number=", f.getGradientCallsNumber())
    print("model gradient calls number=", f.getGradientCallsNumber())
    print("model hessian calls number=", f.getHessianCallsNumber())
    print("taylor mean first order=", taylor_mean_fo)
    print("taylor variance=", taylor_cov)
    print("taylor importance factors=", taylor_if)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    model evaluation calls number= 1
    model gradient calls number= 1
    model hessian calls number= 1
    taylor mean first order= [0.170111]
    taylor variance= [[ 0.00041128 ]]
    taylor importance factors= [E : 0.0471628, F : 0.703601, L : 0.0811537, I : 0.168082]




.. GENERATED FROM PYTHON SOURCE LINES 63-66

.. code-block:: Python

    graph = taylor.drawImportanceFactors()
    view = viewer.View(graph)




.. image-sg:: /auto_reliability_sensitivity/central_dispersion/images/sphx_glr_plot_central_tendency_001.png
   :alt: Importance Factors from Taylor expansions - Y
   :srcset: /auto_reliability_sensitivity/central_dispersion/images/sphx_glr_plot_central_tendency_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 67-69

We see that, at first order, the variable :math:`F` explains about 70% of the variance of the output :math:`Y`.
On the other hand, the variable :math:`E` is the least significant in the variance of the output: :math:`E` only explains about 5% of the output variance.

.. GENERATED FROM PYTHON SOURCE LINES 71-73

Monte-Carlo simulation
----------------------

.. GENERATED FROM PYTHON SOURCE LINES 75-76

Perform a Monte Carlo simulation of Y to estimate its mean.

.. GENERATED FROM PYTHON SOURCE LINES 78-92

.. code-block:: Python

    algo = ot.ExpectationSimulationAlgorithm(Y)
    algo.setMaximumOuterSampling(1000)
    algo.setCoefficientOfVariationCriterionType("NONE")
    algo.run()
    print("model evaluation calls number=", f.getEvaluationCallsNumber())
    expectation_result = algo.getResult()
    expectation_mean = expectation_result.getExpectationEstimate()
    print(
        "monte carlo mean=",
        expectation_mean,
        "var=",
        expectation_result.getVarianceEstimate(),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    model evaluation calls number= 1001
    monte carlo mean= [0.170862] var= [4.16463e-07]




.. GENERATED FROM PYTHON SOURCE LINES 93-95

Central dispersion analysis based on a sample
---------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 97-98

Directly compute statistical moments based on a sample of Y. Sometimes the probabilistic model is not available and the study needs to start from the data.

.. GENERATED FROM PYTHON SOURCE LINES 100-106

.. code-block:: Python

    Y_s = Y.getSample(1000)
    y_mean = Y_s.computeMean()
    y_stddev = Y_s.computeStandardDeviation()
    y_quantile_95p = Y_s.computeQuantilePerComponent(0.95)
    print("mean=", y_mean, "stddev=", y_stddev, "quantile@95%", y_quantile_95p)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    mean= [0.170247] stddev= [0.0196868] quantile@95% [0.206176]




.. GENERATED FROM PYTHON SOURCE LINES 107-112

.. code-block:: Python

    graph = ot.KernelSmoothing().build(Y_s).drawPDF()
    graph.setTitle("Kernel smoothing approximation of the output distribution")
    view = viewer.View(graph)

    plt.show()



.. image-sg:: /auto_reliability_sensitivity/central_dispersion/images/sphx_glr_plot_central_tendency_002.png
   :alt: Kernel smoothing approximation of the output distribution
   :srcset: /auto_reliability_sensitivity/central_dispersion/images/sphx_glr_plot_central_tendency_002.png
   :class: sphx-glr-single-img






.. _sphx_glr_download_auto_reliability_sensitivity_central_dispersion_plot_central_tendency.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_central_tendency.ipynb <plot_central_tendency.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_central_tendency.py <plot_central_tendency.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_central_tendency.zip <plot_central_tendency.zip>`
