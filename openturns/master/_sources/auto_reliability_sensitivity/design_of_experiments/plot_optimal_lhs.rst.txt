
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_reliability_sensitivity/design_of_experiments/plot_optimal_lhs.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_reliability_sensitivity_design_of_experiments_plot_optimal_lhs.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_reliability_sensitivity_design_of_experiments_plot_optimal_lhs.py:


Optimize an LHS design of experiments
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 7-8

This examples show how to generate optimized LHS experiments according to the different criteria.

.. GENERATED FROM PYTHON SOURCE LINES 10-16

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 17-18

**LHS and space filling**

.. GENERATED FROM PYTHON SOURCE LINES 20-40

.. code-block:: Python

    N = 100
    # Considering independent Uniform distributions of dimension 3
    # Bounds are (-1,1), (0,2) and (0, 0.5)
    distribution = ot.JointDistribution(
        [ot.Uniform(-1.0, 1.0), ot.Uniform(0.0, 2.0), ot.Uniform(0.0, 0.5)]
    )
    # Random LHS
    lhs = ot.LHSExperiment(distribution, N)
    lhs.setAlwaysShuffle(True)  # randomized
    design = lhs.generate()
    # C2
    c2 = ot.SpaceFillingC2().evaluate(design)
    # PhiP with default p
    phip = ot.SpaceFillingPhiP().evaluate(design)
    # mindist
    mindist = ot.SpaceFillingMinDist().evaluate(design)
    # For p->infinity
    phip_inf = ot.SpaceFillingPhiP(100).evaluate(design)
    print(phip, mindist, phip_inf)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    30.25429286266814 0.03967883091869973 30.254292857678614




.. GENERATED FROM PYTHON SOURCE LINES 41-42

**Optimized LHS using Monte Carlo**

.. GENERATED FROM PYTHON SOURCE LINES 44-59

As with Monte Carlo, user decides of a fixed number of iterations,
but this time this number is part of the temperature profile.

Two profiles are currently provided:
- Linear profile: :math:`T_i = T_0 (1-\frac{1}{n_{iter}})`
- Geometric profile: :math:`T_i = T_O c^i, 0<c<1`

Starting from an LHS design, a new design is built by permuting a random coordinate of two randomly chosen sample points;
this new design is also an LHS, but not necessarily a more efficient design.

A comparison of criteria of the two designs is done, and the new LHS is accepted with probability

.. math::
   min\left(exp{\left[-\frac{\Phi(LHS_{new}) - \Phi(LHS)}{T_i}\right]}, 1\right)


.. GENERATED FROM PYTHON SOURCE LINES 61-62

Considering independent Uniform(0,1) distributions of dimension 3

.. GENERATED FROM PYTHON SOURCE LINES 62-69

.. code-block:: Python

    distribution = ot.JointDistribution([ot.Uniform(0.0, 1.0)] * 3)
    # Random LHS
    lhs = ot.LHSExperiment(distribution, N)
    lhs.setAlwaysShuffle(True)  # randomized
    algo = ot.SimulatedAnnealingLHS(lhs)
    design = algo.generate()








.. GENERATED FROM PYTHON SOURCE LINES 70-71

One could also fix the criterion, the temperature profile and get more results.

.. GENERATED FROM PYTHON SOURCE LINES 71-101

.. code-block:: Python


    # Considering independent Uniform distributions of dimension 3
    # Bounds are (-1,1), (0,2) and (0, 0.5)
    distribution = ot.JointDistribution(
        [ot.Uniform(-1.0, 1.0), ot.Uniform(0.0, 2.0), ot.Uniform(0.0, 0.5)]
    )
    # Random LHS
    lhs = ot.LHSExperiment(distribution, N)
    lhs.setAlwaysShuffle(True)  # randomized
    # Fixing C2 crit
    space_filling = ot.SpaceFillingC2()
    # Defining a temperature profile
    # A geometric profile seems accurate with default parameters
    # e.g. T0=10, c=0.95, iMax=2000
    temperatureProfile = ot.GeometricProfile()
    algo = ot.SimulatedAnnealingLHS(lhs, space_filling, temperatureProfile)
    # optimal design
    design = algo.generate()
    result = algo.getResult()
    # Criteria for the optimal design
    crit_c2 = result.getC2()
    crit_phip = result.getPhiP()
    crit_mindist = result.getMinDist()
    # History of the criterion used for optimization
    history = result.getAlgoHistory()
    criterion_hist = history[:, 0]
    # Additional results
    temperature_hist = history[:, 1]
    probability_hist = history[:, 2]








.. GENERATED FROM PYTHON SOURCE LINES 102-103

It is also possible to chain several iterations of the whole process with different starting points.

.. GENERATED FROM PYTHON SOURCE LINES 103-125

.. code-block:: Python

    N = 10

    # Considering independent Uniform distributions of dimension 3
    # Bounds are (-1,1), (0,2) and (0, 0.5)
    distribution = ot.JointDistribution(
        [ot.Uniform(-1.0, 1.0), ot.Uniform(0.0, 2.0), ot.Uniform(0.0, 0.5)]
    )
    # Random LHS
    lhs = ot.LHSExperiment(distribution, N)
    lhs.setAlwaysShuffle(True)  # randomized
    # Fixing PhiP crit
    space_filling = ot.SpaceFillingPhiP()
    # Defining a temperature profile
    # T0=10, iMax=3000
    temperatureProfile = ot.LinearProfile(10.0, 3000)
    algo = ot.SimulatedAnnealingLHS(lhs, space_filling, temperatureProfile)
    restart = 50
    design = algo.generateWithRestart(restart)
    # Retrieve all optimal designs
    result = algo.getResult()
    designs = [result.getOptimalDesign(i) for i in range(restart)]








.. GENERATED FROM PYTHON SOURCE LINES 126-127

Finally, we could start the optimization process of LHS using a precomputed LHS design.

.. GENERATED FROM PYTHON SOURCE LINES 127-146

.. code-block:: Python


    # Considering independent Uniform distributions of dimension 3
    # Bounds are (0,1)^3
    distribution = ot.JointDistribution([ot.Uniform(0.0, 1.0)] * 3)
    # Random LHS
    lhs = ot.LHSExperiment(distribution, N)
    lhs.setAlwaysShuffle(True)  # randomized
    # Fixing C2 crit for example
    space_filling = ot.SpaceFillingC2()
    # Defining a temperature profile
    # T0=10, iMax=3000
    temperatureProfile = ot.LinearProfile(10.0, 3000)
    algo = ot.SimulatedAnnealingLHS(lhs, space_filling, temperatureProfile)
    design = algo.generate()
    result = algo.getResult()
    # check history ==> draw criterion
    graph = result.drawHistoryCriterion()
    view = viewer.View(graph)




.. image-sg:: /auto_reliability_sensitivity/design_of_experiments/images/sphx_glr_plot_optimal_lhs_001.png
   :alt: C2 criterion history of optimal design
   :srcset: /auto_reliability_sensitivity/design_of_experiments/images/sphx_glr_plot_optimal_lhs_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 147-149

Convergence needs to be performed
New algo starting from this design

.. GENERATED FROM PYTHON SOURCE LINES 149-152

.. code-block:: Python

    algo = ot.SimulatedAnnealingLHS(design, distribution, space_filling, temperatureProfile)
    design = algo.generate()
    plt.show()








.. _sphx_glr_download_auto_reliability_sensitivity_design_of_experiments_plot_optimal_lhs.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_optimal_lhs.ipynb <plot_optimal_lhs.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_optimal_lhs.py <plot_optimal_lhs.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_optimal_lhs.zip <plot_optimal_lhs.zip>`
