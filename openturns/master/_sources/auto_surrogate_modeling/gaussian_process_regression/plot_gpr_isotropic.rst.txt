
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_surrogate_modeling/gaussian_process_regression/plot_gpr_isotropic.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_surrogate_modeling_gaussian_process_regression_plot_gpr_isotropic.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_surrogate_modeling_gaussian_process_regression_plot_gpr_isotropic.py:


Gaussian Process Regression: use an isotropic covariance kernel
===============================================================

In typical machine learning applications, Gaussian process regression
surrogate models take several inputs,
and those inputs are usually heterogeneous
(e.g. in the :doc:`cantilever beam
</auto_surrogate_modeling/gaussian_process_regression/plot_gpr_cantilever_beam>` use case,
inputs are various physical quantities).

In geostatistical applications however, inputs are typically spatial
coordinates, which means one can assume the output varies at the same rate
in all directions.
This calls for a specific kind of covariance kernel, represented
in the library by the :class:`~openturns.IsotropicCovarianceModel` class.

.. GENERATED FROM PYTHON SOURCE LINES 18-21

.. code-block:: Python


    # TODO : change reference to plot_gpr_cantilever_beam








.. GENERATED FROM PYTHON SOURCE LINES 22-25

Modeling temperature across a surface
-------------------------------------
In this example, we collect temperature data over a floorplan using sensors.

.. GENERATED FROM PYTHON SOURCE LINES 27-49

.. code-block:: Python

    import numpy as np
    import openturns as ot
    import matplotlib.pyplot as plt


    coordinates = ot.Sample(
        [
            [100.0, 100.0],
            [500.0, 100.0],
            [900.0, 100.0],
            [100.0, 350.0],
            [500.0, 350.0],
            [900.0, 350.0],
            [100.0, 600.0],
            [500.0, 600.0],
            [900.0, 600.0],
        ]
    )
    observations = ot.Sample(
        [[25.0], [25.0], [10.0], [20.0], [25.0], [20.0], [15.0], [25.0], [25.0]]
    )








.. GENERATED FROM PYTHON SOURCE LINES 50-51

Let us plot the data.

.. GENERATED FROM PYTHON SOURCE LINES 51-62

.. code-block:: Python


    # Extract coordinates.
    x = np.array(coordinates[:, 0])
    y = np.array(coordinates[:, 1])

    # Plot the data with a scatter plot and a color map.
    fig = plt.figure()
    plt.scatter(x, y, c=observations, cmap="viridis")
    plt.colorbar()
    plt.show()




.. image-sg:: /auto_surrogate_modeling/gaussian_process_regression/images/sphx_glr_plot_gpr_isotropic_001.svg
   :alt: plot gpr isotropic
   :srcset: /auto_surrogate_modeling/gaussian_process_regression/images/sphx_glr_plot_gpr_isotropic_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 63-66

Because we are going to view several Gaussian Process Regression models in this example,
we use a function to automate the process of optimizing the scale parameter
and producing the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 66-96

.. code-block:: Python


    lower = 50.0
    upper = 1000.0


    def fitGPR(coordinates, observations, covarianceModel, basis):
        """
        Fit the parameters of a Gaussian Process Regression surrogate model.
        """
        # Set the starting scale for the optimization.
        scale_dimension = covarianceModel.getScale().getDimension()
        covarianceModel.setScale([upper] * scale_dimension)

        # Prepare to fit Gaussian process hyperparameters.
        fitter = ot.GaussianProcessFitter(
            coordinates, observations, covarianceModel, basis
        )

        # Fit the GP hyperparameters.
        fitter.run()
        fitter_result = fitter.getResult()

        # Based on the GP hyperparameters perform the regression.
        regression = ot.GaussianProcessRegression(fitter_result)
        regression.run()
        result = regression.getResult()
        surrogate = result.getMetaModel()
        return result, surrogate









.. GENERATED FROM PYTHON SOURCE LINES 97-98

Let us define a helper function to plot Gaussian Process Regression predictions.

.. GENERATED FROM PYTHON SOURCE LINES 98-131

.. code-block:: Python



    def plotGPRPredictions(gprModel):
        """
        Plot the predictions of a Gaussian Process Regression surrogate model.
        """
        # Create the mesh of the box [0., 1000.] * [0., 700.]
        myInterval = ot.Interval([0.0, 0.0], [1000.0, 700.0])

        # Define the number of intervals in each direction of the box
        nx = 20
        ny = 20
        myIndices = [nx - 1, ny - 1]
        myMesher = ot.IntervalMesher(myIndices)
        myMeshBox = myMesher.build(myInterval)

        # Predict
        vertices = myMeshBox.getVertices()
        predictions = gprModel(vertices)

        # Format for plot
        X = np.array(vertices[:, 0]).reshape((ny, nx))
        Y = np.array(vertices[:, 1]).reshape((ny, nx))
        predictions_array = np.array(predictions).reshape((ny, nx))

        # Plot
        plt.figure()
        plt.pcolormesh(X, Y, predictions_array, shading="auto")
        plt.colorbar()
        plt.show()
        return









.. GENERATED FROM PYTHON SOURCE LINES 132-136

Predict with an anisotropic geometric covariance kernel
-------------------------------------------------------
In order to illustrate the usefulness of isotropic covariance kernels,
we first perform prediction with an anisotropic geometric kernel.

.. GENERATED FROM PYTHON SOURCE LINES 138-145

Keep in mind that, when there are more than one input dimension,
the :class:`~openturns.CovarianceModel` classes use a multidimensional
scale parameter :math:`\vect{\theta}`.
They are anisotropic geometric by default.

Our example has two input dimensions,
so :math:`\vect{\theta} = (\theta_1, \theta_2)`.

.. GENERATED FROM PYTHON SOURCE LINES 145-153

.. code-block:: Python



    inputDimension = 2
    basis = ot.ConstantBasisFactory(inputDimension).build()
    covarianceModel = ot.SquaredExponential(inputDimension)
    gpr_result, surrogate_model = fitGPR(coordinates, observations, covarianceModel, basis)
    plotGPRPredictions(surrogate_model)




.. image-sg:: /auto_surrogate_modeling/gaussian_process_regression/images/sphx_glr_plot_gpr_isotropic_002.svg
   :alt: plot gpr isotropic
   :srcset: /auto_surrogate_modeling/gaussian_process_regression/images/sphx_glr_plot_gpr_isotropic_002.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 154-157

We see weird vertical columns on the plot.
How did this happen? Let us have a look at the optimized scale parameter
:math:`\hat{\vect{\theta}} = (\hat{\theta}_1, \hat{\theta}_2)`.

.. GENERATED FROM PYTHON SOURCE LINES 157-159

.. code-block:: Python


    print(gpr_result.getCovarianceModel().getScale())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [7.06852,365.498]




.. GENERATED FROM PYTHON SOURCE LINES 160-161

The value of :math:`\hat{\theta}_1` is actually equal to the lower bound:

.. GENERATED FROM PYTHON SOURCE LINES 161-164

.. code-block:: Python


    print(lower)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    50.0




.. GENERATED FROM PYTHON SOURCE LINES 165-167

This means that temperatures are likely to vary a lot along the X axis
and much slower across the Y axis based on the observation data.

.. GENERATED FROM PYTHON SOURCE LINES 169-174

Predict with an isotropic covariance kernel
---------------------------------------------------
If we know that variations of the temperature are isotropic
(i.e. with no priviledged direction),
we can embed this information within the covariance kernel.

.. GENERATED FROM PYTHON SOURCE LINES 174-177

.. code-block:: Python


    isotropic = ot.IsotropicCovarianceModel(ot.SquaredExponential(), inputDimension)








.. GENERATED FROM PYTHON SOURCE LINES 178-183

The :class:`~openturns.IsotropicCovarianceModel` class creates an isotropic
version with a given input dimension of a :class:`~openturns.CovarianceModel`.
Because is isotropic, it only needs one scale parameter :math:`\theta_{iso}`
and it will make sure :math:`\theta_1 = \theta_2 = \theta_{iso}` at all times
during the optimization.

.. GENERATED FROM PYTHON SOURCE LINES 183-187

.. code-block:: Python


    gpr_result, surrogate_model = fitGPR(coordinates, observations, isotropic, basis)
    print(gpr_result.getCovarianceModel().getScale())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [286.419]




.. GENERATED FROM PYTHON SOURCE LINES 188-189

Prediction with the isotropic covariance kernel is much more satisfactory.

.. GENERATED FROM PYTHON SOURCE LINES 189-192

.. code-block:: Python


    # sphinx_gallery_thumbnail_number = 3
    plotGPRPredictions(surrogate_model)



.. image-sg:: /auto_surrogate_modeling/gaussian_process_regression/images/sphx_glr_plot_gpr_isotropic_003.svg
   :alt: plot gpr isotropic
   :srcset: /auto_surrogate_modeling/gaussian_process_regression/images/sphx_glr_plot_gpr_isotropic_003.svg
   :class: sphx-glr-single-img






.. _sphx_glr_download_auto_surrogate_modeling_gaussian_process_regression_plot_gpr_isotropic.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_gpr_isotropic.ipynb <plot_gpr_isotropic.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_gpr_isotropic.py <plot_gpr_isotropic.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_gpr_isotropic.zip <plot_gpr_isotropic.zip>`
