
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>SpectralGaussianProcess &#8212; OpenTURNS  documentation</title>
    <link rel="stylesheet" href="../../_static/openturns.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="GaussianProcess" href="openturns.GaussianProcess.html" />
    <link rel="prev" title="Hamming" href="openturns.Hamming.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="http://www.openturns.org/">Home</a></li>
    <li><a href="../../install.html">Get it</a></li>
    <li><a href="../../contents.html">Doc</a></li>
    <li><a href="https://github.com/openturns">Code</a></li>
    <li><a href="https://github.com/openturns/openturns/issues">Bugs</a></li>
  </ul>
  <a href="../../index.html">
    <h1>
      <img src="../../_static/logo-openturns-wo-bg.png" alt="" width=100px height=100px />
      OpenTURNS
    </h1>
    <h2> An Open source initiative for the Treatment of Uncertainties, Risks'N Statistics</h2>
  </a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="openturns.GaussianProcess.html" title="GaussianProcess"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="openturns.Hamming.html" title="Hamming"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">OpenTURNS  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../contents.html" >Contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../user_manual.html" >API</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../stochastic_process.html" accesskey="U">Stochastic process</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="openturns.Hamming.html"
                        title="previous chapter">Hamming</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="openturns.GaussianProcess.html"
                        title="next chapter">GaussianProcess</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/user_manual/_generated/openturns.SpectralGaussianProcess.rst"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="spectralgaussianprocess">
<h1>SpectralGaussianProcess<a class="headerlink" href="#spectralgaussianprocess" title="Permalink to this headline">¶</a></h1>
<p>(<a class="reference external" href="../../user_manual/_generated/openturns-SpectralGaussianProcess-1.py">Source code</a>, <a class="reference external" href="../../user_manual/_generated/openturns-SpectralGaussianProcess-1.png">png</a>, <a class="reference external" href="../../user_manual/_generated/openturns-SpectralGaussianProcess-1.hires.png">hires.png</a>, <a class="reference external" href="../../user_manual/_generated/openturns-SpectralGaussianProcess-1.pdf">pdf</a>)</p>
<div class="figure align-default">
<img alt="../../_images/openturns-SpectralGaussianProcess-1.png" src="../../_images/openturns-SpectralGaussianProcess-1.png" />
</div>
<dl class="class">
<dt id="openturns.SpectralGaussianProcess">
<em class="property">class </em><code class="sig-name descname">SpectralGaussianProcess</code><span class="sig-paren">(</span><em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Spectral Gaussian process.</p>
<dl>
<dt>Available constructors:</dt><dd><p>SpectralGaussianProcess(<em>spectralModel, timeGrid</em>)</p>
<p>SpectralGaussianProcess(<em>spectralModel, maxFreq, N</em>)</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>timeGrid</strong><span class="classifier"><a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a></span></dt><dd><p>The time grid associated to the process.
The algorithm is only implemented when the mesh is a regular grid.</p>
</dd>
<dt><strong>spectralModel</strong><span class="classifier"><a class="reference internal" href="openturns.SpectralModel.html#openturns.SpectralModel" title="openturns.SpectralModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralModel</span></code></a></span></dt><dd></dd>
<dt><strong>maxFreq</strong><span class="classifier">float</span></dt><dd><p>Equal to the maximal frequency minus <img class="math" src="../../_images/math/c36f669b30a54333a07138e2f377d14d190353b9.svg" alt="\Delta f"/>.</p>
</dd>
<dt><strong>N</strong><span class="classifier">float</span></dt><dd><p>The number of points in the frequency grid, which is equal to the number of
time stamps of the time grid.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>In the first usage, we fix the time grid and the second order model (spectral
density model) which implements the process. The frequency discretization is
deduced from the time discretization by the formulas
<img class="math" src="../../_images/math/3bb5c6e8197742bda9b9029786494d6998b3ef45.svg" alt="f_{max} = \frac{1}{\Delta t}, \quad \Delta f = \frac{1}{t_{max}}, N = \frac{f_{max}}{\Delta f}= \frac{t_{max}}{\Delta t}"/></p></li>
<li><p>In the second usage, the process is fixed in the frequency domain. <em>fmax</em>
value and <em>N</em> induce the time grid. Care: the maximal frequency used in the
computation is not <em>fmax</em> but <img class="math" src="../../_images/math/ef334d602b0c1aa89e0e65ce7eb48bc00ae9519e.svg" alt="(1-1/N)fmax = fmax - \Delta f"/>.</p></li>
<li><p>In the third usage, the spectral model is given and the other arguments are
the same as the first usage.</p></li>
<li><p>In the fourth usage, the spectral model is given and the other arguments are
the same as the second usage.</p></li>
</ul>
<p>The first call of <a class="reference internal" href="#openturns.SpectralGaussianProcess.getRealization" title="openturns.SpectralGaussianProcess.getRealization"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getRealization()</span></code></a> might be time consuming because it
computes <img class="math" src="../../_images/math/740219495c5b12f680f503149cd6a3d24d7374cb.svg" alt="N"/> hermitian matrices of size <img class="math" src="../../_images/math/6c17a829872725512568f56ec42c4bb56a3ded7c.svg" alt="d \times \ d"/>, where
<img class="math" src="../../_images/math/e850273a52c7b4f7137b8cd36bf72c0825f8a6d7.svg" alt="d"/> is the dimension of the spectral model. These matrices are factorized
and stored in order to be used for each call of the <em>getRealization</em> method.</p>
<p class="rubric">Examples</p>
<p>Create a <em>SpectralGaussianProcess</em> from a spectral model and a time grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">openturns</span> <span class="k">as</span> <span class="nn">ot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialCorrelation</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">CorrelationMatrix</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spatialCorrelation</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">myTimeGrid</span> <span class="o">=</span>  <span class="n">ot</span><span class="o">.</span><span class="n">RegularGrid</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mySpectralModel</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">CauchyModel</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">spatialCorrelation</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mySpectNormProc1</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">SpectralGaussianProcess</span><span class="p">(</span><span class="n">mySpectralModel</span><span class="p">,</span> <span class="n">myTimeGrid</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getClassName" title="openturns.SpectralGaussianProcess.getClassName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getClassName</span></code></a>(self)</p></td>
<td><p>Accessor to the object’s name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getContinuousRealization" title="openturns.SpectralGaussianProcess.getContinuousRealization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getContinuousRealization</span></code></a>(self)</p></td>
<td><p>Get a continuous realization.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getCovarianceModel" title="openturns.SpectralGaussianProcess.getCovarianceModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getCovarianceModel</span></code></a>(self)</p></td>
<td><p>Accessor to the covariance model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getDescription" title="openturns.SpectralGaussianProcess.getDescription"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getDescription</span></code></a>(self)</p></td>
<td><p>Get the description of the process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getFFTAlgorithm" title="openturns.SpectralGaussianProcess.getFFTAlgorithm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getFFTAlgorithm</span></code></a>(self)</p></td>
<td><p>Get the FFT algorithm used to generate realizations of the spectral Gaussian process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getFrequencyGrid" title="openturns.SpectralGaussianProcess.getFrequencyGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getFrequencyGrid</span></code></a>(self)</p></td>
<td><p>Get the frequency grid used to discretize the spectral model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getFrequencyStep" title="openturns.SpectralGaussianProcess.getFrequencyStep"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getFrequencyStep</span></code></a>(self)</p></td>
<td><p>Get the frequency step <img class="math" src="../../_images/math/c36f669b30a54333a07138e2f377d14d190353b9.svg" alt="\Delta f"/> used to discretize the spectral model.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getFuture" title="openturns.SpectralGaussianProcess.getFuture"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getFuture</span></code></a>(self, \*args)</p></td>
<td><p>Prediction of the <img class="math" src="../../_images/math/740219495c5b12f680f503149cd6a3d24d7374cb.svg" alt="N"/> future iterations of the process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getId" title="openturns.SpectralGaussianProcess.getId"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getId</span></code></a>(self)</p></td>
<td><p>Accessor to the object’s id.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getInputDimension" title="openturns.SpectralGaussianProcess.getInputDimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getInputDimension</span></code></a>(self)</p></td>
<td><p>Get the dimension of the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getMarginal" title="openturns.SpectralGaussianProcess.getMarginal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMarginal</span></code></a>(self, \*args)</p></td>
<td><p>Get the <img class="math" src="../../_images/math/330a968478c29d75335bb3afea843e96cc00378d.svg" alt="k^{th}"/> marginal of the random process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getMaximalFrequency" title="openturns.SpectralGaussianProcess.getMaximalFrequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMaximalFrequency</span></code></a>(self)</p></td>
<td><p>Get the maximal frequency used in the computation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getMesh" title="openturns.SpectralGaussianProcess.getMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getMesh</span></code></a>(self)</p></td>
<td><p>Get the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getNFrequency" title="openturns.SpectralGaussianProcess.getNFrequency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getNFrequency</span></code></a>(self)</p></td>
<td><p>Get the  number of points in the frequency grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getName" title="openturns.SpectralGaussianProcess.getName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getName</span></code></a>(self)</p></td>
<td><p>Accessor to the object’s name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getOutputDimension" title="openturns.SpectralGaussianProcess.getOutputDimension"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getOutputDimension</span></code></a>(self)</p></td>
<td><p>Get the dimension of the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getRealization" title="openturns.SpectralGaussianProcess.getRealization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getRealization</span></code></a>(self)</p></td>
<td><p>Get a realization of the process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getSample" title="openturns.SpectralGaussianProcess.getSample"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSample</span></code></a>(self, size)</p></td>
<td><p>Get <img class="math" src="../../_images/math/6dd74dfb7ff6eff513acaa90195f45bb6f794012.svg" alt="n"/> realizations of the process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getShadowedId" title="openturns.SpectralGaussianProcess.getShadowedId"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getShadowedId</span></code></a>(self)</p></td>
<td><p>Accessor to the object’s shadowed id.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getSpectralModel" title="openturns.SpectralGaussianProcess.getSpectralModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getSpectralModel</span></code></a>(self)</p></td>
<td><p>Get the spectral model.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getTimeGrid" title="openturns.SpectralGaussianProcess.getTimeGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getTimeGrid</span></code></a>(self)</p></td>
<td><p>Get the time grid of observation of the process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getTrend" title="openturns.SpectralGaussianProcess.getTrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getTrend</span></code></a>(self)</p></td>
<td><p>Accessor to the trend.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.getVisibility" title="openturns.SpectralGaussianProcess.getVisibility"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVisibility</span></code></a>(self)</p></td>
<td><p>Accessor to the object’s visibility state.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.hasName" title="openturns.SpectralGaussianProcess.hasName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hasName</span></code></a>(self)</p></td>
<td><p>Test if the object is named.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.hasVisibleName" title="openturns.SpectralGaussianProcess.hasVisibleName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hasVisibleName</span></code></a>(self)</p></td>
<td><p>Test if the object has a distinguishable name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.isComposite" title="openturns.SpectralGaussianProcess.isComposite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isComposite</span></code></a>(self)</p></td>
<td><p>Test whether the process is composite or not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.isNormal" title="openturns.SpectralGaussianProcess.isNormal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isNormal</span></code></a>(self)</p></td>
<td><p>Test whether the process is normal or not.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.isStationary" title="openturns.SpectralGaussianProcess.isStationary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isStationary</span></code></a>(self)</p></td>
<td><p>Test whether the process is stationary or not.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setDescription" title="openturns.SpectralGaussianProcess.setDescription"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setDescription</span></code></a>(self, description)</p></td>
<td><p>Set the description of the process.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setFFTAlgorithm" title="openturns.SpectralGaussianProcess.setFFTAlgorithm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setFFTAlgorithm</span></code></a>(self, fft)</p></td>
<td><p>Set the FFT algorithm used to generate realizations of the spectral Gaussian process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setMesh" title="openturns.SpectralGaussianProcess.setMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setMesh</span></code></a>(self, mesh)</p></td>
<td><p>Set the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setName" title="openturns.SpectralGaussianProcess.setName"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setName</span></code></a>(self, name)</p></td>
<td><p>Accessor to the object’s name.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setShadowedId" title="openturns.SpectralGaussianProcess.setShadowedId"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setShadowedId</span></code></a>(self, id)</p></td>
<td><p>Accessor to the object’s shadowed id.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setTimeGrid" title="openturns.SpectralGaussianProcess.setTimeGrid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setTimeGrid</span></code></a>(self, timeGrid)</p></td>
<td><p>Set the time grid of observation of the process.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#openturns.SpectralGaussianProcess.setVisibility" title="openturns.SpectralGaussianProcess.setVisibility"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setVisibility</span></code></a>(self, visible)</p></td>
<td><p>Accessor to the object’s visibility state.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 57%" />
<col style="width: 43%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>AdaptGrid</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="openturns.SpectralGaussianProcess.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getClassName">
<code class="sig-name descname">getClassName</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getClassName" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s name.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>class_name</strong><span class="classifier">str</span></dt><dd><p>The object class name (<cite>object.__class__.__name__</cite>).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getContinuousRealization">
<code class="sig-name descname">getContinuousRealization</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getContinuousRealization" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a continuous realization.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>realization</strong><span class="classifier"><a class="reference internal" href="openturns.Function.html#openturns.Function" title="openturns.Function"><code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code></a></span></dt><dd><p>According to the process, the continuous realizations are built:</p>
<ul class="simple">
<li><p>either using a dedicated functional model if it exists: e.g. a functional
basis process.</p></li>
<li><p>or using an interpolation from a discrete realization of the process on
<img class="math" src="../../_images/math/663aa9a04b4fdfd0484efc4552316c1c1849cce6.svg" alt="\cM"/>: in dimension <img class="math" src="../../_images/math/f052617b551bcb6705214a766078381458e242d7.svg" alt="d=1"/>, a linear interpolation and in
dimension <img class="math" src="../../_images/math/6291462f011d4038d56e4b06d39beff56c9d1ee6.svg" alt="d \geq 2"/>, a piecewise constant function (the value at a
given position is equal to the value at the nearest vertex of the mesh of
the process).</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getCovarianceModel">
<code class="sig-name descname">getCovarianceModel</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getCovarianceModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the covariance model.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>cov_model</strong><span class="classifier"><a class="reference internal" href="openturns.CovarianceModel.html#openturns.CovarianceModel" title="openturns.CovarianceModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">CovarianceModel</span></code></a></span></dt><dd><p>Covariance model, if any.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getDescription">
<code class="sig-name descname">getDescription</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the description of the process.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>description</strong><span class="classifier"><a class="reference internal" href="openturns.Description.html#openturns.Description" title="openturns.Description"><code class="xref py py-class docutils literal notranslate"><span class="pre">Description</span></code></a></span></dt><dd><p>Description of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getFFTAlgorithm">
<code class="sig-name descname">getFFTAlgorithm</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getFFTAlgorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the FFT algorithm used to generate realizations of the spectral Gaussian process.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>fftAlgo</strong><span class="classifier"><a class="reference internal" href="openturns.FFT.html#openturns.FFT" title="openturns.FFT"><code class="xref py py-class docutils literal notranslate"><span class="pre">FFT</span></code></a></span></dt><dd><p>FFT algorithm used to generate realizations of the spectral Gaussian process.
By default, it is the <a class="reference internal" href="openturns.KissFFT.html#openturns.KissFFT" title="openturns.KissFFT"><code class="xref py py-class docutils literal notranslate"><span class="pre">KissFFT</span></code></a> algorithm.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getFrequencyGrid">
<code class="sig-name descname">getFrequencyGrid</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getFrequencyGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the frequency grid used to discretize the spectral model.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>freqGrid</strong><span class="classifier"><a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a></span></dt><dd><p>The frequency grid used to discretize the spectral model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getFrequencyStep">
<code class="sig-name descname">getFrequencyStep</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getFrequencyStep" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the frequency step <img class="math" src="../../_images/math/c36f669b30a54333a07138e2f377d14d190353b9.svg" alt="\Delta f"/> used to discretize the spectral model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freqStep</strong><span class="classifier">float</span></dt><dd><p>The frequency step <img class="math" src="../../_images/math/c36f669b30a54333a07138e2f377d14d190353b9.svg" alt="\Delta f"/> used to discretize the spectral model.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getFuture">
<code class="sig-name descname">getFuture</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getFuture" title="Permalink to this definition">¶</a></dt>
<dd><p>Prediction of the <img class="math" src="../../_images/math/740219495c5b12f680f503149cd6a3d24d7374cb.svg" alt="N"/> future iterations of the process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>stepNumber</strong><span class="classifier">int, <img class="math" src="../../_images/math/8e76b5cc1f2f0763ed8baca1715efce18fd90445.svg" alt="N \geq 0"/></span></dt><dd><p>Number of future steps.</p>
</dd>
<dt><strong>size</strong><span class="classifier">int, <img class="math" src="../../_images/math/838f15472a3eb4e858b0eb0ef1119ec3e82f9079.svg" alt="size \geq 0"/>, optional</span></dt><dd><p>Number of futures needed. Default is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>prediction</strong><span class="classifier"><a class="reference internal" href="openturns.ProcessSample.html#openturns.ProcessSample" title="openturns.ProcessSample"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessSample</span></code></a> or <a class="reference internal" href="openturns.TimeSeries.html#openturns.TimeSeries" title="openturns.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a></span></dt><dd><p><img class="math" src="../../_images/math/740219495c5b12f680f503149cd6a3d24d7374cb.svg" alt="N"/> future iterations of the process.
If <img class="math" src="../../_images/math/f3eff5c784ab095d69ad949513a1699bd263c80f.svg" alt="size = 1"/>, <em>prediction</em> is a <a class="reference internal" href="openturns.TimeSeries.html#openturns.TimeSeries" title="openturns.TimeSeries"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeSeries</span></code></a>.
Otherwise, it is a <a class="reference internal" href="openturns.ProcessSample.html#openturns.ProcessSample" title="openturns.ProcessSample"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessSample</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getId">
<code class="sig-name descname">getId</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getId" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s id.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">int</span></dt><dd><p>Internal unique identifier.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getInputDimension">
<code class="sig-name descname">getInputDimension</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getInputDimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimension of the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>Dimension of the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/>: <img class="math" src="../../_images/math/6dd74dfb7ff6eff513acaa90195f45bb6f794012.svg" alt="n"/>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getMarginal">
<code class="sig-name descname">getMarginal</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">*args</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getMarginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the <img class="math" src="../../_images/math/330a968478c29d75335bb3afea843e96cc00378d.svg" alt="k^{th}"/> marginal of the random process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>k</strong><span class="classifier">int or list of ints <img class="math" src="../../_images/math/7e7212f433d712b93b4480b341a0d66878ef6f98.svg" alt="0 \leq k &lt; d"/></span></dt><dd><p>Index of the marginal(s) needed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>marginals</strong><span class="classifier"><a class="reference internal" href="openturns.Process.html#openturns.Process" title="openturns.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">Process</span></code></a></span></dt><dd><p>Process defined with marginal(s) of the random process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getMaximalFrequency">
<code class="sig-name descname">getMaximalFrequency</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getMaximalFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximal frequency used in the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>freqMax</strong><span class="classifier">float</span></dt><dd><p>The maximal frequency used in the computation: <img class="math" src="../../_images/math/ef334d602b0c1aa89e0e65ce7eb48bc00ae9519e.svg" alt="(1-1/N)fmax = fmax - \Delta f"/>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getMesh">
<code class="sig-name descname">getMesh</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the mesh.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>mesh</strong><span class="classifier"><a class="reference internal" href="openturns.Mesh.html#openturns.Mesh" title="openturns.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a></span></dt><dd><p>Mesh over which the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/> is discretized.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getNFrequency">
<code class="sig-name descname">getNFrequency</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getNFrequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the  number of points in the frequency grid.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>freqGrid</strong><span class="classifier"><a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a></span></dt><dd><p>The number <img class="math" src="../../_images/math/740219495c5b12f680f503149cd6a3d24d7374cb.svg" alt="N"/> of points in the frequency grid, which is equal to the
number of time stamps of the time grid.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getName">
<code class="sig-name descname">getName</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getName" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s name.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getOutputDimension">
<code class="sig-name descname">getOutputDimension</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getOutputDimension" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dimension of the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>d</strong><span class="classifier">int</span></dt><dd><p>Dimension of the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getRealization">
<code class="sig-name descname">getRealization</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getRealization" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a realization of the process.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>realization</strong><span class="classifier"><a class="reference internal" href="openturns.Field.html#openturns.Field" title="openturns.Field"><code class="xref py py-class docutils literal notranslate"><span class="pre">Field</span></code></a></span></dt><dd><p>Contains a mesh over which the process is discretized and the values of the
process at the vertices of the mesh.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getSample">
<code class="sig-name descname">getSample</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getSample" title="Permalink to this definition">¶</a></dt>
<dd><p>Get <img class="math" src="../../_images/math/6dd74dfb7ff6eff513acaa90195f45bb6f794012.svg" alt="n"/> realizations of the process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n</strong><span class="classifier">int, <img class="math" src="../../_images/math/7d4d98bd40ec5827fbee59c9401a8167082b93f5.svg" alt="n \geq 0"/></span></dt><dd><p>Number of realizations of the process needed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>processSample</strong><span class="classifier"><a class="reference internal" href="openturns.ProcessSample.html#openturns.ProcessSample" title="openturns.ProcessSample"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProcessSample</span></code></a></span></dt><dd><p><img class="math" src="../../_images/math/6dd74dfb7ff6eff513acaa90195f45bb6f794012.svg" alt="n"/> realizations of the random process. A process sample is a
collection of fields which share the same mesh <img class="math" src="../../_images/math/db23aa6d3b5b4a8284b16df4f070d6591dcb35c1.svg" alt="\cM \in \Rset^n"/>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getShadowedId">
<code class="sig-name descname">getShadowedId</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getShadowedId" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s shadowed id.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">int</span></dt><dd><p>Internal unique identifier.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getSpectralModel">
<code class="sig-name descname">getSpectralModel</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getSpectralModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the spectral model.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>specMod</strong><span class="classifier"><a class="reference internal" href="openturns.SpectralModel.html#openturns.SpectralModel" title="openturns.SpectralModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpectralModel</span></code></a></span></dt><dd><p>The spectral model defining the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getTimeGrid">
<code class="sig-name descname">getTimeGrid</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getTimeGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the time grid of observation of the process.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>timeGrid</strong><span class="classifier"><a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a></span></dt><dd><p>Time grid of a process when the mesh associated to the
process can be interpreted as a <a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a>. We check
if the vertices of the mesh are scalar and are regularly spaced in
<img class="math" src="../../_images/math/3d96a678badf58a51ae5dba6193060e2d1083c2c.svg" alt="\Rset"/> but we don’t check if the connectivity of the mesh is conform
to the one of a regular grid (without any hole and composed of ordered
instants).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getTrend">
<code class="sig-name descname">getTrend</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getTrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the trend.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>trend</strong><span class="classifier"><a class="reference internal" href="openturns.TrendTransform.html#openturns.TrendTransform" title="openturns.TrendTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">TrendTransform</span></code></a></span></dt><dd><p>Trend, if any.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.getVisibility">
<code class="sig-name descname">getVisibility</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.getVisibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s visibility state.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>visible</strong><span class="classifier">bool</span></dt><dd><p>Visibility flag.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.hasName">
<code class="sig-name descname">hasName</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.hasName" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the object is named.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hasName</strong><span class="classifier">bool</span></dt><dd><p>True if the name is not empty.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.hasVisibleName">
<code class="sig-name descname">hasVisibleName</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.hasVisibleName" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the object has a distinguishable name.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hasVisibleName</strong><span class="classifier">bool</span></dt><dd><p>True if the name is not empty and not the default one.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.isComposite">
<code class="sig-name descname">isComposite</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.isComposite" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the process is composite or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>isComposite</strong><span class="classifier">bool</span></dt><dd><p><em>True</em> if the process is composite (built upon a function and a process).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.isNormal">
<code class="sig-name descname">isNormal</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.isNormal" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the process is normal or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>isNormal</strong><span class="classifier">bool</span></dt><dd><p><em>True</em> if the process is normal.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A stochastic process is normal if all its finite dimensional joint
distributions are normal, which means that for all <img class="math" src="../../_images/math/0292eddb9d807c5c4fa8e4da816e0a6e29961a7a.svg" alt="k \in \Nset"/> and
<img class="math" src="../../_images/math/897cb15dc28807f6831c656f7aa3411a99c43bc9.svg" alt="I_k \in \Nset^*"/>, with <img class="math" src="../../_images/math/6ced3705bc7f846ffe50f58b151420e96e8bcf6c.svg" alt="cardI_k=k"/>, there is
<img class="math" src="../../_images/math/7e13bcdd4fff9c30959bbc5a7b584b1e9667c794.svg" alt="\vect{m}_1, \dots, \vect{m}_k \in \Rset^d"/> and
<img class="math" src="../../_images/math/74b29557f1dd30e8d00569c23b442253e41d7643.svg" alt="\mat{C}_{1,\dots,k}\in\mathcal{M}_{kd,kd}(\Rset)"/> such that:</p>
<div class="math">
<p><img src="../../_images/math/4eabdd0d8c0b9b4648348babff60ccb0b4741bda.svg" alt="\Expect{\exp\left\{i\Tr{\vect{X}}_{I_k} \vect{U}_{k}  \right\}} =
\exp{\left\{i\Tr{\vect{U}}_{k}\vect{M}_{k}-\frac{1}{2}\Tr{\vect{U}}_{k}\mat{C}_{1,\dots,k}\vect{U}_{k}\right\}}"/></p>
</div><p>where <img class="math" src="../../_images/math/426c6802475638261372b820661c2a7e85d01147.svg" alt="\Tr{\vect{X}}_{I_k} = (\Tr{X}_{\vect{t}_1}, \hdots, \Tr{X}_{\vect{t}_k})"/>,
<img class="math" src="../../_images/math/ae26cd7223e178c32e5c587791c12f1f8fd24886.svg" alt="\\Tr{vect{U}}_{k} = (\Tr{\vect{u}}_{1}, \hdots, \Tr{\vect{u}}_{k})"/> and
<img class="math" src="../../_images/math/bf0cfc26933eaf31d69b7fbcfdccefe38dc4045a.svg" alt="\Tr{\vect{M}}_{k} = (\Tr{\vect{m}}_{1}, \hdots, \Tr{\vect{m}}_{k})"/> and
<img class="math" src="../../_images/math/b2cd8b1b336480025b2632d45d850e816301b717.svg" alt="\mat{C}_{1,\dots,k}"/> is the symmetric matrix:</p>
<div class="math">
<p><img src="../../_images/math/83f37dd0c93190e88561df6ac2117993ff3fddcd.svg" alt="\mat{C}_{1,\dots,k} = \left(
\begin{array}{cccc}
  C(\vect{t}_1, \vect{t}_1) &amp;C(\vect{t}_1, \vect{t}_2) &amp; \hdots &amp; C(\vect{t}_1, \vect{t}_{k}) \\
  \hdots &amp; C(\vect{t}_2, \vect{t}_2)  &amp; \hdots &amp; C(\vect{t}_2, \vect{t}_{k}) \\
  \hdots &amp; \hdots &amp; \hdots &amp; \hdots \\
  \hdots &amp; \hdots &amp; \hdots &amp; C(\vect{t}_{k}, \vect{t}_{k})
\end{array}
\right)"/></p>
</div><p>A Gaussian process is entirely defined by its mean function <img class="math" src="../../_images/math/0b9d153ad711199f04d35fb7809764ef031f4125.svg" alt="m"/> and its
covariance function <img class="math" src="../../_images/math/8386434e075badbe111200fc04360b61ebad2dab.svg" alt="C"/> (or correlation function <img class="math" src="../../_images/math/4c1e61a97a8d13c6c03c93620bfc12a522de5efb.svg" alt="R"/>).</p>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.isStationary">
<code class="sig-name descname">isStationary</code><span class="sig-paren">(</span><em class="sig-param">self</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.isStationary" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the process is stationary or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>isStationary</strong><span class="classifier">bool</span></dt><dd><p><em>True</em> if the process is stationary.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A process <img class="math" src="../../_images/math/7f4fec4d90527658ec378be1ddee2489ba8127a7.svg" alt="X"/> is stationary if its distribution is invariant by
translation: <img class="math" src="../../_images/math/217ca2216be406dda48667cd59050d7947d0e5ce.svg" alt="\forall k \in \Nset"/>,
<img class="math" src="../../_images/math/e523985aea1fb50af1a67fff3aeb0fdf40e125fd.svg" alt="\forall (\vect{t}_1, \dots, \vect{t}_k) \in \cD"/>,
<img class="math" src="../../_images/math/94c3bd610e2630a2d67c3ebc67a1f4fb181fe68f.svg" alt="\forall \vect{h}\in \Rset^n"/>, we have:</p>
<div class="math">
<p><img src="../../_images/math/b031771bb0fd1f1badc723010a4c3e635d1ebd27.svg" alt="(X_{\vect{t}_1}, \dots, X_{\vect{t}_k})
\stackrel{\mathcal{D}}{=} (X_{\vect{t}_1+\vect{h}}, \dots, X_{\vect{t}_k+\vect{h}})"/></p>
</div></dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setDescription">
<code class="sig-name descname">setDescription</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">description</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the description of the process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>description</strong><span class="classifier">sequence of str</span></dt><dd><p>Description of the process.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setFFTAlgorithm">
<code class="sig-name descname">setFFTAlgorithm</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">fft</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setFFTAlgorithm" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the FFT algorithm used to generate realizations of the spectral Gaussian process.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>fftAlgo</strong><span class="classifier"><a class="reference internal" href="openturns.FFT.html#openturns.FFT" title="openturns.FFT"><code class="xref py py-class docutils literal notranslate"><span class="pre">FFT</span></code></a></span></dt><dd><p>FFT algorithm that will be used to generate realizations of the spectral
Gaussian process. The <a class="reference internal" href="openturns.KissFFT.html#openturns.KissFFT" title="openturns.KissFFT"><code class="xref py py-class docutils literal notranslate"><span class="pre">KissFFT</span></code></a> is provided.
More efficient implementations are provided by the <em>openturns-fftw</em> module.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setMesh">
<code class="sig-name descname">setMesh</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">mesh</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the mesh.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>mesh</strong><span class="classifier"><a class="reference internal" href="openturns.Mesh.html#openturns.Mesh" title="openturns.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a></span></dt><dd><p>Mesh over which the domain <img class="math" src="../../_images/math/49286fbd056c7ee87f2ca755f67f651549507ff9.svg" alt="\cD"/> is discretized.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setName">
<code class="sig-name descname">setName</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setName" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>The name of the object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setShadowedId">
<code class="sig-name descname">setShadowedId</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">id</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setShadowedId" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s shadowed id.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>id</strong><span class="classifier">int</span></dt><dd><p>Internal unique identifier.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setTimeGrid">
<code class="sig-name descname">setTimeGrid</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">timeGrid</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setTimeGrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the time grid of observation of the process.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl>
<dt><strong>timeGrid</strong><span class="classifier"><a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a></span></dt><dd><p>Time grid of observation of the process when the mesh associated to the
process can be interpreted as a <a class="reference internal" href="openturns.RegularGrid.html#openturns.RegularGrid" title="openturns.RegularGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">RegularGrid</span></code></a>. We check
if the vertices of the mesh are scalar and are regularly spaced in
<img class="math" src="../../_images/math/3d96a678badf58a51ae5dba6193060e2d1083c2c.svg" alt="\Rset"/> but we don’t check if the connectivity of the mesh is conform
to the one of a regular grid (without any hole and composed of ordered
instants).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="openturns.SpectralGaussianProcess.setVisibility">
<code class="sig-name descname">setVisibility</code><span class="sig-paren">(</span><em class="sig-param">self</em>, <em class="sig-param">visible</em><span class="sig-paren">)</span><a class="headerlink" href="#openturns.SpectralGaussianProcess.setVisibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor to the object’s visibility state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>visible</strong><span class="classifier">bool</span></dt><dd><p>Visibility flag.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="openturns.GaussianProcess.html" title="GaussianProcess"
             >next</a> |</li>
        <li class="right" >
          <a href="openturns.Hamming.html" title="Hamming"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">OpenTURNS  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../contents.html" >Contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../user_manual.html" >API</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../stochastic_process.html" >Stochastic process</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005-2019 Airbus-EDF-IMACS-Phimeca.
      Last updated on Jun 05, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.1.0.
    </div>
  </body>
</html>