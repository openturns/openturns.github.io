.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_calibration_least_squares_and_gaussian_calibration_plot_calibration_chaboche.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_auto_calibration_least_squares_and_gaussian_calibration_plot_calibration_chaboche.py:


Calibration of the Chaboche mechanical model
============================================

Deterministic model
-------------------

The Chaboche mecanical law predicts the stress depending on the strain:

.. math::
   \sigma = G(\epsilon,R,C,\gamma) = R + \frac{C}{\gamma} (1-\exp(-\gamma\epsilon))


where:

- :math:`\epsilon` is the strain,
- :math:`\sigma` is the stress (Pa),
- :math:`R`, :math:`C`, :math:`\gamma` are the parameters.

The variables have the following distributions and are supposed to be independent.

 ================  ===========================================================
 Random var.       Distribution
 ================  ===========================================================
 :math:`R`         Lognormal (:math:`\mu = 750` MPa, :math:`\sigma = 11` MPa)
 :math:`C`         Normal (:math:`\mu = 2750` MPa, :math:`\sigma = 250` MPa)
 :math:`\gamma`    Normal (:math:`\mu = 10`, :math:`\sigma = 2`)
 :math:`\epsilon`  Uniform(a=0, b=0.07).
 ================  ===========================================================

Parameters to calibrate
-----------------------

The vector of parameters to calibrate is:

.. math::
   \theta = (R,C,\gamma).


We set:

- :math:`R = 750\times 10^6`,
- :math:`C = 2750\times 10^6`,
- :math:`\gamma = 10`.

Observations
------------

In order to create a calibration problem, we make the hypothesis that the strain has the following distribution:

.. math::
   \epsilon \sim Uniform(0,0.07).


Moreover, we consider a gaussian noise on the observed constraint:

.. math::
   \epsilon_\sigma \sim \mathcal{N} \left(0,10\times 10^6\right)


and we make the hypothesis that the observation errors are independent.
We set the number of observations to:

.. math::
   n = 100.


We generate a Monte-Carlo sampling with size :math:`n`:

.. math::
   \sigma_i = G(\epsilon_i,R,C,\gamma) + (\epsilon_\sigma)_i,


for :math:`i = 1,..., n`.
The observations are the pairs :math:`\{(\epsilon_i,\sigma_i)\}_{i=1,...,n}`, i.e. each observation is a couple made of the strain and the corresponding stress.

Thanks to
---------

- Antoine Dumas, Phimeca


References
----------

- J. Lemaitre and J. L. Chaboche (2002) "Mechanics of solid materials" Cambridge University Press.


Generate the observations
-------------------------


.. code-block:: default

    import numpy as np
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    ot.Log.Show(ot.Log.NONE)








Define the model.


.. code-block:: default

    def modelChaboche(X):
        strain, R, C, gamma = X
        stress = R + C * (1 - np.exp(-gamma * strain)) / gamma
        return [stress]









Create the Python function.


.. code-block:: default

    g = ot.PythonFunction(4, 1, modelChaboche)








Define the random vector.


.. code-block:: default

    Strain = ot.Uniform(0, 0.07)
    unknownR = 750e6
    unknownC = 2750e6
    unknownGamma = 10
    R = ot.Dirac(unknownR)
    C = ot.Dirac(unknownC)
    Gamma = ot.Dirac(unknownGamma)

    Strain.setDescription(["Strain"])
    R.setDescription(["R"])
    C.setDescription(["C"])
    Gamma.setDescription(["Gamma"])








Create the joint input distribution function.


.. code-block:: default

    inputDistribution = ot.ComposedDistribution([Strain, R, C, Gamma])








Create the Monte-Carlo sample.


.. code-block:: default

    sampleSize = 100
    inputSample = inputDistribution.getSample(sampleSize)
    outputStress = g(inputSample)
    outputStress[0:5]






.. raw:: html

    <TABLE><TR><TD></TD><TH>y0</TH></TR>
    <TR><TH>0</TH><TD>8.488914e+08</TD></TR>
    <TR><TH>1</TH><TD>8.783113e+08</TD></TR>
    <TR><TH>2</TH><TD>8.754496e+08</TD></TR>
    <TR><TH>3</TH><TD>8.872187e+08</TD></TR>
    <TR><TH>4</TH><TD>8.595783e+08</TD></TR>
    </TABLE>
    <br />
    <br />

Plot the histogram of the output.


.. code-block:: default

    histoGraph = ot.HistogramFactory().build(outputStress / 1.0e6).drawPDF()
    histoGraph.setTitle("Histogram of the sample stress")
    histoGraph.setXTitle("Stress (MPa)")
    histoGraph.setLegends([""])
    view = viewer.View(histoGraph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_001.png
    :alt: Histogram of the sample stress
    :class: sphx-glr-single-img





Generate observation noise.


.. code-block:: default

    stressObservationNoiseSigma = 10.0e6  # (Pa)
    noiseSigma = ot.Normal(0.0, stressObservationNoiseSigma)
    sampleNoiseH = noiseSigma.getSample(sampleSize)
    observedStress = outputStress + sampleNoiseH









.. code-block:: default

    observedStrain = inputSample[:, 0]









.. code-block:: default

    graph = ot.Graph("Observations", "Strain", "Stress (MPa)", True)
    cloud = ot.Cloud(observedStrain, observedStress / 1.0e6)
    graph.add(cloud)
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_002.png
    :alt: Observations
    :class: sphx-glr-single-img





Set the calibration parameters
------------------------------

Define the value of the reference values of the :math:`\theta` parameter. In the bayesian framework, this is called the mean of the *prior* gaussian distribution. In the data assimilation framework, this is called the *background*.


.. code-block:: default

    R = 700e6  # Exact : 750e6
    C = 2500e6  # Exact : 2750e6
    Gamma = 8.0  # Exact : 10
    thetaPrior = ot.Point([R, C, Gamma])









The following statement create the calibrated function from the model. The calibrated parameters `R`, `C`, `Gamma` are at indices 1, 2, 3 in the inputs arguments of the model.


.. code-block:: default

    calibratedIndices = [1, 2, 3]
    mycf = ot.ParametricFunction(g, calibratedIndices, thetaPrior)








Calibration with linear least squares
-------------------------------------

The `LinearLeastSquaresCalibration` class performs the linear least squares calibration by linearizing the model in the neighbourhood of the reference point.


.. code-block:: default

    algo = ot.LinearLeastSquaresCalibration(
        mycf, observedStrain, observedStress, thetaPrior, "SVD"
    )








The `run` method computes the solution of the problem.


.. code-block:: default

    algo.run()









.. code-block:: default

    calibrationResult = algo.getResult()








Analysis of the results
-----------------------

The `getParameterMAP` method returns the maximum of the posterior distribution of :math:`\theta`.


.. code-block:: default

    thetaMAP = calibrationResult.getParameterMAP()
    thetaMAP






.. raw:: html

    <p>[7.48178e+08,2.80672e+09,10.4592]</p>
    <br />
    <br />

We can compute a 95% confidence interval of the parameter :math:`\theta^\star`.


.. code-block:: default

    thetaPosterior = calibrationResult.getParameterPosterior()
    thetaPosterior.computeBilateralConfidenceIntervalWithMarginalProbability(0.95)[0]






.. raw:: html

    <p>[7.40369e+08, 7.55986e+08]<br>
    [2.27903e+09, 3.33441e+09]<br>
    [-517.284, 538.203]</p>
    <br />
    <br />

We can see that the `Gamma` parameter has a large confidence interval : even the sign of the parameter is unknown.
The parameter which is calibrated with the smallest confidence
interval is `R`, which confidence interval is [708.3,780.0] (MPa).
This is why this parameter seems the most important in this case.


.. code-block:: default

    graph = calibrationResult.drawObservationsVsInputs()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_003.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a good fit after calibration, since the predictions after calibration (i.e. the green crosses) are close to the observations (i.e. the blue crosses).


.. code-block:: default

    graph = calibrationResult.drawObservationsVsPredictions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_004.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a much better fit after calibration, since the predictions are close to the diagonal of the graphics.


.. code-block:: default

    observationError = calibrationResult.getObservationsError()
    observationError






.. raw:: html

    <p>Normal(mu = 0, sigma = 1.1025e+07)</p>
    <br />
    <br />


.. code-block:: default

    graph = calibrationResult.drawResiduals()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_005.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





The analysis of the residuals shows that the distribution is centered on zero and symmetric. This indicates that the calibration performed well.

Moreover, the distribution of the residuals is close to being gaussian.


.. code-block:: default

    graph = calibrationResult.drawParameterDistributions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_006.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





Calibration with nonlinear least squares
----------------------------------------

The `NonLinearLeastSquaresCalibration` class performs the non linear least squares calibration by minimizing the squared euclidian norm between the predictions and the observations.


.. code-block:: default

    algo = ot.NonLinearLeastSquaresCalibration(mycf, observedStrain, observedStress, thetaPrior)









The `run` method computes the solution of the problem.


.. code-block:: default

    algo.run()









.. code-block:: default

    calibrationResult = algo.getResult()








Analysis of the results
-----------------------

The `getParameterMAP` method returns the maximum of the posterior distribution of :math:`\theta`.


.. code-block:: default

    thetaMAP = calibrationResult.getParameterMAP()
    thetaMAP






.. raw:: html

    <p>[7.47522e+08,2.88854e+09,11.1915]</p>
    <br />
    <br />

We can compute a 95% confidence interval of the parameter :math:`\theta^\star`.


.. code-block:: default

    thetaPosterior = calibrationResult.getParameterPosterior()
    thetaPosterior.computeBilateralConfidenceIntervalWithMarginalProbability(0.95)[0]






.. raw:: html

    <p>[7.38602e+08, 7.58579e+08]<br>
    [2.16219e+09, 3.62933e+09]<br>
    [3.5572, 18.8279]</p>
    <br />
    <br />

We can see that all three parameters are estimated with a large confidence interval.


.. code-block:: default

    graph = calibrationResult.drawObservationsVsInputs()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_007.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a good fit after calibration, since the predictions after calibration (i.e. the green crosses) are close to the observations (i.e. the blue crosses).


.. code-block:: default

    graph = calibrationResult.drawObservationsVsPredictions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_008.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a much better fit after calibration, since the predictions are close to the diagonal of the graphics.


.. code-block:: default

    observationError = calibrationResult.getObservationsError()
    observationError






.. raw:: html

    <p>Normal(mu = 2160.56, sigma = 1.09017e+07)</p>
    <br />
    <br />


.. code-block:: default

    graph = observationError.drawPDF()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_009.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img






.. code-block:: default

    graph = calibrationResult.drawResiduals()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_010.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





The analysis of the residuals shows that the distribution is centered on zero and symmetric. This indicates that the calibration performed well.

Moreover, the distribution of the residuals is close to being gaussian. This indicates that the observation error might be gaussian.


.. code-block:: default

    graph = calibrationResult.drawParameterDistributions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_011.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





Gaussian calibration parameters
-------------------------------

The standard deviation of the observations errors.


.. code-block:: default

    sigmaStress = 1.0e7  # (Pa)








Define the covariance matrix of the output Y of the model.


.. code-block:: default

    errorCovariance = ot.CovarianceMatrix(1)
    errorCovariance[0, 0] = sigmaStress ** 2








Define the covariance matrix of the parameters :math:`\theta` to calibrate.


.. code-block:: default

    sigmaR = 0.1 * R
    sigmaC = 0.1 * C
    sigmaGamma = 0.1 * Gamma









.. code-block:: default

    sigma = ot.CovarianceMatrix(3)
    sigma[0, 0] = sigmaR ** 2
    sigma[1, 1] = sigmaC ** 2
    sigma[2, 2] = sigmaGamma ** 2
    sigma






.. raw:: html

    <p>[[ 4.9e+15  0        0        ]<br>
     [ 0        6.25e+16 0        ]<br>
     [ 0        0        0.64     ]]</p>
    <br />
    <br />

Gaussian linear calibration
---------------------------

The `GaussianLinearCalibration` class performs the gaussian linear calibration by linearizing the model in the neighbourhood of the prior.


.. code-block:: default

    algo = ot.GaussianLinearCalibration(mycf, observedStrain, observedStress, thetaPrior, sigma, errorCovariance)








The `run` method computes the solution of the problem.


.. code-block:: default

    algo.run()









.. code-block:: default

    calibrationResult = algo.getResult()








Analysis of the results
-----------------------

The `getParameterMAP` method returns the maximum of the posterior distribution of :math:`\theta`.


.. code-block:: default

    thetaMAP = calibrationResult.getParameterMAP()
    thetaMAP






.. raw:: html

    <p>[7.5035e+08,2.60977e+09,8.17958]</p>
    <br />
    <br />

We can compute a 95% confidence interval of the parameter :math:`\theta^\star`.


.. code-block:: default

    thetaPosterior = calibrationResult.getParameterPosterior()
    thetaPosterior.computeBilateralConfidenceIntervalWithMarginalProbability(0.95)[0]






.. raw:: html

    <p>[7.45134e+08, 7.55566e+08]<br>
    [2.41407e+09, 2.80548e+09]<br>
    [6.48461, 9.87455]</p>
    <br />
    <br />

We can see that all three parameters are estimated with a large confidence interval.


.. code-block:: default

    graph = calibrationResult.drawObservationsVsInputs()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_012.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a good fit after calibration, since the predictions after calibration (i.e. the green crosses) are close to the observations (i.e. the blue crosses).


.. code-block:: default

    graph = calibrationResult.drawObservationsVsPredictions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_013.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a much better fit after calibration, since the predictions are close to the diagonal of the graphics.

The observation error is predicted by linearizing the problem at the prior.


.. code-block:: default

    observationError = calibrationResult.getObservationsError()
    observationError






.. raw:: html

    <p>Normal(mu = 0, sigma = 1e+07)</p>
    <br />
    <br />

This can be compared to the residuals distribution, which is computed at the posterior.


.. code-block:: default

    graph = calibrationResult.drawResiduals()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_014.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





The analysis of the gaussian distribution (the blue line) of the observation errors is close to the posterior distribution of the residuals (the green line). Moreover, the posterior distribution is centered. These informations indicate that the calibration performed well.


.. code-block:: default

    graph = calibrationResult.drawParameterDistributions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_015.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





For the :math:`R` variable, the observations are much more important than the prior: this is shown by the fact that the posterior and prior distribution of the :math:`R` variable are very different.

We see that the prior and posterior distribution are close to each other for the :math:`\gamma` variable: the observations did not convey much information for this variable.

Gaussian nonlinear calibration
------------------------------

The `GaussianNonLinearCalibration` class performs the gaussian nonlinear calibration.


.. code-block:: default

    algo = ot.GaussianNonLinearCalibration(mycf, observedStrain, observedStress, thetaPrior, sigma, errorCovariance)








The `run` method computes the solution of the problem.


.. code-block:: default

    algo.run()









.. code-block:: default

    calibrationResult = algo.getResult()








Analysis of the results
-----------------------

The `getParameterMAP` method returns the maximum of the posterior distribution of :math:`\theta`.


.. code-block:: default

    thetaMAP = calibrationResult.getParameterMAP()
    thetaMAP






.. raw:: html

    <p>[7.50466e+08,2.61003e+09,8.19629]</p>
    <br />
    <br />

We can compute a 95% confidence interval of the parameter :math:`\theta^\star`.


.. code-block:: default

    thetaPosterior = calibrationResult.getParameterPosterior()
    thetaPosterior.computeBilateralConfidenceIntervalWithMarginalProbability(0.95)[0]






.. raw:: html

    <p>[7.44651e+08, 7.54581e+08]<br>
    [2.47164e+09, 2.85086e+09]<br>
    [6.9034, 10.3133]</p>
    <br />
    <br />

We can see that all three parameters are estimated with a large confidence interval.


.. code-block:: default

    graph = calibrationResult.drawObservationsVsInputs()
    graph.setLegendPosition("topleft")
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_016.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a good fit after calibration, since the predictions after calibration (i.e. the green crosses) are close to the observations (i.e. the blue crosses).


.. code-block:: default

    graph = calibrationResult.drawObservationsVsPredictions()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_017.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that there is a much better fit after calibration, since the predictions are close to the diagonal of the graphics.

The observation error is predicted by bootstraping the problem at the posterior.


.. code-block:: default

    observationError = calibrationResult.getObservationsError()
    observationError






.. raw:: html

    <p>Normal(mu = -7013.81, sigma = 1e+07)</p>
    <br />
    <br />

This can be compared to the residuals distribution, which is computed at the posterior.


.. code-block:: default

    graph = calibrationResult.drawResiduals()
    view = viewer.View(graph)




.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_018.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





The analysis is very similar to the linear calibration.


.. code-block:: default

    graph = calibrationResult.drawParameterDistributions()
    view = viewer.View(graph)

    plt.show()



.. image:: /auto_calibration/least_squares_and_gaussian_calibration/images/sphx_glr_plot_calibration_chaboche_019.png
    :alt: plot calibration chaboche
    :class: sphx-glr-single-img





We see that the prior and posterior distribution for the :math:`\gamma` parameter are close to each other, but not superimposed: the observations significantly brought information to the variable :math:`\gamma` during the calibration.


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  6.636 seconds)


.. _sphx_glr_download_auto_calibration_least_squares_and_gaussian_calibration_plot_calibration_chaboche.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_calibration_chaboche.py <plot_calibration_chaboche.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_calibration_chaboche.ipynb <plot_calibration_chaboche.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
