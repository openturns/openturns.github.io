.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_auto_reliability_sensitivity_reliability_plot_post_analytical_importance_sampling.py>`     to download the full example code
    .. rst-class:: sphx-glr-example-title

    .. _sphx_glr_auto_reliability_sensitivity_reliability_plot_post_analytical_importance_sampling.py:


Post analytical importance sampling
===================================

In this example we want to estimate a threshold exceedance probability by combining approximation and simulation methods.

  - perform an FORM or SORM study in order to find the design point,

  - perform an importance sampling study centered around the design point: the importance distribution operates in the standard space and is the standard distribution of the standard space (the standard elliptical distribution in the case of an elliptic copula of the input random vector, the standard normal one in all the other cases).

The importance sampling technique in the standard space may be of two kinds:

  - the sample is generated according to the new importance distribution: this technique is called post analytical importance sampling,

  - the sample is generated according to the new importance distribution and is controlled by the value of the linearized limit state function: this technique is called post analytical controlled importance sampling.

This post analytical importance sampling algorithm is created from the result structure of a FORM or SORM algorithm.

It is parameterized like other simulation algorithm, through the parameters OuterSampling, BlockSize, ... and provide the same type of results.

Let us note that the post FORM/SORM importance sampling method may be implemented thanks to the ImportanceSampling object, where the importance distribution is defined in the standard space: then, it requires that the event initially defined in the pysical space be transformed in the standard space.

The controlled importance sampling technique is only accessible within the post analytical context.


.. code-block:: default

    from __future__ import print_function
    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    import math as m
    ot.Log.Show(ot.Log.NONE)








Create a model


.. code-block:: default

    model = ot.SymbolicFunction(['x1', 'x2'], ['x1^2+x2'])
    R = ot.CorrelationMatrix(2)
    R[0,1] = -0.6
    inputDist = ot.Normal([0.,0.], R)
    inputDist.setDescription(['X1', 'X2'])
    inputVector = ot.RandomVector(inputDist)

    # Create the output random vector Y=model(X)
    Y = ot.CompositeRandomVector(model, inputVector)

    # Create the event Y > 4
    threshold = 4.0
    event = ot.ThresholdEvent(Y, ot.Greater(), threshold)








Create a FORM algorithm


.. code-block:: default

    solver = ot.Cobyla()
    startingPoint = inputDist.getMean()
    algo = ot.FORM(solver, event, startingPoint)

    # Run the algorithm and retrieve the result
    algo.run()
    result_form = algo.getResult()








Create the post analytical importance sampling simulation algorithm


.. code-block:: default

    algo = ot.PostAnalyticalImportanceSampling(result_form)
    algo.run()
    algo.getResult()






.. raw:: html

    <p>probabilityEstimate=4.411967e-02 varianceEstimate=1.929276e-05 standard deviation=4.39e-03 coefficient of variation=9.96e-02 confidenceLength(0.95)=1.72e-02 outerSampling=200 blockSize=1</p>
    <br />
    <br />

Create the post analytical controlled importance sampling simulation algorithm


.. code-block:: default

    algo = ot.PostAnalyticalControlledImportanceSampling(result_form)
    algo.run()
    algo.getResult()





.. raw:: html

    <p>probabilityEstimate=4.565267e-02 varianceEstimate=0.000000e+00 standard deviation=0.00e+00 coefficient of variation=0.00e+00 confidenceLength(0.95)=0.00e+00 outerSampling=2 blockSize=1</p>
    <br />
    <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.006 seconds)


.. _sphx_glr_download_auto_reliability_sensitivity_reliability_plot_post_analytical_importance_sampling.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: plot_post_analytical_importance_sampling.py <plot_post_analytical_importance_sampling.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: plot_post_analytical_importance_sampling.ipynb <plot_post_analytical_importance_sampling.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
