
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>An illustrated example of a FORM probability estimate &#8212; OpenTURNS 1.18rc1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/openturns.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/mysearchtools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Create an event based on a process" href="../reliability_processes/plot_event_process.html" />
    <link rel="prev" title="Create unions or intersections of events" href="plot_event_system.html" />
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
 

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="http://www.openturns.org/">Home</a></li>
    <li><a href="../../install.html">Get it</a></li>
    <li><a href="../../contents.html">Doc</a></li>
    <li><a href="https://openturns.discourse.group/">Forum</a></li>
    <li><a href="https://gitter.im/openturns/community">Chat</a></li>
    <li><a href="https://github.com/openturns/openturns/wiki/Modules">Modules</a></li>
    <li><a href="https://github.com/openturns">Code</a></li>
    <li><a href="https://github.com/openturns/openturns/issues">Bugs</a></li>
  </ul>
  <a href="../../index.html">
    <h1>
      <img src="../../_static/logo-openturns-wo-bg.png" alt="" width=100px height=100px />
      OpenTURNS
    </h1>
    <h2> An Open source initiative for the Treatment of Uncertainties, Risks'N Statistics</h2>
  </a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../reliability_processes/plot_event_process.html" title="Create an event based on a process"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="plot_event_system.html" title="Create unions or intersections of events"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">OpenTURNS 1.18rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../contents.html" >Contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../examples/examples.html" >Examples</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" accesskey="U">Reliability &amp; Sensitivity</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">An illustrated example of a FORM probability estimate</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">An illustrated example of a FORM probability estimate</a><ul>
<li><a class="reference internal" href="#abstract">Abstract</a></li>
<li><a class="reference internal" href="#position-of-the-problem">Position of the problem</a></li>
<li><a class="reference internal" href="#the-form-approximation">The FORM approximation</a><ul>
<li><a class="reference internal" href="#variable-transform">Variable transform</a></li>
<li><a class="reference internal" href="#the-design-point">The design point</a></li>
<li><a class="reference internal" href="#estimating-the-failure-probability-integral">Estimating the failure probability integral</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-sorm-approximation">The SORM approximation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="plot_event_system.html"
                        title="previous chapter">Create unions or intersections of events</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../reliability_processes/plot_event_process.html"
                        title="next chapter">Create an event based on a process</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/auto_reliability_sensitivity/reliability/plot_form_explained.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-auto-reliability-sensitivity-reliability-plot-form-explained-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<section class="sphx-glr-example-title" id="an-illustrated-example-of-a-form-probability-estimate">
<span id="sphx-glr-auto-reliability-sensitivity-reliability-plot-form-explained-py"></span><h1>An illustrated example of a FORM probability estimate<a class="headerlink" href="#an-illustrated-example-of-a-form-probability-estimate" title="Permalink to this headline">¶</a></h1>
<section id="abstract">
<h2>Abstract<a class="headerlink" href="#abstract" title="Permalink to this headline">¶</a></h2>
<p>In this example we illustrate the different steps of a FORM/SORM analysis on a
simple example. We focus on the different steps and compare them with an analytic
computation whenever possible.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openturns</span> <span class="k">as</span> <span class="nn">ot</span>
<span class="kn">import</span> <span class="nn">openturns.viewer</span> <span class="k">as</span> <span class="nn">otv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pylab</span> <span class="k">as</span> <span class="n">plt</span>
</pre></div>
</div>
</section>
<section id="position-of-the-problem">
<h2>Position of the problem<a class="headerlink" href="#position-of-the-problem" title="Permalink to this headline">¶</a></h2>
<p>We consider a bivariate random vector <img class="math" src="../../_images/math/ad1953c010d17b112e729112f97991fa7b17f0b1.svg" alt="X = (X_1, X_2)"/> with the following independent marginals :</p>
<ul class="simple">
<li><p>an exponential distribution with parameter <img class="math" src="../../_images/math/7c92acda0d527f60f71bd88bbe8bb469bf7d89b8.svg" alt="\lambda=1"/>, <img class="math" src="../../_images/math/19044c9e41a5bd3329ff159edee0d5a459e6214f.svg" alt="X_1 \sim \mathcal{E}(1.0)"/> ;</p></li>
<li><p>a standard unit gaussian <img class="math" src="../../_images/math/82ac9ab225ebd0ebfa7867c1f160c3774fba3aa8.svg" alt="X_2 \sim \mathcal{N}(0,1)"/>.</p></li>
</ul>
<p>The support of the input vector is <img class="math" src="../../_images/math/2919cc4f0f9ac2780d7ead6f5d5b2e6ef2a9ccf0.svg" alt="[0, +\infty[ \times \mathbb{R}"/></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">distX1</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Exponential</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">distX2</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">()</span>
<span class="n">distX</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">ComposedDistribution</span><span class="p">([</span><span class="n">distX1</span><span class="p">,</span> <span class="n">distX2</span><span class="p">])</span>
</pre></div>
</div>
<p>We can draw the bidimensional PDF of the distribution <cite>distX</cite> over <img class="math" src="../../_images/math/b6a73c8253a2f119138fbebb5702335c8fe3728c.svg" alt="[0,-10] \times [10,10]"/> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ot</span><span class="o">.</span><span class="n">ResourceMap_SetAsUnsignedInteger</span><span class="p">(</span><span class="s2">&quot;Contour-DefaultLevelsNumber&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">graphPDF</span> <span class="o">=</span> <span class="n">distX</span><span class="o">.</span><span class="n">drawPDF</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="n">graphPDF</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;2D-PDF of the input variables $(X_1, X_2)$&#39;</span><span class="p">)</span>
<span class="n">graphPDF</span><span class="o">.</span><span class="n">setXTitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">)</span>
<span class="n">graphPDF</span><span class="o">.</span><span class="n">setYTitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">)</span>
<span class="n">graphPDF</span><span class="o">.</span><span class="n">setLegendPosition</span><span class="p">(</span><span class="s2">&quot;bottomright&quot;</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphPDF</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_001.png" srcset="../../_images/sphx_glr_plot_form_explained_001.png" alt="2D-PDF of the input variables $(X_1, X_2)$" class = "sphx-glr-single-img"/><p>We consider the model <img class="math" src="../../_images/math/bf8d4953e2b131a5f1f8a26b3ce4619d4f3152a6.svg" alt="f : (x_1, x_2) \mapsto x_1 x_2"/> which maps the random input vector <img class="math" src="../../_images/math/ea775056706c0642a79ca7b47cbc53cd1a63fc8d.svg" alt="X"/> to the output variable <img class="math" src="../../_images/math/01fecf7d86a80b5cb3e5e19b9db686f5fb427ec7.svg" alt="Y=f(X) \in \mathbb{R}"/>. We also draw the isolines of the model <cite>f</cite>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">SymbolicFunction</span><span class="p">([</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="s1">&#39;x2&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;x1 * x2&#39;</span><span class="p">])</span>
<span class="n">graphModel</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">draw</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="n">graphModel</span><span class="o">.</span><span class="n">setXTitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_1$&#39;</span><span class="p">)</span>
<span class="n">graphModel</span><span class="o">.</span><span class="n">setXTitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$x_2$&#39;</span><span class="p">)</span>
<span class="n">graphModel</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Isolines of the model : $Y = f(X)$&#39;</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphModel</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_002.png" srcset="../../_images/sphx_glr_plot_form_explained_002.png" alt="Isolines of the model : $Y = f(X)$" class = "sphx-glr-single-img"/><p>We want to estimate the probability <img class="math" src="../../_images/math/ed5fd9cb0e37b8e99156d14f92ce0f73fede7c28.svg" alt="P_f"/> of the output variable to be greater than a prescribed threshold <img class="math" src="../../_images/math/b976aadbf137850c9cc5f70bc2c2398102299a6c.svg" alt="s=10"/> : this is the failure event. This probability is simply expressed as an integral :</p>
<div class="math">
<p><img src="../../_images/math/05e24a80b8090372fad2815aa4740f721de6215f.svg" alt="P_f = \int_{\mathcal{D}} \mathbf{1}_{\mathcal{D}}(x) df_{X_1,X_2}(x)"/></p>
</div><p>where <img class="math" src="../../_images/math/7d481c13e1f5d1986af3fe360035ad5bbe014def.svg" alt="\mathcal{D} = \{ (x_1, x_2) \in [0,+\infty[ \times \mathbb{R} / x_1 x_2 \geq s \}"/> is the failure domain.
In the general case the probability density function <img class="math" src="../../_images/math/4ae043539ed91e37e0738977f70730614e9a3bac.svg" alt="f_{X_1,X_2}"/> and the domain of integration <img class="math" src="../../_images/math/f4c5797d9ee891ff1d753ce555c6627f0941656a.svg" alt="\mathcal{D}"/> are difficult to handle.</p>
<p>We first define RandomVector objects and the failure event associated to the ouput random variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vectorX</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">RandomVector</span><span class="p">(</span><span class="n">distX</span><span class="p">)</span>
<span class="n">vectorY</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">CompositeRandomVector</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">vectorX</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="n">event</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">ThresholdEvent</span><span class="p">(</span><span class="n">vectorY</span><span class="p">,</span> <span class="n">ot</span><span class="o">.</span><span class="n">Greater</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>This event can easily be represented with a 1D curve as it is a branch of an hyperbole.
If <img class="math" src="../../_images/math/a8d6702fece5b8f0669d5c121d32415dacaa481b.svg" alt="y =  x_1 x_2 = 10.0"/>, then the boundary of the domain of failure is the curve :</p>
<div class="math">
<p><img src="../../_images/math/f86a7243d5e5f50064e941073de3bf8bcf037857.svg" alt="h : x_1 \mapsto \frac{10.0}{x_1}"/></p>
</div><p>We shall represent this curve using a <a class="reference internal" href="../../user_manual/_generated/openturns.Contour.html#openturns.Contour" title="openturns.Contour"><code class="xref py py-class docutils literal notranslate"><span class="pre">Contour</span></code></a> object.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span>
<span class="n">xx</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Box</span><span class="p">([</span><span class="n">nx</span><span class="p">],</span> <span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">]))</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
<span class="n">yy</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Box</span><span class="p">([</span><span class="n">ny</span><span class="p">],</span> <span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">([</span><span class="o">-</span><span class="mf">10.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">]))</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
<span class="n">inputData</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Box</span><span class="p">([</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">],</span> <span class="n">ot</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span>
    <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]))</span><span class="o">.</span><span class="n">generate</span><span class="p">()</span>
<span class="n">outputData</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">inputData</span><span class="p">)</span>
<span class="n">mycontour</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Contour</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">outputData</span><span class="p">,</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;10.0&quot;</span><span class="p">])</span>
<span class="n">myGraph</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="s2">&quot;Representation of the failure domain&quot;</span><span class="p">,</span>
                   <span class="sa">r</span><span class="s2">&quot;$X_1$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$X_2$&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">myGraph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mycontour</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">texts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot; Event : $\mathcal</span><span class="si">{D}</span><span class="s2"> = \{Y \geq 10.0\}$&quot;</span><span class="p">]</span>
<span class="n">myText</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Text</span><span class="p">([[</span><span class="mf">4.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span> <span class="n">texts</span><span class="p">)</span>
<span class="n">myText</span><span class="o">.</span><span class="n">setTextSize</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">myGraph</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">myText</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">myGraph</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_003.png" srcset="../../_images/sphx_glr_plot_form_explained_003.png" alt="Representation of the failure domain" class = "sphx-glr-single-img"/><p>We can superimpose the event boundary with the 2D-PDF ot the input variables :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mycontour</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">mycontour</span><span class="o">.</span><span class="n">setLabels</span><span class="p">([</span><span class="s2">&quot;event&quot;</span><span class="p">])</span>
<span class="n">graphPDF</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mycontour</span><span class="p">)</span>
<span class="n">graphPDF</span><span class="o">.</span><span class="n">setLegendPosition</span><span class="p">(</span><span class="s2">&quot;bottomright&quot;</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphPDF</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_004.png" srcset="../../_images/sphx_glr_plot_form_explained_004.png" alt="2D-PDF of the input variables $(X_1, X_2)$" class = "sphx-glr-single-img"/><p>From the previous figure we observe that in the failure domain the PDF takes small (and even very small) values. Consequently the probability of the failure, the integral <img class="math" src="../../_images/math/ed5fd9cb0e37b8e99156d14f92ce0f73fede7c28.svg" alt="P_f"/> is also expected to be small. The FORM/SORM methods estimate this kind of integral.</p>
</section>
<section id="the-form-approximation">
<h2>The FORM approximation<a class="headerlink" href="#the-form-approximation" title="Permalink to this headline">¶</a></h2>
<p>The basic steps of the FORM (or SORM) algorithm are :</p>
<ul class="simple">
<li><p>an isoprobabilistic transform ;</p></li>
<li><p>finding the design point : that is the nearest point wrt the origin in the standard space ;</p></li>
<li><p>estimating the probability integral.</p></li>
</ul>
<p>As mentionned, both the density function and the domain of integration are complex in general.
The first step of the FORM method makes the density easier to work with and the second step tackles
the domain of integration problem.</p>
<section id="variable-transform">
<h3>Variable transform<a class="headerlink" href="#variable-transform" title="Permalink to this headline">¶</a></h3>
<p>OpenTURNS has several isoprobabilistic transforms and the FORM/SORM classes implement the Generalized
Nataf and Rosenblatt transforms. In this case the <cite>distX</cite> distribution is not elliptical so the default method is the Rosenblatt transform.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is Elliptical ? &quot;</span><span class="p">,</span> <span class="n">distX</span><span class="o">.</span><span class="n">isElliptical</span><span class="p">())</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Is Elliptical ?  False
</pre></div>
</div>
<p>We seek an isoprobabilistic transform <img class="math" src="../../_images/math/893b95408f6feaa3c0bf7b3d915e498bce7feb0c.svg" alt="T"/> such as</p>
<div class="math">
<p><img src="../../_images/math/f1c1a448e8a9cdb45f84a3aa4bcd4b4b6054a92d.svg" alt="T : X \mapsto Z"/></p>
</div><p>where each component of <img class="math" src="../../_images/math/cc91179189738c9223d552e868c802f621878744.svg" alt="Z"/> is a standard unit gaussian.</p>
<p>The isoprobabilistic transform and its inverse are methods of the distribution <cite>distX</cite> :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">transformation</span> <span class="o">=</span> <span class="n">distX</span><span class="o">.</span><span class="n">getIsoProbabilisticTransformation</span><span class="p">()</span>
<span class="n">inverseTransformation</span> <span class="o">=</span> <span class="n">distX</span><span class="o">.</span><span class="n">getInverseIsoProbabilisticTransformation</span><span class="p">()</span>
</pre></div>
</div>
<p>The main goal of this step is to work with a simpler probability density function of
the input variables as they will be standard gaussian unit and uncorrelated. The domain of
integration will still be complicated but will be handled with a well chosen approximate.</p>
<p>We detail the Rosenblatt transform in this simple case.
In this example we consider independent variables so the transform is simpler, we only have to
perform the transformation on each variable. For the second one is already a standard unit gaussian
we transform the first variable only.</p>
<p>We draw a realization of the random input vector. This point is said to be in the physical space.
We shall focus on the first component.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xi</span> <span class="o">=</span> <span class="n">vectorX</span><span class="o">.</span><span class="n">getRealization</span><span class="p">()</span>
</pre></div>
</div>
<p>The first step of the Rosenblatt transform is to build a random variable <img class="math" src="../../_images/math/d72213c27ee9fd471f33aeff30351d91d9d623b4.svg" alt="u"/> with a uniform law in ]0,1[.
This is done through an evaluation of the CDF of <cite>distX1</cite> at the given point in the physical space.
Once again, please note that the second component is left unchanged.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ui</span> <span class="o">=</span> <span class="p">[</span><span class="n">distX1</span><span class="o">.</span><span class="n">computeCDF</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The second step is to build a standard unit gaussian from a uniform variable. This is done by a
simple call to the probit function. The point <cite>zi</cite> is said to be in the standard space.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zi</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">()</span><span class="o">.</span><span class="n">computeInverseSurvivalFunction</span><span class="p">(</span><span class="n">ui</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ui</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The sought transform then maps a point in the physical space to the standard space :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>[0.291882,-0.55673] -&gt; [0.25314355280016465, -0.5567298885851408] -&gt; [-0.6646301103295218, -0.5567298885851408]
</pre></div>
</div>
<p>We also build the isoprobabilistic transform <img class="math" src="../../_images/math/9fa5f4454e5c6b60c1db53e35291b150b9d615b8.svg" alt="T_1"/> and its inverse <img class="math" src="../../_images/math/c79cfd2c9fe88c6baca67f2f61a7a75eee18dbc1.svg" alt="T_1^{-1}"/> for the
first marginal :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">transformX1</span> <span class="o">=</span> <span class="n">distX1</span><span class="o">.</span><span class="n">getIsoProbabilisticTransformation</span><span class="p">()</span>
<span class="n">inverseTransformX1</span> <span class="o">=</span> <span class="n">distX1</span><span class="o">.</span><span class="n">getInverseIsoProbabilisticTransformation</span><span class="p">()</span>
</pre></div>
</div>
<p>We can check the result of our experiment against :</p>
<ul class="simple">
<li><p>the 2D-transform <img class="math" src="../../_images/math/893b95408f6feaa3c0bf7b3d915e498bce7feb0c.svg" alt="T"/> ;</p></li>
<li><p>the 1D-transform <img class="math" src="../../_images/math/9fa5f4454e5c6b60c1db53e35291b150b9d615b8.svg" alt="T_1"/> and the second component unchanged ;</p></li>
</ul>
<p>and observe the results are the same.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zi1D</span> <span class="o">=</span> <span class="p">[</span><span class="n">transformX1</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">zi2D</span> <span class="o">=</span> <span class="n">transformation</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zi = &quot;</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zi1D = &quot;</span><span class="p">,</span> <span class="n">zi1D</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;zi2D = &quot;</span><span class="p">,</span> <span class="n">zi2D</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>zi =  [-0.6646301103295218, -0.5567298885851408]
zi1D =  [-0.6646301103295218, -0.5567298885851408]
zi2D =  [-0.66463,-0.55673]
</pre></div>
</div>
<p>We can represent the boundary of the event in the standard space : that is a composition of the
hyperbole <img class="math" src="../../_images/math/1da31641527f7da86f154337cd13c271e13b5299.svg" alt="h : x \mapsto 10/x"/> and the inverse transform <img class="math" src="../../_images/math/c79cfd2c9fe88c6baca67f2f61a7a75eee18dbc1.svg" alt="T_1^{-1}"/> defined by
<img class="math" src="../../_images/math/e477b92f2c5118b93824d1c5d89603338a3664d8.svg" alt="inverseTransformX1"/>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">failureBoundaryPhysicalSpace</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">SymbolicFunction</span><span class="p">([</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;10.0 / x&#39;</span><span class="p">])</span>
<span class="n">failureBoundaryStandardSpace</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">ComposedFunction</span><span class="p">(</span>
    <span class="n">failureBoundaryPhysicalSpace</span><span class="p">,</span> <span class="n">inverseTransformX1</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">failureBoundaryStandardSpace</span><span class="p">([</span><span class="n">xi</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>

<span class="n">graphStandardSpace</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span>
    <span class="s1">&#39;Failure event in the standard space&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$u_1$&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$u_2$&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">curveCX</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="s1">&#39;Boundary of the event $\partial \mathcal</span><span class="si">{D}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">curveCX</span><span class="o">.</span><span class="n">setLineStyle</span><span class="p">(</span><span class="s2">&quot;solid&quot;</span><span class="p">)</span>
<span class="n">curveCX</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;blue&quot;</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curveCX</span><span class="p">)</span>
</pre></div>
</div>
<p>We add the origin to the previous graph.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cloud</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">([</span><span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">])</span>
<span class="n">cloud</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">cloud</span><span class="o">.</span><span class="n">setPointStyle</span><span class="p">(</span><span class="s2">&quot;fcircle&quot;</span><span class="p">)</span>
<span class="n">cloud</span><span class="o">.</span><span class="n">setLegend</span><span class="p">(</span><span class="s2">&quot;origin&quot;</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cloud</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">setLegendPosition</span><span class="p">(</span><span class="s2">&quot;bottomright&quot;</span><span class="p">)</span>

<span class="c1"># Some annotation</span>
<span class="n">texts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;Event : $\mathcal</span><span class="si">{D}</span><span class="s2"> = \{Y \geq 10.0\}$&quot;</span><span class="p">]</span>
<span class="n">myText</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Text</span><span class="p">([[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">]],</span> <span class="n">texts</span><span class="p">)</span>
<span class="n">myText</span><span class="o">.</span><span class="n">setTextSize</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">myText</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphStandardSpace</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_005.png" srcset="../../_images/sphx_glr_plot_form_explained_005.png" alt="Failure event in the standard space" class = "sphx-glr-single-img"/></section>
<section id="the-design-point">
<h3>The design point<a class="headerlink" href="#the-design-point" title="Permalink to this headline">¶</a></h3>
<p>The FORM and SORM methods assume that the failure probability integral has its support in
the vicinity of the closest point of the domain to the origin.
Then the second step of the method is to find this point, <em>the design point</em>, through a
minimization problem under constraints.</p>
<p>We configure the Cobyla solver that we use for the optimization :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">solver</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cobyla</span><span class="p">()</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setMaximumIterationNumber</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setMaximumAbsoluteError</span><span class="p">(</span><span class="mf">1.0e-3</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setMaximumRelativeError</span><span class="p">(</span><span class="mf">1.0e-3</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setMaximumResidualError</span><span class="p">(</span><span class="mf">1.0e-3</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setMaximumConstraintError</span><span class="p">(</span><span class="mf">1.0e-3</span><span class="p">)</span>
</pre></div>
</div>
<p>We build the FORM algorithm with its basic constructor. The starting point for the optimization
algorithm is the mean of the input variables.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">algoFORM</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">FORM</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">distX</span><span class="o">.</span><span class="n">getMean</span><span class="p">())</span>
</pre></div>
</div>
<p>We are ready to run the algorithm and store the result :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">algoFORM</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">algoFORM</span><span class="o">.</span><span class="n">getResult</span><span class="p">()</span>
</pre></div>
</div>
<p>The design point can be retrieved in both physical and standard space with respectively the
<cite>getPhysicalSpaceDesignPoint</cite> and <cite>getStandardSpaceDesignPoint</cite> methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">designPointPhysicalSpace</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getPhysicalSpaceDesignPoint</span><span class="p">()</span>
<span class="n">designPointStandardSpace</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getStandardSpaceDesignPoint</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Design point in physical space : &quot;</span><span class="p">,</span> <span class="n">designPointPhysicalSpace</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Design point in standard space : &quot;</span><span class="p">,</span> <span class="n">designPointStandardSpace</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Design point in physical space :  [4.84183,2.06513]
Design point in standard space :  [2.41384,2.06513]
</pre></div>
</div>
<p>We can get the Hasofer index with the <cite>getHasoferReliabilityIndex</cite> method which is the distance of the design point to the origin :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">betaHL</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getHasoferReliabilityIndex</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Hasofer index : &quot;</span><span class="p">,</span> <span class="n">betaHL</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Hasofer index :  3.176696193499824
</pre></div>
</div>
<p>We visualize it on the previous graph.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cloud</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Cloud</span><span class="p">([</span><span class="n">designPointStandardSpace</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">designPointStandardSpace</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">cloud</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">cloud</span><span class="o">.</span><span class="n">setPointStyle</span><span class="p">(</span><span class="s2">&quot;fcircle&quot;</span><span class="p">)</span>
<span class="n">cloud</span><span class="o">.</span><span class="n">setLegend</span><span class="p">(</span><span class="s2">&quot;design point&quot;</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cloud</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">setGrid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">setLegendPosition</span><span class="p">(</span><span class="s2">&quot;bottomright&quot;</span><span class="p">)</span>
<span class="n">cc</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Curve</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">designPointStandardSpace</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span>
              <span class="mf">0.0</span><span class="p">,</span> <span class="n">designPointStandardSpace</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="sa">r</span><span class="s1">&#39;$\beta_</span><span class="si">{HL}</span><span class="s1">$ distance&#39;</span><span class="p">)</span>
<span class="n">cc</span><span class="o">.</span><span class="n">setLineStyle</span><span class="p">(</span><span class="s2">&quot;dashed&quot;</span><span class="p">)</span>
<span class="n">cc</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;black&quot;</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphStandardSpace</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_006.png" srcset="../../_images/sphx_glr_plot_form_explained_006.png" alt="Failure event in the standard space" class = "sphx-glr-single-img"/></section>
<section id="estimating-the-failure-probability-integral">
<h3>Estimating the failure probability integral<a class="headerlink" href="#estimating-the-failure-probability-integral" title="Permalink to this headline">¶</a></h3>
<p>The last step of the FORM algorithm is to replace the domain of integration by the half-space at
the design point. In this simple example the half-space is delimited by the tangent at the design
point in the standard space.</p>
<p>The expression of the failure domain boundary in the standard space is the composition of the
hyperbole <img class="math" src="../../_images/math/f8277b92423e75eab3dbdfb3bf9b4203d7e30a4d.svg" alt="h:x \mapsto 10/x"/> and the inverse transform on the first variable. We can compute
the gradient (here the first derivative of a 1D function <img class="math" src="../../_images/math/a28e552aedee8515d019a96d69ee579017030c74.svg" alt="h(u_0)"/> ) at any given point with the
getGradient method :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u0</span> <span class="o">=</span> <span class="p">[</span><span class="n">designPointStandardSpace</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">du0</span> <span class="o">=</span> <span class="n">failureBoundaryStandardSpace</span><span class="o">.</span><span class="n">getGradient</span><span class="p">()</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;abscissa of the design point u0  = &quot;</span><span class="p">,</span> <span class="n">u0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value of the failure boundary at u0 = &quot;</span><span class="p">,</span>
      <span class="n">failureBoundaryStandardSpace</span><span class="p">(</span><span class="n">u0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value of the gradient of the failure boundary at u0 = &quot;</span><span class="p">,</span> <span class="n">du0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>abscissa of the design point u0  =  2.4138442539794656
value of the failure boundary at u0 =  2.065335164461817
value of the gradient of the failure boundary at u0 =  -1.1706609709100166
</pre></div>
</div>
<p>In the standard space the equation of the tangent <img class="math" src="../../_images/math/fddf33571040693bddfece67b5f341cd5e4278c4.svg" alt="\Pi_{u_0}(x)"/> is given by</p>
<div class="math">
<p><img src="../../_images/math/631ea73340d9f98c06d2a249a24d21b82161ae9b.svg" alt="\Pi_{u_0}(x) = (h \circ T^{-1}) (u_0) + \frac{d}{dx} (h \circ T^{-1}) (u_0) (x-u_0)"/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">hyperplane</span> <span class="o">=</span> <span class="n">failureBoundaryStandardSpace</span><span class="p">(</span><span class="n">u0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">du0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">u0</span><span class="p">)</span>
<span class="n">curveHyperplane</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">hyperplane</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\Pi_</span><span class="si">{u_0}</span><span class="s1">$ (FORM)&#39;</span><span class="p">)</span>
<span class="n">curveHyperplane</span><span class="o">.</span><span class="n">setLineStyle</span><span class="p">(</span><span class="s2">&quot;dashed&quot;</span><span class="p">)</span>
<span class="n">curveHyperplane</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curveHyperplane</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphStandardSpace</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_007.png" srcset="../../_images/sphx_glr_plot_form_explained_007.png" alt="Failure event in the standard space" class = "sphx-glr-single-img"/><p>In the standard space the PDF of the input variables is rotationally invariant so</p>
<div class="math">
<p><img src="../../_images/math/27c7dcbb8677ae82cc62c7a3d85016caf0fd48aa.svg" alt="P_f \approx E(\beta_{HL}),"/></p>
</div><p>where <img class="math" src="../../_images/math/ae516dd94482267c058710b1c54183c19b9a02c8.svg" alt="E(.)"/> is the survival function of the standard unit gaussian.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pf</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">()</span><span class="o">.</span><span class="n">computeSurvivalFunction</span><span class="p">(</span><span class="n">betaHL</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;FORM : Pf = &quot;</span><span class="p">,</span> <span class="n">pf</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>FORM : Pf =  0.0007448149708283453
</pre></div>
</div>
<p>This proability of failure is the one computed in the FORMResult and obtained with the <cite>getEventProbability</cite> method :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pf</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">getEventProbability</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Probability of failure (FORM) Pf = &quot;</span><span class="p">,</span> <span class="n">pf</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Probability of failure (FORM) Pf =  0.0007448149708283453
</pre></div>
</div>
</section>
</section>
<section id="the-sorm-approximation">
<h2>The SORM approximation<a class="headerlink" href="#the-sorm-approximation" title="Permalink to this headline">¶</a></h2>
<p>The SORM approximate uses an osculating paraboloid instead of the half-space delimited by the
tangent at the design point. In this case it is a simple parabola we can obtain through Taylor expansion at the design point.
However, in the general case one has to manipulate the gradient and the hessian in the
standard space which is cumbersome.</p>
<p>We need the value of the second derivative of the failure boundary function at the design point in
the standard space :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u0</span> <span class="o">=</span> <span class="p">[</span><span class="n">designPointStandardSpace</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">d2u0</span> <span class="o">=</span> <span class="n">failureBoundaryStandardSpace</span><span class="o">.</span><span class="n">getHessian</span><span class="p">()</span><span class="o">.</span><span class="n">hessian</span><span class="p">(</span><span class="n">u0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;abscissa of the design point u0  = &quot;</span><span class="p">,</span> <span class="n">u0</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;value of the hessian of the failure boundary at u0 = &quot;</span><span class="p">,</span> <span class="n">d2u0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>abscissa of the design point u0  =  2.4138442539794656
value of the hessian of the failure boundary at u0 =  0.9401058369642105
</pre></div>
</div>
<p>In the standard space the equation of the osculating parabola <img class="math" src="../../_images/math/948a1a630d7319bfd4736268b6c0783f84c3ad56.svg" alt="\mathcal{P}_{u_0}(x)"/> at <img class="math" src="../../_images/math/ccc06a43ce875e7f07be0d6be536bc4a0bbc8ff5.svg" alt="u_0"/> is given by</p>
<div class="math">
<p><img src="../../_images/math/0e24b1ecf6596b530ddd1e7a4d48061a39b3a44c.svg" alt="\mathcal{P}_{u_0}(x) = h \circ T^{-1} (u_0) + \frac{d}{dx} (h \circ T^{-1})(u_0) (x-u_0) + \frac{1}{2} \frac{d^2}{dx^2} (h \circ T^{-1})(u_0) (x-u_0)^2"/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">parabola</span> <span class="o">=</span> <span class="n">failureBoundaryStandardSpace</span><span class="p">(</span>
    <span class="n">u0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">du0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">u0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d2u0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">u0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">curveParabola</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">Curve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">parabola</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;$\mathcal</span><span class="si">{P}</span><span class="s1">_</span><span class="si">{u_0}</span><span class="s1">$ (SORM)&#39;</span><span class="p">)</span>
<span class="n">curveParabola</span><span class="o">.</span><span class="n">setLineStyle</span><span class="p">(</span><span class="s2">&quot;dashed&quot;</span><span class="p">)</span>
<span class="n">curveParabola</span><span class="o">.</span><span class="n">setColor</span><span class="p">(</span><span class="s2">&quot;orange&quot;</span><span class="p">)</span>
<span class="n">graphStandardSpace</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curveParabola</span><span class="p">)</span>
<span class="n">view</span> <span class="o">=</span> <span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="p">(</span><span class="n">graphStandardSpace</span><span class="p">)</span>
</pre></div>
</div>
<img src="../../_images/sphx_glr_plot_form_explained_008.png" srcset="../../_images/sphx_glr_plot_form_explained_008.png" alt="Failure event in the standard space" class = "sphx-glr-single-img"/><p>The next step is to estimate the principal curvatures of the osculating paraboloid.</p>
<p>For any regular function <img class="math" src="../../_images/math/658ae44ee69111e3048325f416f44d6080707928.svg" alt="g"/> the curvature <img class="math" src="../../_images/math/77f8dc354c5c7ed4e9b9eacc8031ef4d42ccf199.svg" alt="\kappa(x_0)"/> at the point <img class="math" src="../../_images/math/465ca6ac10519324f8a5d51b6e4485f9833730a6.svg" alt="x_0"/> in cartesian coordinates reads as</p>
<div class="math">
<p><img src="../../_images/math/9735d758a1290e8c614d5a818a2c72d01d206420.svg" alt="\kappa(x_0) = \frac{g''(x_0)}{(1+[g'(x_0)]^2)^{3/2}}."/></p>
</div><p>For the oscilating parabola of concern we use the gradient and hessian previously computed :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">curvature</span> <span class="o">=</span> <span class="p">(</span><span class="n">d2u0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">du0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Curvature (analytic formula) = &quot;</span><span class="p">,</span> <span class="n">curvature</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Curvature (analytic formula) =  0.2575913913885428
</pre></div>
</div>
<p>We build the SORM algorithm and run it :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">algoSORM</span> <span class="o">=</span> <span class="n">ot</span><span class="o">.</span><span class="n">SORM</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">distX</span><span class="o">.</span><span class="n">getMean</span><span class="p">())</span>
<span class="n">algoSORM</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The SORM result is obtained with the <cite>getResult</cite> method :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">resultSORM</span> <span class="o">=</span> <span class="n">algoSORM</span><span class="o">.</span><span class="n">getResult</span><span class="p">()</span>
</pre></div>
</div>
<p>The principal curvatures of the osculating paraboloid at the design point is obtained by the
<cite>getSortedCurvatures</cite> method :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Curvature (estimated) = &quot;</span><span class="p">,</span> <span class="n">resultSORM</span><span class="o">.</span><span class="n">getSortedCurvatures</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Curvature (estimated) =  0.25761034541532546
</pre></div>
</div>
<p>Once the curvature is obtained there are several ways of approximating the failure probability <img class="math" src="../../_images/math/ed5fd9cb0e37b8e99156d14f92ce0f73fede7c28.svg" alt="P_f"/>. OpenTURNS implements the Breitung, Hohenbichler and Tvedt estimates.</p>
<p>For instance, the Breitung approximation gives</p>
<div class="math">
<p><img src="../../_images/math/3260ab58da3557884868a3ef10047aa3c209e9ab.svg" alt="P_f \approx E(\beta_{HL}) \frac{1}{\sqrt{1+\beta_{HL}\kappa}}"/></p>
</div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">betaHL</span><span class="o">*</span><span class="n">curvature</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">pf</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ot</span><span class="o">.</span><span class="n">Normal</span><span class="p">()</span><span class="o">.</span><span class="n">computeCDF</span><span class="p">(</span><span class="n">betaHL</span><span class="p">))</span> <span class="o">*</span> <span class="n">coeff</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SORM : Pf = &quot;</span><span class="p">,</span> <span class="n">pf</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>SORM : Pf =  0.0005523531956150853
</pre></div>
</div>
<p>We can compare with the different estimators implemented in OpenTURNS :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pfBreitung</span> <span class="o">=</span> <span class="n">resultSORM</span><span class="o">.</span><span class="n">getEventProbabilityBreitung</span><span class="p">()</span>
<span class="n">pfHohenbichler</span> <span class="o">=</span> <span class="n">resultSORM</span><span class="o">.</span><span class="n">getEventProbabilityHohenbichler</span><span class="p">()</span>
<span class="n">pfTvedt</span> <span class="o">=</span> <span class="n">resultSORM</span><span class="o">.</span><span class="n">getEventProbabilityTvedt</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Probability of failure (SORM Breintung) Pf = &quot;</span><span class="p">,</span> <span class="n">pfBreitung</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Probability of failure (SORM Hohenbichler) Pf = &quot;</span><span class="p">,</span> <span class="n">pfHohenbichler</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Probability of failure (SORM Tvedt) Pf = &quot;</span><span class="p">,</span> <span class="n">pfTvedt</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Probability of failure (SORM Breintung) Pf =  0.0005523440504782278
Probability of failure (SORM Hohenbichler) Pf =  0.0005420328660296243
Probability of failure (SORM Tvedt) Pf =  0.0005381057564251503
</pre></div>
</div>
<p>Display all figures</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">otv</span><span class="o">.</span><span class="n">View</span><span class="o">.</span><span class="n">ShowAll</span><span class="p">()</span>
</pre></div>
</div>
<p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes  1.305 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-reliability-sensitivity-reliability-plot-form-explained-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/3d2145e19a3f35b61ce70b0fbf969d54/plot_form_explained.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">plot_form_explained.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../../_downloads/c61fd9f93d93e9cf0203e12a05051e42/plot_form_explained.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">plot_form_explained.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../reliability_processes/plot_event_process.html" title="Create an event based on a process"
             >next</a> |</li>
        <li class="right" >
          <a href="plot_event_system.html" title="Create unions or intersections of events"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">OpenTURNS 1.18rc1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../contents.html" >Contents</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../examples/examples.html" >Examples</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../index.html" >Reliability &amp; Sensitivity</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">An illustrated example of a FORM probability estimate</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2005-2021 Airbus-EDF-IMACS-ONERA-Phimeca.
      Last updated on Nov 08, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>