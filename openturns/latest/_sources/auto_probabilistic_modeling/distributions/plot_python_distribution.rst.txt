
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/distributions/plot_python_distribution.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_distributions_plot_python_distribution.py:


Create a customized distribution or copula
==========================================

.. GENERATED FROM PYTHON SOURCE LINES 7-20

In this example, we show how to create our own distribution or copula.

We use a :class:`~openturns.PythonDistribution` that overloads all the methods of the
:class:`~openturns.Distribution` class.
It is not necessary to override all the methods: only the *computeCDF()* and *getRange()* methods
must be overridden.
All the methods which are not overridden  are inherited from
:class:`~openturns.Distribution`: they are numerically derived from the *computeCDF()*
method, using some keys of the :class:`~openturns.ResourceMap` class.

To create a copula, the method *isCopula()* has to be overridden and return *True*.

Then an instance of the new class can be passed on into a :class:`~openturns.Distribution` class.

.. GENERATED FROM PYTHON SOURCE LINES 22-30

.. code-block:: Python

    import openturns as ot
    import openturns.testing as ott
    import openturns.viewer as otv
    import math as m
    import warnings

    warnings.filterwarnings("ignore")








.. GENERATED FROM PYTHON SOURCE LINES 31-32

First inherit :class:`~openturns.PythonDistribution`:

.. GENERATED FROM PYTHON SOURCE LINES 32-137

.. code-block:: Python



    class UniformNdPy(ot.PythonDistribution):
        def __init__(self, a=[0.0], b=[1.0]):
            super().__init__(len(a))
            if len(a) != len(b):
                raise ValueError("Invalid bounds")
            for i in range(len(a)):
                if a[i] > b[i]:
                    raise ValueError("Invalid bounds")
            self.a = a
            self.b = b
            self.factor = 1.0
            for i in range(len(a)):
                self.factor *= b[i] - a[i]

        def getRange(self):
            return ot.Interval(self.a, self.b, [True] * len(self.a), [True] * len(self.a))

        def getRealization(self):
            X = []
            for i in range(len(self.a)):
                X.append(
                    self.a[i] + (self.b[i] - self.a[i]) * ot.RandomGenerator.Generate()
                )
            return X

        def getSample(self, size):
            X = []
            for i in range(size):
                X.append(self.getRealization())
            return X

        def computeCDF(self, X):
            prod = 1.0
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                prod *= min(self.b[i], X[i]) - self.a[i]
            return prod / self.factor

        def computePDF(self, X):
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                if X[i] > self.b[i]:
                    return 0.0
            return 1.0 / self.factor

        def getMean(self):
            mu = []
            for i in range(len(self.a)):
                mu.append(0.5 * (self.a[i] + self.b[i]))
            return mu

        def getStandardDeviation(self):
            stdev = []
            for i in range(len(self.a)):
                stdev.append((self.b[i] - self.a[i]) / m.sqrt(12.0))
            return stdev

        def getSkewness(self):
            return [0.0] * len(self.a)

        def getKurtosis(self):
            return [1.8] * len(self.a)

        def getMoment(self, n):
            return [-0.1 * n] * len(self.a)

        def computeCharacteristicFunction(self, x):
            if len(self.a) > 1:
                raise ValueError("dim>1")
            ax = self.a[0] * x
            bx = self.b[0] * x
            return (m.sin(bx) - m.sin(ax) + 1j * (m.cos(ax) - m.cos(bx))) / (bx - ax)

        def isElliptical(self):
            return (len(self.a) == 1) and (self.a[0] == -self.b[0])

        def isCopula(self):
            for i in range(len(self.a)):
                if self.a[i] != 0.0:
                    return False
                if self.b[i] != 1.0:
                    return False
            return True

        def getMarginal(self, indices):
            subA = []
            subB = []
            for i in indices:
                subA.append(self.a[i])
                subB.append(self.b[i])
            py_dist = UniformNdPy(subA, subB)
            return ot.Distribution(py_dist)

        def computeQuantile(self, prob, tail=False):
            p = 1.0 - prob if tail else prob
            quantile = list(self.a)
            for i in range(len(self.a)):
                quantile[i] += p * (self.b[i] - self.a[i])
            return quantile









.. GENERATED FROM PYTHON SOURCE LINES 138-139

Now instantiate the distribution:

.. GENERATED FROM PYTHON SOURCE LINES 139-141

.. code-block:: Python

    distribution = ot.Distribution(UniformNdPy([5, 6], [7, 9]))








.. GENERATED FROM PYTHON SOURCE LINES 142-143

And plot the CDF:

.. GENERATED FROM PYTHON SOURCE LINES 143-146

.. code-block:: Python

    graph = distribution.drawCDF()
    view = otv.View(graph)




.. image-sg:: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.svg
   :alt: X0 iso-CDF
   :srcset: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 147-148

We can easily generate sample:

.. GENERATED FROM PYTHON SOURCE LINES 148-150

.. code-block:: Python

    distribution.getSample(5)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
      <tr><td></td><th>v0</th><th>v1</th></tr>
      <tr><th>0</th><td>6.259753</td><td>8.648416</td></tr>
      <tr><th>1</th><td>5.270553</td><td>6.097508</td></tr>
      <tr><th>2</th><td>5.694114</td><td>8.908269</td></tr>
      <tr><th>3</th><td>6.841359</td><td>7.50912</td></tr>
      <tr><th>4</th><td>5.126412</td><td>6.878271</td></tr>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 151-152

or compute the mean:

.. GENERATED FROM PYTHON SOURCE LINES 152-154

.. code-block:: Python

    distribution.getMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=2 values=[6,7.5]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 155-156

Also we can compute the probability contained in an interval:

.. GENERATED FROM PYTHON SOURCE LINES 156-158

.. code-block:: Python

    distribution.computeProbability(ot.Interval([5.5, 6], [8.5, 9]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.75



.. GENERATED FROM PYTHON SOURCE LINES 159-161

We can validate the distribution with :class:`openturns.testing.DistributionValidation`
It automatically checks the consistency of most services and allows one to check for errors.

.. GENERATED FROM PYTHON SOURCE LINES 161-164

.. code-block:: Python

    checker = ott.DistributionValidation(distribution)
    checker.run()








.. GENERATED FROM PYTHON SOURCE LINES 165-166

.. code-block:: Python

    otv.View.ShowAll()








.. _sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_python_distribution.ipynb <plot_python_distribution.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_python_distribution.py <plot_python_distribution.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_python_distribution.zip <plot_python_distribution.zip>`
