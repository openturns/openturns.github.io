
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_stochastic_processes/plot_mix_rv_process.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_stochastic_processes_plot_mix_rv_process.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_stochastic_processes_plot_mix_rv_process.py:


Create a process from random vectors and processes
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-24

The objective is to create a process defined from a random vector and a process.

We consider the following limit state function, defined as the difference between a degrading resistance :math:`r(t) = R - bt` and a time-varying load :math:`S(t)`:

.. math::
   \begin{align*}
   g(t)= r(t) - S(t) = R - bt - S(t)
   \end{align*}

We propose the following probabilistic model:

- :math:`R` is the initial resistance, and :math:`R \sim \mathcal{N}(\mu_R, \sigma_R)`;
- :math:`b` is the deterioration rate of the resistance; it is deterministic;
- :math:`S(t)` is the time-varying stress, which is modeled by a stationary Gaussian process of mean value :math:`\mu_S`,
  standard deviation :math:`\sigma_S` and a squared exponential covariance model;
- :math:`t` is the time, varying in :math:`[0,T]`.


.. GENERATED FROM PYTHON SOURCE LINES 27-28

First, import the python modules:

.. GENERATED FROM PYTHON SOURCE LINES 30-34

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as otv
    import math as m








.. GENERATED FROM PYTHON SOURCE LINES 35-37

1. Create the Gaussian process :math:`(\omega, t) \rightarrow S(\omega,t)`
--------------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 39-40

Create the mesh which is a regular grid on :math:`[0,T]`, with :math:`T=50`, by step =1:

.. GENERATED FROM PYTHON SOURCE LINES 42-49

.. code-block:: Python

    b = 0.01
    t0 = 0.0
    step = 1
    tfin = 50
    n = round((tfin - t0) / step)
    myMesh = ot.RegularGrid(t0, step, n)








.. GENERATED FROM PYTHON SOURCE LINES 50-57

Create the squared exponential covariance model:

.. math::
   C(s,t) = \sigma^2e^{-\frac{1}{2} \left( \dfrac{s-t}{l} \right)^2}

where the scale parameter is :math:`l=\frac{10}{\sqrt{2}}` and the amplitude :math:`\sigma = 1`.


.. GENERATED FROM PYTHON SOURCE LINES 59-63

.. code-block:: Python

    ll = 10 / m.sqrt(2)
    myCovKernel = ot.SquaredExponential([ll])
    print("cov model = ", myCovKernel)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cov model =  SquaredExponential(scale=[7.07107], amplitude=[1])




.. GENERATED FROM PYTHON SOURCE LINES 64-65

Create the Gaussian process :math:`S(t)`:

.. GENERATED FROM PYTHON SOURCE LINES 67-70

.. code-block:: Python

    S_proc = ot.GaussianProcess(myCovKernel, myMesh)









.. GENERATED FROM PYTHON SOURCE LINES 71-73

2. Create the process :math:`(\omega, t) \rightarrow R(\omega)-bt`
------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 75-76

First, create the random variable :math:`R \sim \mathcal{N}(\mu_R, \sigma_R)`, with :math:`\mu_R = 5` and :math:`\sigma_R = 0.3`:

.. GENERATED FROM PYTHON SOURCE LINES 78-82

.. code-block:: Python

    muR = 5
    sigR = 0.3
    R = ot.Normal(muR, sigR)








.. GENERATED FROM PYTHON SOURCE LINES 83-84

The create the Dirac random variable :math:`B = b`:

.. GENERATED FROM PYTHON SOURCE LINES 86-88

.. code-block:: Python

    B = ot.Dirac(b)








.. GENERATED FROM PYTHON SOURCE LINES 89-96

Then create the process :math:`(\omega, t) \rightarrow R(\omega)-bt` using the :class:`~openturns.FunctionalBasisProcess` class
and the functional basis :math:`\phi_1 : t \rightarrow 1` and :math:`\phi_2: -t \rightarrow t`:

.. math::
   R(\omega)-bt = R(\omega)\phi_1(t) + B(\omega) \phi_2(t)

with :math:`(R,B)` independent.

.. GENERATED FROM PYTHON SOURCE LINES 98-106

.. code-block:: Python

    const_func = ot.SymbolicFunction(["t"], ["1"])
    linear_func = ot.SymbolicFunction(["t"], ["-t"])
    myBasis = ot.Basis([const_func, linear_func])

    coef = ot.JointDistribution([R, B])

    R_proc = ot.FunctionalBasisProcess(coef, myBasis, myMesh)








.. GENERATED FROM PYTHON SOURCE LINES 107-109

3. Create the process :math:`Z: (\omega, t) \rightarrow R(\omega)-bt + S(\omega, t)`
------------------------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 111-112

First, aggregate both processes into one process of dimension 2: :math:`(R_{proc}, S_{proc})`

.. GENERATED FROM PYTHON SOURCE LINES 114-116

.. code-block:: Python

    myRS_proc = ot.AggregatedProcess([R_proc, S_proc])








.. GENERATED FROM PYTHON SOURCE LINES 117-128

Then create the spatial field function that acts only on the values of the process, keeping the mesh unchanged, using the :class:`~openturns.ValueFunction` class.
We define the function :math:`g` on :math:`\mathbb{R}^2` by:

.. math::
   g(x,y) = x-y

in order to define the spatial field function :math:`g_{dyn}` that acts on fields, defined by:

.. math::
   \forall t\in [0,T], g_{dyn}(X(\omega, t), Y(\omega, t)) = X(\omega, t) - Y(\omega, t)


.. GENERATED FROM PYTHON SOURCE LINES 130-133

.. code-block:: Python

    g = ot.SymbolicFunction(["x1", "x2"], ["x1-x2"])
    gDyn = ot.ValueFunction(g, myMesh)








.. GENERATED FROM PYTHON SOURCE LINES 134-135

Now you have to create the final process :math:`Z` thanks to :math:`g_{dyn}`:

.. GENERATED FROM PYTHON SOURCE LINES 137-139

.. code-block:: Python

    Z_proc = ot.CompositeProcess(gDyn, myRS_proc)








.. GENERATED FROM PYTHON SOURCE LINES 140-142

4. Draw some realizations of the process
----------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 144-150

.. code-block:: Python

    N = 10
    sampleZ_proc = Z_proc.getSample(N)
    graph = sampleZ_proc.drawMarginal(0)
    graph.setTitle(r"Some realizations of $Z(\omega, t)$")
    view = otv.View(graph)




.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_mix_rv_process_001.svg
   :alt: Some realizations of $Z(\omega, t)$
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_mix_rv_process_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 151-153

5. Evaluate the probability that :math:`Z(\omega, t) \in \mathcal{D}`
---------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 155-156

We define the domain :math:`\mathcal{D} = [2,4]` and the event :math:`Z(\omega, t) \in \mathcal{D}`:

.. GENERATED FROM PYTHON SOURCE LINES 158-162

.. code-block:: Python

    domain = ot.Interval([2], [4])
    print("D = ", domain)
    event = ot.ProcessEvent(Z_proc, domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    D =  [2, 4]




.. GENERATED FROM PYTHON SOURCE LINES 163-164

We use the Monte Carlo sampling to evaluate the probability:

.. GENERATED FROM PYTHON SOURCE LINES 166-182

.. code-block:: Python

    MC_algo = ot.ProbabilitySimulationAlgorithm(event)
    MC_algo.setMaximumOuterSampling(1000000)
    MC_algo.setBlockSize(100)
    MC_algo.setMaximumCoefficientOfVariation(0.01)
    MC_algo.run()

    result = MC_algo.getResult()

    proba = result.getProbabilityEstimate()
    print("Probability = ", proba)
    variance = result.getVarianceEstimate()
    print("Variance Estimate = ", variance)
    IC90_low = proba - result.getConfidenceLength(0.90) / 2
    IC90_upp = proba + result.getConfidenceLength(0.90) / 2
    print("IC (90%) = [", IC90_low, ", ", IC90_upp, "]")
    view.ShowAll()




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Probability =  0.7505882352941179
    Variance Estimate =  5.561188313010005e-05
    IC (90%) = [ 0.7383220066001566 ,  0.7628544639880792 ]





.. _sphx_glr_download_auto_stochastic_processes_plot_mix_rv_process.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_mix_rv_process.ipynb <plot_mix_rv_process.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_mix_rv_process.py <plot_mix_rv_process.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_mix_rv_process.zip <plot_mix_rv_process.zip>`
