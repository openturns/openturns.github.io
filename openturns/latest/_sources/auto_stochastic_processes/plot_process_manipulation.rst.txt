
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_stochastic_processes/plot_process_manipulation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_stochastic_processes_plot_process_manipulation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_stochastic_processes_plot_process_manipulation.py:


Manipulate stochastic processes
===============================

.. GENERATED FROM PYTHON SOURCE LINES 7-20

The objective here is to manipulate a multivariate stochastic process :math:`X: \Omega \times \mathcal{D} \rightarrow \mathbb{R}^d`,
where :math:`\mathcal{D} \in \mathbb{R}^n` is discretized on the mesh :math:`\mathcal{M}`
and exhibit some of the services exposed by the :class:`~openturns.Process` objects:

- ask for the dimension, with the method :meth:`~openturns.Process.getOutputDimension` ;
- ask for the mesh, with the method :meth:`~openturns.Process.getMesh` ;
- ask for the mesh as regular 1-d mesh, with the :meth:`~openturns.Process.getTimeGrid` method ;
- ask for a realization, with the method the :meth:`~openturns.Process.getRealization` method ;
- ask for a continuous realization, with the :meth:`~openturns.Process.getContinuousRealization` method ;
- ask for a sample of realizations, with the :meth:`~openturns.Process.getSample` method ;
- ask for the normality of the process with the :meth:`~openturns.Process.isNormal` method ;
- ask for the stationarity of the process with the :meth:`~openturns.Process.isStationary` method.


.. GENERATED FROM PYTHON SOURCE LINES 22-25

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as otv








.. GENERATED FROM PYTHON SOURCE LINES 26-27

We create a mesh -a time grid- which is a :class:`~openturns.RegularGrid` :

.. GENERATED FROM PYTHON SOURCE LINES 27-33

.. code-block:: Python

    tMin = 0.0
    timeStep = 0.1
    n = 100
    time_grid = ot.RegularGrid(tMin, timeStep, n)
    time_grid.setName("time")








.. GENERATED FROM PYTHON SOURCE LINES 34-36

We create a Normal process :math:`X_t = (X_t^0, X_t^1, X_t^2)` in dimension 3 with an exponential covariance model.
We define the amplitude and the scale of the :class:`~openturns.ExponentialModel`

.. GENERATED FROM PYTHON SOURCE LINES 36-39

.. code-block:: Python

    scale = [4.0]
    amplitude = [1.0, 2.0, 3.0]








.. GENERATED FROM PYTHON SOURCE LINES 40-41

We define a spatial correlation :

.. GENERATED FROM PYTHON SOURCE LINES 41-46

.. code-block:: Python

    spatialCorrelation = ot.CorrelationMatrix(3)
    spatialCorrelation[0, 1] = 0.8
    spatialCorrelation[0, 2] = 0.6
    spatialCorrelation[1, 2] = 0.1








.. GENERATED FROM PYTHON SOURCE LINES 47-48

The covariance model is now created with :

.. GENERATED FROM PYTHON SOURCE LINES 48-50

.. code-block:: Python

    myCovarianceModel = ot.ExponentialModel(scale, amplitude, spatialCorrelation)








.. GENERATED FROM PYTHON SOURCE LINES 51-52

Eventually, the process is  built with :

.. GENERATED FROM PYTHON SOURCE LINES 52-54

.. code-block:: Python

    process = ot.GaussianProcess(myCovarianceModel, time_grid)








.. GENERATED FROM PYTHON SOURCE LINES 55-56

The dimension `d` of the process may be retrieved by

.. GENERATED FROM PYTHON SOURCE LINES 56-59

.. code-block:: Python

    dim = process.getOutputDimension()
    print("Dimension : %d" % dim)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Dimension : 3




.. GENERATED FROM PYTHON SOURCE LINES 60-61

The underlying mesh of the process is obtained with the `getMesh` method :

.. GENERATED FROM PYTHON SOURCE LINES 61-63

.. code-block:: Python

    mesh = process.getMesh()








.. GENERATED FROM PYTHON SOURCE LINES 64-65

We have access to peculiar data of the mesh such as the corners :

.. GENERATED FROM PYTHON SOURCE LINES 65-68

.. code-block:: Python

    minMesh = mesh.getVertices().getMin()[0]
    maxMesh = mesh.getVertices().getMax()[0]








.. GENERATED FROM PYTHON SOURCE LINES 69-70

We draw it :

.. GENERATED FROM PYTHON SOURCE LINES 70-77

.. code-block:: Python

    graph = mesh.draw()
    graph.setTitle("Time grid (mesh)")
    graph.setXTitle("t")
    graph.setYTitle("")
    view = otv.View(graph)





.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_001.svg
   :alt: Time grid (mesh)
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 78-79

We can get the time grid of the process when the mesh can be interpreted as a regular time grid :

.. GENERATED FROM PYTHON SOURCE LINES 79-82

.. code-block:: Python

    print(process.getTimeGrid())






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    RegularGrid(start=0, step=0.1, n=100)




.. GENERATED FROM PYTHON SOURCE LINES 83-84

A typical feature of a process is the generation of a realization of itself :

.. GENERATED FROM PYTHON SOURCE LINES 84-86

.. code-block:: Python

    realization = process.getRealization()








.. GENERATED FROM PYTHON SOURCE LINES 87-89

Here it is a sample of size :math:`100 \times 4` (100 time steps, 3 spatial cooordinates and the time variable).
We are able to draw its marginals, for instance the first (index 0) one :math:`X_t^0`, against the time with no interpolation:

.. GENERATED FROM PYTHON SOURCE LINES 89-96

.. code-block:: Python

    interpolate = False
    graph = realization.drawMarginal(0, interpolate)
    graph.setTitle("First marginal of a realization of the process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t^0$")
    view = otv.View(graph)




.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_002.svg
   :alt: First marginal of a realization of the process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_002.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 97-98

The same graph, but with interpolated values (default behaviour) :

.. GENERATED FROM PYTHON SOURCE LINES 98-105

.. code-block:: Python

    graph = realization.drawMarginal(0)
    graph.setTitle("First marginal of a realization of the process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t^0$")
    view = otv.View(graph)





.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_003.svg
   :alt: First marginal of a realization of the process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_003.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 106-107

We can build a function representing the process using P1-Lagrange interpolation (when not defined from a functional model).

.. GENERATED FROM PYTHON SOURCE LINES 107-109

.. code-block:: Python

    continuousRealization = process.getContinuousRealization()








.. GENERATED FROM PYTHON SOURCE LINES 110-111

Once again we draw its first marginal :

.. GENERATED FROM PYTHON SOURCE LINES 111-117

.. code-block:: Python

    marginal0 = continuousRealization.getMarginal(0)
    graph = marginal0.draw(minMesh, maxMesh)
    graph.setTitle("First marginal of a P1-Lagrange continuous realization of the process")
    graph.setXTitle("t")
    view = otv.View(graph)




.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_004.svg
   :alt: First marginal of a P1-Lagrange continuous realization of the process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_004.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 118-120

Please note that the `marginal0` object is a function. Consequently we can
evaluate it at any point of the domain, say :math:`t_0=3.5678`

.. GENERATED FROM PYTHON SOURCE LINES 120-124

.. code-block:: Python

    t0 = 3.5678
    print(t0, marginal0([t0]))






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    3.5678 [0.295309]




.. GENERATED FROM PYTHON SOURCE LINES 125-126

Several realizations of the process may be determined at once :

.. GENERATED FROM PYTHON SOURCE LINES 126-129

.. code-block:: Python

    number = 10
    fieldSample = process.getSample(number)








.. GENERATED FROM PYTHON SOURCE LINES 130-132

Let us draw them the first marginal
sphinx_gallery_thumbnail_number = 5

.. GENERATED FROM PYTHON SOURCE LINES 132-138

.. code-block:: Python

    graph = fieldSample.drawMarginal(0, False)
    graph.setTitle("First marginal of 10 realizations of the process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t^0$")
    view = otv.View(graph)




.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_005.svg
   :alt: First marginal of 10 realizations of the process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_005.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 139-140

Same graph, but with interpolated values :

.. GENERATED FROM PYTHON SOURCE LINES 140-147

.. code-block:: Python

    graph = fieldSample.drawMarginal(0)
    graph.setTitle("First marginal of 10 realizations of the process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t^0$")
    view = otv.View(graph)





.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_006.svg
   :alt: First marginal of 10 realizations of the process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_process_manipulation_006.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 148-155

Miscellanies
------------

We can extract any marginal of the process with the `getMarginal` method.
Beware the numerotation begins at 0 ! It may be not implemented yet for
some processes.
The extracted marginal is a 1-d Gaussian process

.. GENERATED FROM PYTHON SOURCE LINES 155-157

.. code-block:: Python

    print(process.getMarginal([1]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GaussianProcess(trend=[x0]->[0], covariance=ExponentialModel(scale=[4], amplitude=[2], no spatial correlation))




.. GENERATED FROM PYTHON SOURCE LINES 158-159

If we extract simultaneously two indices we build a 2-d Gaussian process

.. GENERATED FROM PYTHON SOURCE LINES 159-161

.. code-block:: Python

    print(process.getMarginal([0, 2]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    GaussianProcess(trend=[x0]->[0,0], covariance=ExponentialModel(scale=[4], amplitude=[1,3], spatial correlation=
    [[ 1   0.6 ]
     [ 0.6 1   ]]))




.. GENERATED FROM PYTHON SOURCE LINES 162-163

We can check whether the process is Gaussian or not

.. GENERATED FROM PYTHON SOURCE LINES 163-165

.. code-block:: Python

    print("Is normal ? ", process.isNormal())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Is normal ?  True




.. GENERATED FROM PYTHON SOURCE LINES 166-167

and the stationarity as well

.. GENERATED FROM PYTHON SOURCE LINES 167-169

.. code-block:: Python

    print("Is stationary ? ", process.isStationary())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Is stationary ?  True




.. GENERATED FROM PYTHON SOURCE LINES 170-171

Display all figures

.. GENERATED FROM PYTHON SOURCE LINES 171-172

.. code-block:: Python

    otv.View.ShowAll()








.. _sphx_glr_download_auto_stochastic_processes_plot_process_manipulation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_process_manipulation.ipynb <plot_process_manipulation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_process_manipulation.py <plot_process_manipulation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_process_manipulation.zip <plot_process_manipulation.zip>`
