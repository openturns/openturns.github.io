
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_functional_modeling/vectorial_functions/plot_create_multivariate_function.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_functional_modeling_vectorial_functions_plot_create_multivariate_function.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_functional_modeling_vectorial_functions_plot_create_multivariate_function.py:


=============================
Create multivariate functions
=============================
We can create multivariate functions by different methods. One of the methods is to gather
multivariate functions. The other one is to create a function having multivariate input using
the tensor product of univariate functions. In this example, we present both methods.

.. GENERATED FROM PYTHON SOURCE LINES 11-39

Description
===========

We want to build some multivariate functions :math:`f : \mathbb{R}^d \mapsto \mathbb{R}^q`.

We can do that:

- Case 1: using a finite collection of multivariate functions :math:`f_i:  \mathbb{R}^d \mapsto \mathbb{R}^q`,
- Case 2: using the tensor product of univariate functions,
- Case 3: using the tensor product of orthogonal univariate polynomials,
- Case 4: using the tensor product of orthogonal univariate functions.


Case 1: Finite collection of multivariate functions
===================================================

In that case, we have a  finite collection of multivariate functions
:math:`f_i : \mathbb{R}^d \mapsto \mathbb{R}^q`.
We use the :class:`~openturns.Basis` class.

For example, we consider:

.. math::
    \begin{array}{lcl}
      f_1(x_1, x_2) & = & (x_1^2, x_2^2)\\
      f_2(x_1, x_2) & = & (x_1+1, 2x_2)\\
      f_3(x_1, x_2) & = & (\cos(x_1x_2), x_2^3)
    \end{array}

.. GENERATED FROM PYTHON SOURCE LINES 39-50

.. code-block:: Python


    import openturns as ot

    f1 = ot.SymbolicFunction(["x1", "x2"], ["x1^2", "x2^2"])
    f2 = ot.SymbolicFunction(["x1", "x2"], ["x1+1.0", "2.0*x2"])
    f3 = ot.SymbolicFunction(["x1", "x2"], ["cos(x1*x2)", "x2^3"])

    myBasis = ot.Basis([f1, f2, f3])
    f = myBasis.build(1)









.. GENERATED FROM PYTHON SOURCE LINES 51-70

Case 2: Tensor product of univariate functions
==============================================

In that case, the univariate functions are not necessarily orthogonal with respect to a measure.

We have the family of functions: :math:`(x_i \mapsto \phi^i_k(x_i))_{k \geq 0}`
for :math:`1 \leq i \leq d`.. The :class:`~openturns.EnumerateFunction` class
stores the way the multivariate basis is enumerated: *enumerate(n)* is a multi-index
:math:`\boldsymbol{\alpha} = (\alpha_1, \dots, \alpha_d)` such that the function number :math:`n` is:

.. math::
    f_n(\vect{x}) = \prod_{i=1}^d \phi^i_{\alpha_i}(x_i).

We use the :class:`~openturns.TensorizedUniVariateFunctionFactory` class.

For example, we consider: :math:`f: \mathbb{R}^2 \mapsto \mathbb{R}`, and:

- dimension :math:`x_1`: the family of monomials: :math:`(x_1 \mapsto x_1^k)_{k \geq 0}`,
- dimension :math:`x_2`: the family of Haar wavelets:  :math:`(x_2 \mapsto \phi^2_k(x_2))_{k \geq 0}`.

.. GENERATED FROM PYTHON SOURCE LINES 70-92

.. code-block:: Python


    univFuncFamily_Mon = ot.MonomialFunctionFactory()
    univFuncFamily_UnivPol = ot.OrthogonalUniVariatePolynomialFunctionFactory(
        ot.JacobiFactory()
    )
    univFuncFamily_Haar = ot.HaarWaveletFactory()
    univFuncFamily_Fourier = ot.FourierSeriesFactory()

    familyColl = [
        univFuncFamily_Mon,
        univFuncFamily_UnivPol,
        univFuncFamily_Haar,
        univFuncFamily_Fourier,
    ]
    enumerateFunction = ot.LinearEnumerateFunction(len(familyColl))

    familyFunction = ot.TensorizedUniVariateFunctionFactory(familyColl, enumerateFunction)
    k = 3
    f = familyFunction.build(k)
    print("input dimension = ", f.getInputDimension())
    print("output dimension = ", f.getOutputDimension())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input dimension =  4
    output dimension =  1




.. GENERATED FROM PYTHON SOURCE LINES 93-97

If we want to use an orthogonal univariate polynomials family, then we have to cast the family
in the  :class:`~openturns.OrthogonalUniVariatePolynomialFunctionFactory` class.

For example, we use the  Jacobi orthogonal univariate polynomials family.

.. GENERATED FROM PYTHON SOURCE LINES 97-102

.. code-block:: Python

    univFuncFamily_Jacobi = ot.OrthogonalUniVariatePolynomialFunctionFactory(
        ot.JacobiFactory()
    )









.. GENERATED FROM PYTHON SOURCE LINES 103-123

Case 3:  Tensor product of orthogonal univariate polynomials
============================================================

In that case, the univariate polynomials are orthogonal with respect to a measure :math:`\mu`.

We have the family of polynomials: :math:`(x_i \mapsto \phi^i_k(x_i))_{k \geq 0}`
for :math:`1 \leq i \leq d`. The :class:`~openturns.EnumerateFunction` class decides the way
the multivariate basis is enumerated: *enumerate(n)* is a multi-index
:math:`(\ell_1, \dots, \ell_d)` such that the function number :math:`n`
is:

.. math::
    f_n(\vect{x}) = \prod_{i=1}^d \phi^i_{\ell_i}(x_i).

We use the  :class:`~openturns.OrthogonalProductPolynomialFactory` class.

For example, we consider : :math:`f: \mathbb{R}^2 \mapsto \mathbb{R}`, and:

- dimension of :math:`x_1`: the family of Jacobi polynomials: :math:`(x_1 \mapsto x_1^k){k \geq 0}`,
- dimension of :math:`x_2`: the family of Hermite polynomials: :math:`(x_2 \mapsto \phi^2_k(x_2))_{k \geq 0}`.

.. GENERATED FROM PYTHON SOURCE LINES 123-133

.. code-block:: Python


    univFuncFamily_Jacobi = ot.JacobiFactory()
    univFuncFamily_Hermite = ot.HermiteFactory()
    familyColl = [univFuncFamily_Jacobi, univFuncFamily_Hermite]
    enumerateFunction = ot.LinearEnumerateFunction(len(familyColl))
    familyFunction = ot.OrthogonalProductPolynomialFactory(familyColl, enumerateFunction)
    f = familyFunction.build(3)
    print("input dimension = ", f.getInputDimension())
    print("output dimension = ", f.getOutputDimension())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input dimension =  2
    output dimension =  1




.. GENERATED FROM PYTHON SOURCE LINES 134-135

We get the measure:

.. GENERATED FROM PYTHON SOURCE LINES 135-141

.. code-block:: Python

    measure_Jacobi = ot.JacobiFactory().getMeasure()
    measure_Hermite = ot.HermiteFactory().getMeasure()
    print("Measure orthogonal to Jacobi polynomials = ", measure_Jacobi)
    print("Measure orthogonal to Hermite polynomials = ", measure_Hermite)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Measure orthogonal to Jacobi polynomials =  Beta(alpha = 2, beta = 2, a = -1, b = 1)
    Measure orthogonal to Hermite polynomials =  Normal(mu = 0, sigma = 1)




.. GENERATED FROM PYTHON SOURCE LINES 142-157

Case 4: Tensor product of orthogonal univariate functions
=========================================================

In that case, the univariate functions are orthogonal with respect to a measure :math:`\mu`.

We have the family of functions: :math:`(x_i \mapsto \phi^i_k(x_i))_{k \geq 0}`
for :math:`1 \leq i \leq d`. The :class:`~openturns.EnumerateFunction` class
stores the way the multivariate basis is enumerated: *enumerate(n)* is a multi-index
:math:`\vect{\alpha} = (\alpha_1, \dots, \alpha_d)` such that the function number *n* is:

.. math::

     f_n(\vect{x}) = \prod_{i=1}^d \phi^i_{\alpha_i}(x_i)

We use the :class:`~openturns.OrthogonalProductFunctionFactory` class.

.. GENERATED FROM PYTHON SOURCE LINES 160-164

For example, we consider : :math:`f: \mathbb{R}^2 \mapsto \mathbb{R}`, and:

- dimension :math:`x_1`: the family of Haar wavelets: :math:`(x_1 \mapsto \phi^1_k(x_1))_{k \geq 0}`,
- dimension :math:`x_2`: the family of Fourier series functions: :math:`(x_2 \mapsto \phi^2_k(x_2)){k \geq 0}`.

.. GENERATED FROM PYTHON SOURCE LINES 164-174

.. code-block:: Python


    univFuncFamily_Haar = ot.HaarWaveletFactory()
    univFuncFamily_Fourier = ot.FourierSeriesFactory()
    familyColl = [univFuncFamily_Haar, univFuncFamily_Fourier]
    enumerateFunction = ot.LinearEnumerateFunction(len(familyColl))

    familyFunction = ot.OrthogonalProductFunctionFactory(familyColl, enumerateFunction)
    k = 3
    f = familyFunction.build(k)








.. GENERATED FROM PYTHON SOURCE LINES 175-176

We get the measure:

.. GENERATED FROM PYTHON SOURCE LINES 176-180

.. code-block:: Python

    measure_Haar = ot.HaarWaveletFactory().getMeasure()
    measure_Fourier = ot.FourierSeriesFactory().getMeasure()
    print("Measure orthogonal to Haar wavelets = ", measure_Haar)
    print("Measure orthogonal to Fourier series = ", measure_Fourier)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Measure orthogonal to Haar wavelets =  Uniform(a = 0, b = 1)
    Measure orthogonal to Fourier series =  Uniform(a = -3.14159, b = 3.14159)





.. _sphx_glr_download_auto_functional_modeling_vectorial_functions_plot_create_multivariate_function.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_multivariate_function.ipynb <plot_create_multivariate_function.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_multivariate_function.py <plot_create_multivariate_function.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_create_multivariate_function.zip <plot_create_multivariate_function.zip>`
