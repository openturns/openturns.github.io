
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_sensitivity_analysis/plot_functional_chaos_sensitivity.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_sensitivity_analysis_plot_functional_chaos_sensitivity.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_sensitivity_analysis_plot_functional_chaos_sensitivity.py:


Sobol' sensitivity indices from chaos
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 7-24

In this example we are going to compute global sensitivity indices from a functional chaos decomposition.

We study the Borehole function that models water flow through a borehole:

.. math::
   \frac{2 \pi T_u (H_u - H_l)}{\ln{r/r_w}(1+\frac{2 L T_u}{\ln(r/r_w) r^2_w K_w}\frac{T_u}{T_l})}

With parameters:

- :math:`r_w`: radius of borehole (m)
- :math:`r`: radius of influence (m)
- :math:`T_u`: transmissivity of upper aquifer (:math:`m^2/yr`)
- :math:`H_u`: potentiometric head of upper aquifer (m)
- :math:`T_l`: transmissivity of lower aquifer (:math:`m^2/yr`)
- :math:`H_l`: potentiometric head of lower aquifer (m)
- :math:`L`: length of borehole (m)
- :math:`K_w`: hydraulic conductivity of borehole (:math:`m/yr`)

.. GENERATED FROM PYTHON SOURCE LINES 26-31

.. code-block:: Python

    import openturns as ot
    from operator import itemgetter
    import openturns.viewer as otv









.. GENERATED FROM PYTHON SOURCE LINES 32-33

borehole model

.. GENERATED FROM PYTHON SOURCE LINES 33-51

.. code-block:: Python

    dimension = 8
    input_names = ["rw", "r", "Tu", "Hu", "Tl", "Hl", "L", "Kw"]
    model = ot.SymbolicFunction(
        input_names, ["(2*pi_*Tu*(Hu-Hl))/(ln(r/rw)*(1+(2*L*Tu)/(ln(r/rw)*rw^2*Kw)+Tu/Tl))"]
    )
    coll = [
        ot.Normal(0.1, 0.0161812),
        ot.LogNormal(7.71, 1.0056),
        ot.Uniform(63070.0, 115600.0),
        ot.Uniform(990.0, 1110.0),
        ot.Uniform(63.1, 116.0),
        ot.Uniform(700.0, 820.0),
        ot.Uniform(1120.0, 1680.0),
        ot.Uniform(9855.0, 12045.0),
    ]
    distribution = ot.JointDistribution(coll)
    distribution.setDescription(input_names)








.. GENERATED FROM PYTHON SOURCE LINES 52-53

Freeze r, Tu, Tl from model to go faster

.. GENERATED FROM PYTHON SOURCE LINES 53-63

.. code-block:: Python

    selection = [1, 2, 4]
    complement = ot.Indices(selection).complement(dimension)
    distribution = distribution.getMarginal(complement)
    model = ot.ParametricFunction(
        model, selection, distribution.getMarginal(selection).getMean()
    )
    input_names_copy = list(input_names)
    input_names = itemgetter(*complement)(input_names)
    dimension = len(complement)








.. GENERATED FROM PYTHON SOURCE LINES 64-65

design of experiment

.. GENERATED FROM PYTHON SOURCE LINES 65-69

.. code-block:: Python

    size = 1000
    X = distribution.getSample(size)
    Y = model(X)








.. GENERATED FROM PYTHON SOURCE LINES 70-71

create a functional chaos model

.. GENERATED FROM PYTHON SOURCE LINES 71-75

.. code-block:: Python

    algo = ot.FunctionalChaosAlgorithm(X, Y)
    algo.run()
    result = algo.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 76-77

Quick summary of sensitivity analysis

.. GENERATED FROM PYTHON SOURCE LINES 77-80

.. code-block:: Python

    sensitivityAnalysis = ot.FunctionalChaosSobolIndices(result)
    sensitivityAnalysis






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    FunctionalChaosSobolIndices
    <ul>
      <li>input dimension: 5</li>
      <li>output dimension: 1</li>
      <li>basis size: 181</li>
      <li>mean: [73.8936]</li>
      <li>std-dev: [43.3954]</li>
    </ul>
    <table>
      <tr>
        <th>Input</th>
        <th>Variable</th>
        <th>Sobol' index</th>
        <th>Total index</th>
      </tr>
      <tr>
        <td>0</td>
        <td>rw</td>
        <td>0.858910</td>
        <td>0.871464</td>
      </tr>
      <tr>
        <td>1</td>
        <td>Hu</td>
        <td>0.039188</td>
        <td>0.043765</td>
      </tr>
      <tr>
        <td>2</td>
        <td>Hl</td>
        <td>0.039359</td>
        <td>0.044095</td>
      </tr>
      <tr>
        <td>3</td>
        <td>L</td>
        <td>0.038903</td>
        <td>0.043897</td>
      </tr>
      <tr>
        <td>4</td>
        <td>Kw</td>
        <td>0.009605</td>
        <td>0.010965</td>
      </tr>
    </table>
    <table>
      <tr>
        <th>Index</th>
        <th>Multi-index</th>
        <th>Part of variance</th>
      </tr>
      <tr>
        <td>1</td>
        <td>[1,0,0,0,0]</td>
        <td>0.258254</td>
      </tr>
      <tr>
        <td>56</td>
        <td>[6,0,0,0,0]</td>
        <td>0.180904</td>
      </tr>
      <tr>
        <td>61</td>
        <td>[7,0,0,0,0]</td>
        <td>0.146223</td>
      </tr>
      <tr>
        <td>31</td>
        <td>[5,0,0,0,0]</td>
        <td>0.118067</td>
      </tr>
      <tr>
        <td>96</td>
        <td>[8,0,0,0,0]</td>
        <td>0.069403</td>
      </tr>
      <tr>
        <td>26</td>
        <td>[4,0,0,0,0]</td>
        <td>0.057760</td>
      </tr>
      <tr>
        <td>3</td>
        <td>[0,0,1,0,0]</td>
        <td>0.039358</td>
      </tr>
      <tr>
        <td>2</td>
        <td>[0,1,0,0,0]</td>
        <td>0.039184</td>
      </tr>
      <tr>
        <td>4</td>
        <td>[0,0,0,1,0]</td>
        <td>0.038495</td>
      </tr>
      <tr>
        <td>131</td>
        <td>[9,0,0,0,0]</td>
        <td>0.013976</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 81-82

draw Sobol' indices

.. GENERATED FROM PYTHON SOURCE LINES 82-87

.. code-block:: Python

    first_order = [sensitivityAnalysis.getSobolIndex(i) for i in range(dimension)]
    total_order = [sensitivityAnalysis.getSobolTotalIndex(i) for i in range(dimension)]
    graph = ot.SobolIndicesAlgorithm.DrawSobolIndices(input_names, first_order, total_order)
    view = otv.View(graph)




.. image-sg:: /auto_sensitivity_analysis/images/sphx_glr_plot_functional_chaos_sensitivity_001.svg
   :alt: Sobol' indices
   :srcset: /auto_sensitivity_analysis/images/sphx_glr_plot_functional_chaos_sensitivity_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 88-90

We saw that total order indices are close to first order,
so the higher order indices must be all quite close to 0

.. GENERATED FROM PYTHON SOURCE LINES 90-95

.. code-block:: Python

    for i in range(dimension):
        for j in range(i):
            sij = sensitivityAnalysis.getSobolIndex([i, j])
            print(f"{input_names[i]} & {input_names[j]}: {sij:.4f}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Hu & rw: 0.0038
    Hl & rw: 0.0040
    Hl & Hu: 0.0000
    L & rw: 0.0037
    L & Hu: 0.0005
    L & Hl: 0.0005
    Kw & rw: 0.0009
    Kw & Hu: 0.0001
    Kw & Hl: 0.0001
    Kw & L: 0.0001




.. GENERATED FROM PYTHON SOURCE LINES 96-97

Display all figures

.. GENERATED FROM PYTHON SOURCE LINES 97-98

.. code-block:: Python

    otv.View.ShowAll()








.. _sphx_glr_download_auto_sensitivity_analysis_plot_functional_chaos_sensitivity.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_functional_chaos_sensitivity.ipynb <plot_functional_chaos_sensitivity.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_functional_chaos_sensitivity.py <plot_functional_chaos_sensitivity.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_functional_chaos_sensitivity.zip <plot_functional_chaos_sensitivity.zip>`
