
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/fields_metamodels/plot_viscous_fall_metamodel.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_fields_metamodels_plot_viscous_fall_metamodel.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_fields_metamodels_plot_viscous_fall_metamodel.py:


Viscous free fall: metamodel of a field function
================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-12

In this example, we present how to create the metamodel of a field function.
This examples considers the :ref:`free fall model <use-case-viscous-fall>`.
We first compute the Karhunen-Lo√®ve decomposition of a sample of trajectories.
Then we create a create a polynomial chaos which takes the inputs and returns
the KL decomposition modes as outputs. Finally, we create a metamodel by
combining the KL decomposition and the polynomial chaos.

.. GENERATED FROM PYTHON SOURCE LINES 15-17

Define the model
----------------

.. GENERATED FROM PYTHON SOURCE LINES 19-26

.. code-block:: Python

    import openturns as ot
    import numpy as np
    import openturns.viewer as viewer
    from matplotlib import pylab as plt

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 27-28

We first define the time grid associated with the model.

.. GENERATED FROM PYTHON SOURCE LINES 30-35

.. code-block:: Python

    tmin = 0.0  # Minimum time
    tmax = 12.0  # Maximum time
    gridsize = 100  # Number of time steps
    mesh = ot.IntervalMesher([gridsize - 1]).build(ot.Interval(tmin, tmax))








.. GENERATED FROM PYTHON SOURCE LINES 36-38

.. code-block:: Python

    vertices = mesh.getVertices()








.. GENERATED FROM PYTHON SOURCE LINES 39-40

Creation of the input distribution.

.. GENERATED FROM PYTHON SOURCE LINES 42-48

.. code-block:: Python

    distZ0 = ot.Uniform(100.0, 150.0)
    distV0 = ot.Normal(55.0, 10.0)
    distM = ot.Normal(80.0, 8.0)
    distC = ot.Uniform(0.0, 30.0)
    distribution = ot.ComposedDistribution([distZ0, distV0, distM, distC])








.. GENERATED FROM PYTHON SOURCE LINES 49-53

.. code-block:: Python

    dimension = distribution.getDimension()
    dimension






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    4



.. GENERATED FROM PYTHON SOURCE LINES 54-58

Then we define the Python function which computes the altitude at each time value.
In order to compute all altitudes with a vectorized evaluation, we first convert
the vertices into a Numpy `array` and use the Numpy functions`exp` and `maximum`:
this increases the evaluation performance of the script.

.. GENERATED FROM PYTHON SOURCE LINES 60-74

.. code-block:: Python

    def AltiFunc(X):
        g = 9.81
        z0 = X[0]
        v0 = X[1]
        m = X[2]
        c = X[3]
        tau = m / c
        vinf = -m * g / c
        t = np.array(vertices)
        z = z0 + vinf * t + tau * (v0 - vinf) * (1 - np.exp(-t / tau))
        z = np.maximum(z, 0.0)
        return [[zeta[0]] for zeta in z]









.. GENERATED FROM PYTHON SOURCE LINES 75-78

In order to create a `Function` from this Python function, we use the `PythonPointToFieldFunction` class.
Since the altitude is the only output field, the third argument `outputDimension` is equal to `1`.
If we had computed the speed as an extra output field, we would have set `2` instead.

.. GENERATED FROM PYTHON SOURCE LINES 80-83

.. code-block:: Python

    outputDimension = 1
    alti = ot.PythonPointToFieldFunction(dimension, mesh, outputDimension, AltiFunc)








.. GENERATED FROM PYTHON SOURCE LINES 84-85

Compute a training sample.

.. GENERATED FROM PYTHON SOURCE LINES 87-92

.. code-block:: Python

    size = 2000
    ot.RandomGenerator.SetSeed(0)
    inputSample = distribution.getSample(size)
    outputSample = alti(inputSample)








.. GENERATED FROM PYTHON SOURCE LINES 93-95

Compute the KL decomposition of the output
------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 97-102

.. code-block:: Python

    algo = ot.KarhunenLoeveSVDAlgorithm(outputSample, 1.0e-6)
    algo.run()
    KLResult = algo.getResult()
    scaledModes = KLResult.getScaledModesAsProcessSample()








.. GENERATED FROM PYTHON SOURCE LINES 103-109

.. code-block:: Python

    graph = scaledModes.drawMarginal(0)
    graph.setTitle("KL modes")
    graph.setXTitle(r"$t$")
    graph.setYTitle(r"$z$")
    view = viewer.View(graph)




.. image-sg:: /auto_meta_modeling/fields_metamodels/images/sphx_glr_plot_viscous_fall_metamodel_001.png
   :alt: KL modes
   :srcset: /auto_meta_modeling/fields_metamodels/images/sphx_glr_plot_viscous_fall_metamodel_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 110-111

We create the `postProcessingKL` function which takes coefficients of the K.-L. modes as inputs and returns the trajectories.

.. GENERATED FROM PYTHON SOURCE LINES 113-115

.. code-block:: Python

    karhunenLoeveLiftingFunction = ot.KarhunenLoeveLifting(KLResult)








.. GENERATED FROM PYTHON SOURCE LINES 116-117

The `project` method computes the projection of the output sample (i.e. the trajectories) onto the K.-L. modes.

.. GENERATED FROM PYTHON SOURCE LINES 119-121

.. code-block:: Python

    outputSampleChaos = KLResult.project(outputSample)








.. GENERATED FROM PYTHON SOURCE LINES 122-123

We limit the sampling size of the Lilliefors selection in order to reduce the computational burden.

.. GENERATED FROM PYTHON SOURCE LINES 125-127

.. code-block:: Python

    ot.ResourceMap.SetAsUnsignedInteger("FittingTest-LillieforsMaximumSamplingSize", 1)








.. GENERATED FROM PYTHON SOURCE LINES 128-129

We create a polynomial chaos metamodel which takes the input sample and returns the K.-L. modes.

.. GENERATED FROM PYTHON SOURCE LINES 131-135

.. code-block:: Python

    algo = ot.FunctionalChaosAlgorithm(inputSample, outputSampleChaos)
    algo.run()
    chaosMetamodel = algo.getResult().getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 136-138

The final metamodel is a composition of the KL lifting function and the polynomial chaos metamodel.
In order to combine these two functions, we use the `PointToFieldConnection` class.

.. GENERATED FROM PYTHON SOURCE LINES 140-142

.. code-block:: Python

    metaModel = ot.PointToFieldConnection(karhunenLoeveLiftingFunction, chaosMetamodel)








.. GENERATED FROM PYTHON SOURCE LINES 143-145

Validate the metamodel
----------------------

.. GENERATED FROM PYTHON SOURCE LINES 147-148

Create a validation sample.

.. GENERATED FROM PYTHON SOURCE LINES 150-154

.. code-block:: Python

    size = 10
    validationInputSample = distribution.getSample(size)
    validationOutputSample = alti(validationInputSample)








.. GENERATED FROM PYTHON SOURCE LINES 155-166

.. code-block:: Python

    graph = validationOutputSample.drawMarginal(0)
    graph.setColors(["red"])
    graph2 = metaModel(validationInputSample).drawMarginal(0)
    graph2.setColors(["blue"])
    graph.add(graph2)
    graph.setTitle("Model/metamodel comparison")
    graph.setXTitle(r"$t$")
    graph.setYTitle(r"$z$")
    view = viewer.View(graph)
    plt.show()




.. image-sg:: /auto_meta_modeling/fields_metamodels/images/sphx_glr_plot_viscous_fall_metamodel_002.png
   :alt: Model/metamodel comparison
   :srcset: /auto_meta_modeling/fields_metamodels/images/sphx_glr_plot_viscous_fall_metamodel_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 167-172

We see that the blue trajectories (i.e. the metamodel) are close to the red
trajectories (i.e. the validation sample).
This shows that the metamodel is quite accurate.
However, we observe that the trajectory singularity that occurs when the object
touches the ground (i.e. when :math:`z` is equal to zero), makes the metamodel less accurate.

.. GENERATED FROM PYTHON SOURCE LINES 174-175

Reset ResourceMap

.. GENERATED FROM PYTHON SOURCE LINES 175-176

.. code-block:: Python

    ot.ResourceMap.Reload()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.124 seconds)


.. _sphx_glr_download_auto_meta_modeling_fields_metamodels_plot_viscous_fall_metamodel.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_viscous_fall_metamodel.ipynb <plot_viscous_fall_metamodel.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_viscous_fall_metamodel.py <plot_viscous_fall_metamodel.py>`
