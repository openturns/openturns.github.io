
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_kriging_beam_arbitrary_trend.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:


Kriging: choose an arbitrary trend
==================================

.. GENERATED FROM PYTHON SOURCE LINES 6-19

The goal of this example is to show how to configure an arbitrary trend in a Kriging metamodel.
In the :doc:`/auto_meta_modeling/kriging_metamodel/plot_kriging_chose_trend`
and :doc:`/auto_meta_modeling/kriging_metamodel/plot_kriging_beam_trend` examples,
we show how to configure a polynomial trend.

In general, any collection of multivariate functions can be used as the
`basis` argument of a :class:`~openturns.KrigingAlgorithm`.
In practice, it might not be convenient to create a multivariate basis and
this is why we sometimes create it by tensorization of univariate functions.
In this example, we first use Legendre polynomials as our univariate functions,
then we create an orthogonal polynomial basis corresponding to the input marginals.

For this purpose, we use the :ref:`cantilever beam <use-case-cantilever-beam>` example.

.. GENERATED FROM PYTHON SOURCE LINES 21-23

Definition of the model
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 25-31

.. code-block:: Python

    from openturns.usecases import cantilever_beam
    import openturns as ot

    ot.RandomGenerator.SetSeed(0)
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 32-33

We load the cantilever beam use case

.. GENERATED FROM PYTHON SOURCE LINES 33-35

.. code-block:: Python

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 36-37

We load the function (model) which evaluates the output Y depending on the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 37-39

.. code-block:: Python

    model = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 40-41

Then we define the distribution of the input random vector.

.. GENERATED FROM PYTHON SOURCE LINES 41-44

.. code-block:: Python

    dimension = cb.dim  # number of inputs
    myDistribution = cb.distribution








.. GENERATED FROM PYTHON SOURCE LINES 45-47

Create the design of experiments
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 49-52

We consider a simple Monte-Carlo sampling as a design of experiments.
This is why we generate an input sample using the `getSample` method of the distribution.
Then we evaluate the output using the `model` function.

.. GENERATED FROM PYTHON SOURCE LINES 54-58

.. code-block:: Python

    sampleSize_train = 20
    X_train = myDistribution.getSample(sampleSize_train)
    Y_train = model(X_train)








.. GENERATED FROM PYTHON SOURCE LINES 59-65

Create the Legendre basis
-------------------------

We first create a Legendre basis of univariate polynomials. In order to convert then into multivariate polynomials, we use a linear enumerate function.

The `LegendreFactory` class creates Legendre polynomials.

.. GENERATED FROM PYTHON SOURCE LINES 67-69

.. code-block:: Python

    univariateFactory = ot.LegendreFactory()








.. GENERATED FROM PYTHON SOURCE LINES 70-71

This factory corresponds to the `Uniform` distribution in the [-1,1] interval.

.. GENERATED FROM PYTHON SOURCE LINES 73-75

.. code-block:: Python

    univariateFactory.getMeasure()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    Uniform
    <ul>
      <li>name=Uniform</li>
      <li>dimension=1</li>
      <li>weight=1</li>
      <li>range=[-1, 1]</li>
      <li>description=[X0]</li>
      <li>isParallel=true</li>
      <li>isCopula=false</li>
    </ul>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 76-78

This interval does not correspond to the interval on which the input marginals are defined (we will come back to this topic later),
but this will, anyway, create a consistent trend for the kriging.

.. GENERATED FROM PYTHON SOURCE LINES 80-82

.. code-block:: Python

    polyColl = [univariateFactory] * dimension








.. GENERATED FROM PYTHON SOURCE LINES 83-86

.. code-block:: Python

    enumerateFunction = ot.LinearEnumerateFunction(dimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 87-94

.. code-block:: Python

    functions = []
    numberOfTrendCoefficients = 12
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    1.73205 * x0 * 1.73205 * x1
    1.73205 * x0 * 1.73205 * x2
    1.73205 * x0 * 1.73205 * x3
    -1.11803 + 3.3541 * x1^2
    1.73205 * x1 * 1.73205 * x2
    1.73205 * x1 * 1.73205 * x3




.. GENERATED FROM PYTHON SOURCE LINES 95-97

.. code-block:: Python

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 98-100

Create the metamodel
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 102-107

In order to create the kriging metamodel, we first select a constant trend
with the `ConstantBasisFactory` class.
Then we use a squared exponential covariance model.
Finally, we use the `KrigingAlgorithm` class to create the kriging metamodel,
taking the training sample, the covariance model and the trend basis as input arguments.

.. GENERATED FROM PYTHON SOURCE LINES 109-111

.. code-block:: Python

    covarianceModel = ot.SquaredExponential([1.0] * dimension, [1.0])








.. GENERATED FROM PYTHON SOURCE LINES 112-117

.. code-block:: Python

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 118-119

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 121-123

.. code-block:: Python

    result.getTrendCoefficients()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=12 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 124-125

We see that the number of coefficients in the trend corresponds to the number of functions in the basis.

.. GENERATED FROM PYTHON SOURCE LINES 127-129

.. code-block:: Python

    result.getCovarianceModel()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>SquaredExponential(scale=[1,1,0.163904,0.01], amplitude=[0.0316491])</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 130-132

The `SquaredExponential` model has one amplitude coefficient and 4 scale coefficients.
This is because this covariance model is anisotropic : each of the 4 input variables is associated with its own scale coefficient.

.. GENERATED FROM PYTHON SOURCE LINES 134-136

Create an orthogonal multivariate polynomial factory
----------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 138-145

In order to create a Legendre basis which better corresponds to the input marginals, we could consider the orthogonal basis which would be associated to uniform marginals.
To compute the bounds of these uniform distributions, we may consider the 1% and 99% quantiles of each marginal.

There is, however, a simpler way to proceed. We can simply orthogonalize the input marginals and create the orthogonal polynomial basis corresponding to the inputs.
This corresponds to the method we would use in the polynomial chaos.

We first create the polynomial basis which corresponds to the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 147-149

.. code-block:: Python

    multivariateBasis = ot.OrthogonalProductPolynomialFactory([cb.E, cb.F, cb.L, cb.II])








.. GENERATED FROM PYTHON SOURCE LINES 150-151

Then we create the multivariate basis which has maximum degree equal to 2.

.. GENERATED FROM PYTHON SOURCE LINES 153-158

.. code-block:: Python

    totalDegree = 2
    enumerateFunction = multivariateBasis.getEnumerateFunction()
    numberOfTrendCoefficients = enumerateFunction.getStrataCumulatedCardinal(totalDegree)
    numberOfTrendCoefficients





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    15



.. GENERATED FROM PYTHON SOURCE LINES 159-165

.. code-block:: Python

    functions = []
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    1.73205 * x0 * 1.73205 * x1
    1.73205 * x0 * 1.73205 * x2
    1.73205 * x0 * 1.73205 * x3
    -1.11803 + 3.3541 * x1^2
    1.73205 * x1 * 1.73205 * x2
    1.73205 * x1 * 1.73205 * x3
    -1.11803 + 3.3541 * x2^2
    1.73205 * x2 * 1.73205 * x3
    -1.11803 + 3.3541 * x3^2




.. GENERATED FROM PYTHON SOURCE LINES 166-168

.. code-block:: Python

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 169-174

.. code-block:: Python

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 175-176

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 178-180

.. code-block:: Python

    result.getTrendCoefficients()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=15 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50,1.39896e-44,7.63508e-52,-7.60276e-46]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 181-192

Conclusion
----------

The trend that we have configured corresponds to the basis that we would have used in a full polynomial chaos computed with least squares.

Other extensions of this work would be:

* to use a Fourier basis with `FourierSeriesFactory`,
* wavelets with `HaarWaveletFactory`,

or any other univariate factory.


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_kriging_beam_arbitrary_trend.ipynb <plot_kriging_beam_arbitrary_trend.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_kriging_beam_arbitrary_trend.py <plot_kriging_beam_arbitrary_trend.py>`
