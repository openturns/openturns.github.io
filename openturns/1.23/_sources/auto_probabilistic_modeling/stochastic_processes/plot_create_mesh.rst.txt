
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/stochastic_processes/plot_create_mesh.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_mesh.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_stochastic_processes_plot_create_mesh.py:


Create a mesh
=============

.. GENERATED FROM PYTHON SOURCE LINES 6-14

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    import math as m

    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 15-32

Creation of a regular grid
--------------------------

In this first part we demonstrate how to create a regular grid. Note that a regular grid is a particular mesh of :math:`\mathcal{D}=[0,T] \in \mathbb{R}`.

Here we assume it represents the time :math:`t` as it is often the case, but it can represent any physical quantity.

A regular time grid is a regular discretization of the interval :math:`[0, T] \in \mathbb{R}` into :math:`N` points, noted :math:`(t_0, \dots, t_{N-1})`.

The time grid can be defined using :math:`(t_{Min}, \Delta t, N)` where :math:`N` is the number of points in the time grid.
:math:`\Delta t` the time step between two consecutive instants and :math:`t_0 = t_{Min}`.
Then, :math:`t_k = t_{Min} + k \Delta t` and :math:`t_{Max} = t_{Min} +  (N-1) \Delta t`.


Consider :math:`X: \Omega \times \mathcal{D} \rightarrow \mathbb{R}^d` a multivariate stochastic process of dimension :math:`d`,
where :math:`n=1`, :math:`\mathcal{D}=[0,T]` and :math:`t\in \mathcal{D}` is interpreted as a time stamp.
Then the mesh associated to the process :math:`X` is a (regular) time grid.

.. GENERATED FROM PYTHON SOURCE LINES 35-36

We define a time grid from a starting time `tMin`, a time step `tStep` and a number of time steps `n`.

.. GENERATED FROM PYTHON SOURCE LINES 36-41

.. code-block:: Python

    tMin = 0.0
    tStep = 0.1
    n = 10
    time_grid = ot.RegularGrid(tMin, tStep, n)








.. GENERATED FROM PYTHON SOURCE LINES 42-43

We get the first and the last instants, the step and the number of points :

.. GENERATED FROM PYTHON SOURCE LINES 43-49

.. code-block:: Python

    start = time_grid.getStart()
    step = time_grid.getStep()
    grid_size = time_grid.getN()
    end = time_grid.getEnd()
    print("start=", start, "step=", step, "grid_size=", grid_size, "end=", end)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    start= 0.0 step= 0.1 grid_size= 10 end= 1.0




.. GENERATED FROM PYTHON SOURCE LINES 50-51

We draw the grid.

.. GENERATED FROM PYTHON SOURCE LINES 51-59

.. code-block:: Python

    time_grid.setName("time")
    graph = time_grid.draw()
    graph.setTitle("Time grid")
    graph.setXTitle("t")
    graph.setYTitle("")
    view = viewer.View(graph)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_001.png
   :alt: Time grid
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 60-62

Creation of a mesh
------------------

.. GENERATED FROM PYTHON SOURCE LINES 64-74

In this paragraph we create a mesh :math:`\mathcal{M}` associated to a domain :math:`\mathcal{D} \in \mathbb{R}^n`.

A mesh is defined from vertices in :math:`\mathbb{R}^n` and a topology that connects the vertices: the simplices.
The simplex :math:`Indices([i_1,\dots, i_{n+1}])` relies the vertices of index :math:`(i_1,\dots, i_{n+1})` in :math:`\mathbb{N}^n`.
In dimension 1, a simplex is an interval :math:`Indices([i_1,i_2])`; in dimension 2, it is a triangle :math:`Indices([i_1,i_2, i_3])`.

The library enables to easily create a mesh which is a box of dimension :math:`d=1` or :math:`d=2` regularly meshed in all its directions, thanks to the object IntervalMesher.

Consider :math:`X: \Omega \times \mathcal{D} \rightarrow \mathbb{R}^d` a multivariate stochastic process of dimension :math:`d`, where :math:`\mathcal{D} \in \mathbb{R}^n`.
The mesh :math:`\mathcal{M}` is a discretization of the domain :math:`\mathcal{D}`.

.. GENERATED FROM PYTHON SOURCE LINES 76-77

A  one dimensional mesh is created and represented by :

.. GENERATED FROM PYTHON SOURCE LINES 77-84

.. code-block:: Python

    vertices = [[0.5], [1.5], [2.1], [2.7]]
    simplicies = [[0, 1], [1, 2], [2, 3]]
    mesh1D = ot.Mesh(vertices, simplicies)
    graph1 = mesh1D.draw()
    graph1.setTitle("One dimensional mesh")
    view = viewer.View(graph1)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_002.png
   :alt: One dimensional mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 85-86

We define a bidimensional mesh :

.. GENERATED FROM PYTHON SOURCE LINES 86-94

.. code-block:: Python

    vertices = [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [1.5, 1.0], [2.0, 1.5], [0.5, 1.5]]
    simplicies = [[0, 1, 2], [1, 2, 3], [2, 3, 4], [2, 4, 5], [0, 2, 5]]
    mesh2D = ot.Mesh(vertices, simplicies)
    graph2 = mesh2D.draw()
    graph2.setTitle("Bidimensional mesh")
    graph2.setLegendPosition("lower right")
    view = viewer.View(graph2)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_003.png
   :alt: Bidimensional mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 95-97

We can also define a mesh which is a regularly meshed box in dimension 1 or 2.
We define the number of intervals in each direction of the box :

.. GENERATED FROM PYTHON SOURCE LINES 97-100

.. code-block:: Python

    myIndices = [5, 10]
    myMesher = ot.IntervalMesher(myIndices)








.. GENERATED FROM PYTHON SOURCE LINES 101-102

We then create the mesh of the box :math:`[0, 2] \times [0, 4]` :

.. GENERATED FROM PYTHON SOURCE LINES 102-110

.. code-block:: Python

    lowerBound = [0.0, 0.0]
    upperBound = [2.0, 4.0]
    myInterval = ot.Interval(lowerBound, upperBound)
    myMeshBox = myMesher.build(myInterval)
    mygraph3 = myMeshBox.draw()
    mygraph3.setTitle("Bidimensional mesh on a box")
    view = viewer.View(mygraph3)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_004.png
   :alt: Bidimensional mesh on a box
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 111-112

It is possible to perform a transformation on a regularly meshed box.

.. GENERATED FROM PYTHON SOURCE LINES 112-120

.. code-block:: Python

    myIndices = [20, 20]
    mesher = ot.IntervalMesher(myIndices)
    # r in [1., 2.] and theta in (0., pi]
    lowerBound2 = [1.0, 0.0]
    upperBound2 = [2.0, m.pi]
    myInterval = ot.Interval(lowerBound2, upperBound2)
    meshBox2 = mesher.build(myInterval)








.. GENERATED FROM PYTHON SOURCE LINES 121-122

We define the mapping function and draw the transformation :

.. GENERATED FROM PYTHON SOURCE LINES 122-131

.. code-block:: Python

    f = ot.SymbolicFunction(["r", "theta"], ["r*cos(theta)", "r*sin(theta)"])
    oldVertices = meshBox2.getVertices()
    newVertices = f(oldVertices)
    meshBox2.setVertices(newVertices)
    graphMappedBox = meshBox2.draw()
    graphMappedBox.setTitle("Mapped box mesh")
    view = viewer.View(graphMappedBox)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_005.png
   :alt: Mapped box mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 132-133

Finally we create a mesh of a heart in dimension 2.

.. GENERATED FROM PYTHON SOURCE LINES 133-175

.. code-block:: Python

    def meshHeart(ntheta, nr):
        # First, build the nodes
        nodes = ot.Sample(0, 2)
        nodes.add([0.0, 0.0])
        for j in range(ntheta):
            theta = (m.pi * j) / ntheta
            if abs(theta - 0.5 * m.pi) < 1e-10:
                rho = 2.0
            elif (abs(theta) < 1e-10) or (abs(theta - m.pi) < 1e-10):
                rho = 0.0
            else:
                absTanTheta = abs(m.tan(theta))
                rho = absTanTheta ** (1.0 / absTanTheta) + m.sin(theta)
            cosTheta = m.cos(theta)
            sinTheta = m.sin(theta)
            for k in range(nr):
                tau = (k + 1.0) / nr
                r = rho * tau
                nodes.add([r * cosTheta, r * sinTheta - tau])
        # Second, build the triangles
        triangles = []
        # First heart
        for j in range(ntheta):
            triangles.append([0, 1 + j * nr, 1 + ((j + 1) % ntheta) * nr])
        # Other hearts
        for j in range(ntheta):
            for k in range(nr - 1):
                i0 = k + 1 + j * nr
                i1 = k + 2 + j * nr
                i2 = k + 2 + ((j + 1) % ntheta) * nr
                i3 = k + 1 + ((j + 1) % ntheta) * nr
                triangles.append([i0, i1, i2 % (nr * ntheta)])
                triangles.append([i0, i2, i3 % (nr * ntheta)])
        return ot.Mesh(nodes, triangles)


    mesh4 = meshHeart(48, 16)
    graphMesh = mesh4.draw()
    graphMesh.setTitle("Bidimensional mesh")
    graphMesh.setLegendPosition("")
    view = viewer.View(graphMesh)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_006.png
   :alt: Bidimensional mesh
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_mesh_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 176-177

Display figures

.. GENERATED FROM PYTHON SOURCE LINES 177-178

.. code-block:: Python

    plt.show()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.393 seconds)


.. _sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_mesh.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_mesh.ipynb <plot_create_mesh.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_mesh.py <plot_create_mesh.py>`
