
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/stochastic_processes/plot_mix_rv_process.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_mix_rv_process.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_stochastic_processes_plot_mix_rv_process.py:


Create a process from random vectors and processes
==================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-23

The objective is to create a process defined from a random vector and a process.

We consider the following limit state function, defined as the difference between a degrading resistance :math:`r(t) = R - bt` and a time-varying load :math:`S(t)`:

.. math::
   \begin{align*}
   g(t)= r(t) - S(t) = R - bt - S(t)
   \end{align*}

We propose the following probabilistic model:

- :math:`R` is the initial resistance, and :math:`R \sim \mathcal{N}(\mu_R, \sigma_R)`;
- :math:`b` is the deterioration rate of the resistance; it is deterministic;
- :math:`S(t)` is the time-varying stress, which is modeled by a stationary Gaussian process of mean value :math:`\mu_S`,
  standard deviation :math:`\sigma_S` and a squared exponential covariance model;
- :math:`t` is the time, varying in :math:`[0,T]`.


.. GENERATED FROM PYTHON SOURCE LINES 26-27

First, import the python modules:

.. GENERATED FROM PYTHON SOURCE LINES 29-33

.. code-block:: Python

    import openturns as ot
    from openturns.viewer import View
    import math as m








.. GENERATED FROM PYTHON SOURCE LINES 34-36

1. Create the gaussian process :math:`(\omega, t) \rightarrow S(\omega,t)`
--------------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 38-39

Create the mesh which is a regular grid on :math:`[0,T]`, with :math:`T=50`, by step =1:

.. GENERATED FROM PYTHON SOURCE LINES 41-48

.. code-block:: Python

    b = 0.01
    t0 = 0.0
    step = 1
    tfin = 50
    n = round((tfin - t0) / step)
    myMesh = ot.RegularGrid(t0, step, n)








.. GENERATED FROM PYTHON SOURCE LINES 49-56

Create the squared exeponential covariance model:

.. math::
   C(s,t) = \sigma^2e^{-\frac{1}{2} \left( \dfrac{s-t}{l} \right)^2}

where the scale parameter is :math:`l=\frac{10}{\sqrt{2}}` and the amplitude :math:`\sigma = 1`.


.. GENERATED FROM PYTHON SOURCE LINES 58-62

.. code-block:: Python

    ll = 10 / m.sqrt(2)
    myCovKernel = ot.SquaredExponential([ll])
    print("cov model = ", myCovKernel)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    cov model =  SquaredExponential(scale=[7.07107], amplitude=[1])




.. GENERATED FROM PYTHON SOURCE LINES 63-64

Create the gaussian process :math:`S(t)`:

.. GENERATED FROM PYTHON SOURCE LINES 66-69

.. code-block:: Python

    S_proc = ot.GaussianProcess(myCovKernel, myMesh)









.. GENERATED FROM PYTHON SOURCE LINES 70-72

2. Create the process :math:`(\omega, t) \rightarrow R(\omega)-bt`
------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 74-75

First, create the random variable :math:`R \sim \mathcal{N}(\mu_R, \sigma_R)`, with :math:`\mu_R = 5` and :math:`\sigma_R = 0.3`:

.. GENERATED FROM PYTHON SOURCE LINES 77-81

.. code-block:: Python

    muR = 5
    sigR = 0.3
    R = ot.Normal(muR, sigR)








.. GENERATED FROM PYTHON SOURCE LINES 82-83

The create the Dirac random variable :math:`B = b`:

.. GENERATED FROM PYTHON SOURCE LINES 85-87

.. code-block:: Python

    B = ot.Dirac(b)








.. GENERATED FROM PYTHON SOURCE LINES 88-95

Then create the process :math:`(\omega, t) \rightarrow R(\omega)-bt` using the :math:`FunctionalBasisProcess` class
and the functional basis :math:`\phi_1 : t \rightarrow 1` and :math:`\phi_2: -t \rightarrow t`:

.. math::
   R(\omega)-bt = R(\omega)\phi_1(t) + B(\omega) \phi_2(t)

with :math:`(R,B)` independent.

.. GENERATED FROM PYTHON SOURCE LINES 97-105

.. code-block:: Python

    const_func = ot.SymbolicFunction(["t"], ["1"])
    linear_func = ot.SymbolicFunction(["t"], ["-t"])
    myBasis = ot.Basis([const_func, linear_func])

    coef = ot.JointDistribution([R, B])

    R_proc = ot.FunctionalBasisProcess(coef, myBasis, myMesh)








.. GENERATED FROM PYTHON SOURCE LINES 106-108

3. Create the process :math:`Z: (\omega, t) \rightarrow R(\omega)-bt + S(\omega, t)`
------------------------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 110-111

First, aggregate both processes into one process of dimension 2: :math:`(R_{proc}, S_{proc})`

.. GENERATED FROM PYTHON SOURCE LINES 113-115

.. code-block:: Python

    myRS_proc = ot.AggregatedProcess([R_proc, S_proc])








.. GENERATED FROM PYTHON SOURCE LINES 116-127

Then create the spatial field function that acts only on the values of the process, keeping the mesh unchanged, using the *ValueFunction* class.
We define the function :math:`g` on :math:`\mathbb{R}^2` by:

.. math::
   g(x,y) = x-y

in order to define the spatial field function :math:`g_{dyn}` that acts on fields, defined by:

.. math::
   \forall t\in [0,T], g_{dyn}(X(\omega, t), Y(\omega, t)) = X(\omega, t) - Y(\omega, t)


.. GENERATED FROM PYTHON SOURCE LINES 129-132

.. code-block:: Python

    g = ot.SymbolicFunction(["x1", "x2"], ["x1-x2"])
    gDyn = ot.ValueFunction(g, myMesh)








.. GENERATED FROM PYTHON SOURCE LINES 133-134

Now you have to create the final process :math:`Z` thanks to :math:`g_{dyn}`:

.. GENERATED FROM PYTHON SOURCE LINES 136-138

.. code-block:: Python

    Z_proc = ot.CompositeProcess(gDyn, myRS_proc)








.. GENERATED FROM PYTHON SOURCE LINES 139-141

4. Draw some realizations of the process
----------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 143-149

.. code-block:: Python

    N = 10
    sampleZ_proc = Z_proc.getSample(N)
    graph = sampleZ_proc.drawMarginal(0)
    graph.setTitle(r"Some realizations of $Z(\omega, t)$")
    view = View(graph)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_mix_rv_process_001.png
   :alt: Some realizations of $Z(\omega, t)$
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_mix_rv_process_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 150-152

5. Evaluate the probability that :math:`Z(\omega, t) \in \mathcal{D}`
---------------------------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 154-155

We define the domaine :math:`\mathcal{D} = [2,4]` and the event :math:`Z(\omega, t) \in \mathcal{D}`:

.. GENERATED FROM PYTHON SOURCE LINES 157-161

.. code-block:: Python

    domain = ot.Interval([2], [4])
    print("D = ", domain)
    event = ot.ProcessEvent(Z_proc, domain)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    D =  [2, 4]




.. GENERATED FROM PYTHON SOURCE LINES 162-163

We use the Monte Carlo sampling to evaluate the probability:

.. GENERATED FROM PYTHON SOURCE LINES 165-181

.. code-block:: Python

    MC_algo = ot.ProbabilitySimulationAlgorithm(event)
    MC_algo.setMaximumOuterSampling(1000000)
    MC_algo.setBlockSize(100)
    MC_algo.setMaximumCoefficientOfVariation(0.01)
    MC_algo.run()

    result = MC_algo.getResult()

    proba = result.getProbabilityEstimate()
    print("Probability = ", proba)
    variance = result.getVarianceEstimate()
    print("Variance Estimate = ", variance)
    IC90_low = proba - result.getConfidenceLength(0.90) / 2
    IC90_upp = proba + result.getConfidenceLength(0.90) / 2
    print("IC (90%) = [", IC90_low, ", ", IC90_upp, "]")
    view.ShowAll()




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Probability =  0.7572727272727273
    Variance Estimate =  5.625950969752621e-05
    IC (90%) = [ 0.7449352823106309 ,  0.7696101722348238 ]





.. _sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_mix_rv_process.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_mix_rv_process.ipynb <plot_mix_rv_process.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_mix_rv_process.py <plot_mix_rv_process.py>`
