
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/distributions/plot_python_distribution.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_distributions_plot_python_distribution.py:


Create a customized distribution or copula
==========================================

.. GENERATED FROM PYTHON SOURCE LINES 6-15

In this example we are going to create a distribution or copula.

The way to go is inheriting the PythonDistribution class and overload the methods of the Distribution object.

To create a Copula, the user has to overload isCopula() and return True.

Then an instance of the new class can be passed on into a Distribution object.

At least computeCDF should be overridden.

.. GENERATED FROM PYTHON SOURCE LINES 17-27

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt
    import math as m
    import warnings

    warnings.filterwarnings("ignore")
    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 28-29

Inherit PythonDistribution :

.. GENERATED FROM PYTHON SOURCE LINES 32-138

.. code-block:: Python

    class UniformNdPy(ot.PythonDistribution):
        def __init__(self, a=[0.0], b=[1.0]):
            super(UniformNdPy, self).__init__(len(a))
            if len(a) != len(b):
                raise ValueError("Invalid bounds")
            for i in range(len(a)):
                if a[i] > b[i]:
                    raise ValueError("Invalid bounds")
            self.a = a
            self.b = b
            self.factor = 1.0
            for i in range(len(a)):
                self.factor *= b[i] - a[i]

        def getRange(self):
            return ot.Interval(self.a, self.b, [True] * len(self.a), [True] * len(self.a))

        def getRealization(self):
            X = []
            for i in range(len(self.a)):
                X.append(
                    self.a[i] + (self.b[i] - self.a[i]) * ot.RandomGenerator.Generate()
                )
            return X

        def getSample(self, size):
            X = []
            for i in range(size):
                X.append(self.getRealization())
            return X

        def computeCDF(self, X):
            prod = 1.0
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                prod *= min(self.b[i], X[i]) - self.a[i]
            return prod / self.factor

        def computePDF(self, X):
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                if X[i] > self.b[i]:
                    return 0.0
            return 1.0 / self.factor

        def getMean(self):
            mu = []
            for i in range(len(self.a)):
                mu.append(0.5 * (self.a[i] + self.b[i]))
            return mu

        def getStandardDeviation(self):
            stdev = []
            for i in range(len(self.a)):
                stdev.append((self.b[i] - self.a[i]) / m.sqrt(12.0))
            return stdev

        def getSkewness(self):
            return [0.0] * len(self.a)

        def getKurtosis(self):
            return [1.8] * len(self.a)

        def getMoment(self, n):
            return [-0.1 * n] * len(self.a)

        def getCentralMoment(self, n):
            return [0.0] * len(self.a)

        def computeCharacteristicFunction(self, x):
            if len(self.a) > 1:
                raise ValueError("dim>1")
            ax = self.a[0] * x
            bx = self.b[0] * x
            return (m.sin(bx) - m.sin(ax) + 1j * (m.cos(ax) - m.cos(bx))) / (bx - ax)

        def isElliptical(self):
            return (len(self.a) == 1) and (self.a[0] == -self.b[0])

        def isCopula(self):
            for i in range(len(self.a)):
                if self.a[i] != 0.0:
                    return False
                if self.b[i] != 1.0:
                    return False
            return True

        def getMarginal(self, indices):
            subA = []
            subB = []
            for i in indices:
                subA.append(self.a[i])
                subB.append(self.b[i])
            py_dist = UniformNdPy(subA, subB)
            return ot.Distribution(py_dist)

        def computeQuantile(self, prob, tail=False):
            q = 1.0 - prob if tail else prob
            quantile = self.a
            for i in range(len(self.a)):
                quantile[i] += q * (self.b[i] - self.a[i])
            return quantile









.. GENERATED FROM PYTHON SOURCE LINES 139-140

Let us instantiate the distribution:

.. GENERATED FROM PYTHON SOURCE LINES 142-144

.. code-block:: Python

    distribution = ot.Distribution(UniformNdPy([5, 6], [7, 9]))








.. GENERATED FROM PYTHON SOURCE LINES 145-146

And plot the `cdf`:

.. GENERATED FROM PYTHON SOURCE LINES 148-152

.. code-block:: Python

    graph = distribution.drawCDF()
    graph.setColors(["blue"])
    view = viewer.View(graph)




.. image-sg:: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.png
   :alt: [X0,X1] iso-CDF
   :srcset: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 153-154

We can easily generate sample:

.. GENERATED FROM PYTHON SOURCE LINES 156-158

.. code-block:: Python

    distribution.getSample(5)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
      <tr><td></td><th>v0</th><th>v1</th></tr>
      <tr><th>0</th><td>6.607829</td><td>8.668381</td></tr>
      <tr><th>1</th><td>6.856661</td><td>8.081292</td></tr>
      <tr><th>2</th><td>5.037569</td><td>7.852766</td></tr>
      <tr><th>3</th><td>6.672036</td><td>6.17118</td></tr>
      <tr><th>4</th><td>6.027888</td><td>8.788813</td></tr>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 159-160

or compute the `mean`:

.. GENERATED FROM PYTHON SOURCE LINES 162-164

.. code-block:: Python

    distribution.getMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=2 values=[6,7.5]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 165-166

Also we can compute the probability contained in an interval :

.. GENERATED FROM PYTHON SOURCE LINES 168-170

.. code-block:: Python

    distribution.computeProbability(ot.Interval([5.5, 6], [8.5, 9]))
    plt.show()







.. GENERATED FROM PYTHON SOURCE LINES 171-172

And do more (see `Distribution` for all methods)


.. _sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_python_distribution.ipynb <plot_python_distribution.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_python_distribution.py <plot_python_distribution.py>`
