
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_functional_modeling/vectorial_functions/plot_functions_outputDim.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_functional_modeling_vectorial_functions_plot_functions_outputDim.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_functional_modeling_vectorial_functions_plot_functions_outputDim.py:


===========================================
Increase the output dimension of a function
===========================================

.. GENERATED FROM PYTHON SOURCE LINES 7-36

Description
===========

We want to build a function :math:`f : \mathbb{R}^d \mapsto \mathbb{R}^q` from *q* functions :math:`f_i: \mathbb{R}^d \mapsto \mathbb{R}`.

We can do that:

- Case 1: by aggregation  of the functions :math:`f_i`,
- Case 2: by creating a vectorial linear combination  of the functions :math:`f_i`.

Case 1: Aggregation
===================

We have :math:`q` functions :math:`f_i : \mathbb{R}^d \mapsto \mathbb{R}` for :math:`1 \leq i \leq q`.
We create the function  :math:`f : \mathbb{R}^d \mapsto \mathbb{R}^q` defined by:

.. math::

    f(\vect{x}) =
      \begin{pmatrix}
        f_1(\vect{x}) \\
        \vdots \\
        f_q(\vect{x})
      \end{pmatrix}


We use the :class:`~openturns.AggregatedFunction` class.

In the example, we take :math:`d=2` and :math:`q=3`.

.. GENERATED FROM PYTHON SOURCE LINES 36-47

.. code-block:: Python

    import openturns as ot

    f1 = ot.SymbolicFunction(["x1", "x2"], ["x1^2+x2"])
    f2 = ot.SymbolicFunction(["x1", "x2"], ["x1+x2^2"])
    f3 = ot.SymbolicFunction(["x1", "x2"], ["x1+x2"])
    func_coll = [f1, f2, f3]
    f = ot.AggregatedFunction(func_coll)
    print("input dimension =", f.getInputDimension())
    print("output dimension =", f.getOutputDimension())
    print("f = ", f)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input dimension = 2
    output dimension = 3
    f =  [[x1,x2]->[x1^2+x2],[x1,x2]->[x1+x2^2],[x1,x2]->[x1+x2]]




.. GENERATED FROM PYTHON SOURCE LINES 48-62

Case 2: Vectorial linear combination
====================================

We have :math:`q` functions :math:`f_i : \mathbb{R}^d \mapsto \mathbb{R}` for :math:`1 \leq i \leq q`.
We create the function  :math:`f : \mathbb{R}^d \mapsto \mathbb{R}^q` defined by:

.. math::

    f(\vect{x}) = \sum_{i=1}^q \vect{c}_i f_i(\vect{x})

where :math:`\vect{c}_i \in \mathbb{R} ^q`.

We use the :class:`~openturns.DualLinearCombinationFunction` class.
In the example, we take :math:`d=2` and :math:`q=3`.

.. GENERATED FROM PYTHON SOURCE LINES 62-71

.. code-block:: Python


    c1 = [2.0, 3.0, 4.0]
    c2 = [5.0, 6.0, 7.0]
    c3 = [8.0, 9.0, 10.0]
    coef_list = [c1, c2, c3]
    f = ot.DualLinearCombinationFunction(func_coll, coef_list)
    print("input dimension =", f.getInputDimension())
    print("output dimension =", f.getOutputDimension())
    print("f = ", f)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    input dimension = 2
    output dimension = 3
    f =  [2,3,4] * ([x1,x2]->[x1^2+x2]) + [5,6,7] * ([x1,x2]->[x1+x2^2]) + [8,9,10] * ([x1,x2]->[x1+x2])





.. _sphx_glr_download_auto_functional_modeling_vectorial_functions_plot_functions_outputDim.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_functions_outputDim.ipynb <plot_functions_outputDim.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_functions_outputDim.py <plot_functions_outputDim.py>`
