
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_stochastic_processes/plot_create_and_manipulate_arma_process.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_stochastic_processes_plot_create_and_manipulate_arma_process.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_stochastic_processes_plot_create_and_manipulate_arma_process.py:


Create and manipulate an ARMA process
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 7-9

In this example we first create an ARMA process and then manipulate it.


.. GENERATED FROM PYTHON SOURCE LINES 11-14

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as otv








.. GENERATED FROM PYTHON SOURCE LINES 15-46

Create an ARMA process
----------------------

In this example we are going to build an ARMA process defined by its linear recurrence coefficients.

The creation of an ARMA model requires the data of the AR and MA
coefficients which are:

-  a list of scalars in the unidmensional case :
   :math:`(a_1, \dots, a_p)` for the AR-coefficients and
   :math:`(b_1, \dots, b_q)` for the MA-coefficients

-  a list of square matrix
   :math:`(\mat{A}_{\, 1}, \dots, \mat{A}{\, _p})` for the
   AR-coefficients and
   :math:`(\mat{B}_{\, 1}\, \dots, \mat{B}_{\, q})` for the
   MA-coefficients

It also requires the definition of a white noise
:math:`\vect{\varepsilon}` that contains the same time grid as the
one of the process.
The current state of an ARMA model is characterized by its last
:math:`p` values and the last :math:`q` values of its white noise. It
is possible to get that state thanks to the methods `getState`.
It is possible to create an ARMA with a specific current state. That
specific current state is taken into account to generate possible
futures but not to generate realizations (in order to respect the
stationarity property of the model).
At the creation step, we check whether the process
:math:`ARMA(p,q)` is stationnary.
When the process is not stationary, the user is warned by a message.

.. GENERATED FROM PYTHON SOURCE LINES 48-55

We build the 1-d ARMA process defined by:

.. math::
   X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}

where the white noise :math:`E_t` is defined by :math:`E_t \approx \mathrm{Triangular}(a = -1, m = 0, b = 1)`.


.. GENERATED FROM PYTHON SOURCE LINES 57-58

The definition of the recurrence coefficients ARMA (4,2) is simple:

.. GENERATED FROM PYTHON SOURCE LINES 58-62

.. code-block:: Python

    myARCoef = ot.ARMACoefficients([0.4, 0.3, 0.2, 0.1])
    myMACoef = ot.ARMACoefficients([0.4, 0.3])









.. GENERATED FROM PYTHON SOURCE LINES 63-65

We build a regular time discretization of the interval [0,1] with 10 time steps.
We also set up the white noise distribution of the recurrence relation :

.. GENERATED FROM PYTHON SOURCE LINES 65-68

.. code-block:: Python

    myTimeGrid = ot.RegularGrid(0.0, 0.1, 10)
    myWhiteNoise = ot.WhiteNoise(ot.Triangular(-1.0, 0.0, 1.0), myTimeGrid)








.. GENERATED FROM PYTHON SOURCE LINES 69-70

We are now ready to create the ARMA-process :

.. GENERATED FROM PYTHON SOURCE LINES 70-74

.. code-block:: Python

    process = ot.ARMA(myARCoef, myMACoef, myWhiteNoise)
    print(process)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA(X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}, E_t ~ Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 75-100

ARMA process manipulation
-------------------------

In this paragraph we shall expose some of the services exposed by an :math:`ARMA(p,q)` object, namely :

-  its AR and MA coefficients thanks to the methods `getARCoefficients`,
   `getMACoefficients`,

-  its white noise thanks to the method `getWhiteNoise`, that contains
   the time grid of the process,

-  its current state, that is its last :math:`p` values and the last
   :math:`q` values of its white noise, thanks to the method `getState`,

-  a realization thanks to the method `getRealization` or a sample of realizations thanks to the method `getSample`,

-  a possible future of the model, which is a possible extension of
   the current state on the next :math:`n_{prol}` instants, thanks to
   the method `getFuture`.

-  :math:`n` possible futures of the model, which correspond to
   :math:`n` possible prolongations of the current state on the next
   :math:`n_{prol}` instants, thanks to the method
   `getFuture` (:math:`n_{prol}`, :math:`n`).


.. GENERATED FROM PYTHON SOURCE LINES 103-104

First we get the coefficients AR and MA of the recurrence :

.. GENERATED FROM PYTHON SOURCE LINES 104-107

.. code-block:: Python

    print("AR coeff = ", process.getARCoefficients())
    print("MA coeff = ", process.getMACoefficients())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    AR coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]
    shift = 2
    [[ 0.2 ]]
    shift = 3
    [[ 0.1 ]]

    MA coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]





.. GENERATED FROM PYTHON SOURCE LINES 108-109

We check that the white noise is the one we have previously defined :

.. GENERATED FROM PYTHON SOURCE LINES 109-113

.. code-block:: Python

    myWhiteNoise = process.getWhiteNoise()
    print(myWhiteNoise)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    WhiteNoise(Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 114-115

We generate a possible time series realization :

.. GENERATED FROM PYTHON SOURCE LINES 115-118

.. code-block:: Python

    ts = process.getRealization()
    ts.setName("ARMA realization")








.. GENERATED FROM PYTHON SOURCE LINES 119-120

We draw this time series by specifying the wanted marginal index (only 0 is available here).

.. GENERATED FROM PYTHON SOURCE LINES 120-127

.. code-block:: Python

    graph0 = ts.drawMarginal(0)
    graph0.setTitle("One ARMA realization")
    graph0.setXTitle("t")
    graph0.setYTitle(r"$X_t$")
    view = otv.View(graph0)





.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.svg
   :alt: One ARMA realization
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 128-131

Generate a k time series
k = 5
myProcessSample = process.getSample(k)

.. GENERATED FROM PYTHON SOURCE LINES 131-137

.. code-block:: Python


    # Then get the current state of the ARMA
    # armaState = process.getState()
    # print("armaState = ")
    # print(armaState)








.. GENERATED FROM PYTHON SOURCE LINES 138-139

We draw a sample of size 6 : it is six different time series.

.. GENERATED FROM PYTHON SOURCE LINES 139-152

.. code-block:: Python

    size = 6
    sample = process.getSample(size)
    graph = sample.drawMarginal(0)
    graph.setTitle("Six realizations of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = otv.View(graph)

    # We can obtain the current state of the ARMA process :
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)




.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.svg
   :alt: Six realizations of the ARMA process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.svg
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[-0.13028]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[-0.868465]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[-0.0128748]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[0.421732]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[-0.0152444]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[0.392247]




.. GENERATED FROM PYTHON SOURCE LINES 153-154

Note that if we use the process in the meantime and ask for the current state again, it will be different.

.. GENERATED FROM PYTHON SOURCE LINES 154-167

.. code-block:: Python

    ts = process.getRealization()
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)


    # From the aforementioned `armaState`, we can get the last values of :math:`X_t` and the last values
    # of the white noise :math:`E_t`.
    myLastValues = armaState.getX()
    print(myLastValues)
    myLastEpsilonValues = armaState.getEpsilon()
    print(myLastEpsilonValues)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[0.437017]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[0.305822]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[-0.290839]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[-0.460089]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[-0.178082]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[-0.378829]
    0 : [  0.437017 ]
    1 : [  0.305822 ]
    2 : [ -0.290839 ]
    3 : [ -0.460089 ]
    0 : [ -0.178082 ]
    1 : [ -0.378829 ]




.. GENERATED FROM PYTHON SOURCE LINES 168-169

We have access to the number of iterations before getting a stationary state with

.. GENERATED FROM PYTHON SOURCE LINES 169-172

.. code-block:: Python

    Ntherm = process.getNThermalization()
    print("ThermalValue : %d" % Ntherm)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ThermalValue : 75




.. GENERATED FROM PYTHON SOURCE LINES 173-174

This may be important to evaluate it with another precision epsilon :

.. GENERATED FROM PYTHON SOURCE LINES 174-179

.. code-block:: Python

    epsilon = 1e-8
    newThermalValue = process.computeNThermalization(epsilon)
    print("newThermalValue : %d" % newThermalValue)
    process.setNThermalization(newThermalValue)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    newThermalValue : 38




.. GENERATED FROM PYTHON SOURCE LINES 180-181

An important feature of an ARMA process is the future prediction from its current state over the next  `Nit` instants, say `Nit=20`.

.. GENERATED FROM PYTHON SOURCE LINES 181-183

.. code-block:: Python

    Nit = 21








.. GENERATED FROM PYTHON SOURCE LINES 184-185

First we specify a current state `armaState` and build the corresponding ARMA process `arma` :

.. GENERATED FROM PYTHON SOURCE LINES 185-200

.. code-block:: Python

    arma = ot.ARMA(myARCoef, myMACoef, myWhiteNoise, armaState)

    # Then, we generate a possible future. The last instant was :math:`t=0.9` so the future starts at
    # :math:`t=1.0`. We represent the ARMA process with a solid line and its possible future as a dashed
    # curve.
    future = arma.getFuture(Nit)
    graph = future.drawMarginal(0)
    curve = graph.getDrawable(0)
    curve.setLineStyle("dashed")
    graph0.add(curve)
    graph0.setTitle("One ARMA realization and a possible future")
    # sphinx_gallery_thumbnail_number = 3
    view = otv.View(graph0)





.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.svg
   :alt: One ARMA realization and a possible future
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 201-202

It is of course possible to generate `N` different possible futures over the `Nit` next instants.

.. GENERATED FROM PYTHON SOURCE LINES 202-206

.. code-block:: Python

    N = 6
    possibleFuture_N = arma.getFuture(Nit, N)
    possibleFuture_N.setName("Possible futures")








.. GENERATED FROM PYTHON SOURCE LINES 207-208

Here we only show the future.

.. GENERATED FROM PYTHON SOURCE LINES 208-214

.. code-block:: Python

    graph = possibleFuture_N.drawMarginal(0)
    graph.setTitle("Six possible futures of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = otv.View(graph)




.. image-sg:: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.svg
   :alt: Six possible futures of the ARMA process
   :srcset: /auto_stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 215-216

Display all figures

.. GENERATED FROM PYTHON SOURCE LINES 216-217

.. code-block:: Python

    otv.View.ShowAll()








.. _sphx_glr_download_auto_stochastic_processes_plot_create_and_manipulate_arma_process.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_and_manipulate_arma_process.ipynb <plot_create_and_manipulate_arma_process.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_and_manipulate_arma_process.py <plot_create_and_manipulate_arma_process.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_create_and_manipulate_arma_process.zip <plot_create_and_manipulate_arma_process.zip>`
