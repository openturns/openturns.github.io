
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/stochastic_processes/plot_create_and_manipulate_arma_process.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py:


Create and manipulate an ARMA process
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 7-9

In this example we first create an ARMA process and then manipulate it.


.. GENERATED FROM PYTHON SOURCE LINES 11-18

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pylab as plt

    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 19-50

Create an ARMA process
----------------------

In this example we are going to build an ARMA process defined by its linear recurrence coefficients.

The creation of an ARMA model requires the data of the AR and MA
coefficients which are:

-  a list of scalars in the unidmensional case :
   :math:`(a_1, \dots, a_p)` for the AR-coefficients and
   :math:`(b_1, \dots, b_q)` for the MA-coefficients

-  a list of square matrix
   :math:`(\mat{A}_{\, 1}, \dots, \mat{A}{\, _p})` for the
   AR-coefficients and
   :math:`(\mat{B}_{\, 1}\, \dots, \mat{B}_{\, q})` for the
   MA-coefficients

It also requires the definition of a white noise
:math:`\vect{\varepsilon}` that contains the same time grid as the
one of the process.
The current state of an ARMA model is characterized by its last
:math:`p` values and the last :math:`q` values of its white noise. It
is possible to get that state thanks to the methods `getState`.
It is possible to create an ARMA with a specific current state. That
specific current state is taken into account to generate possible
futures but not to generate realizations (in order to respect the
stationarity property of the model).
At the creation step, we check whether the process
:math:`ARMA(p,q)` is stationnary.
When the process is not stationary, the user is warned by a message.

.. GENERATED FROM PYTHON SOURCE LINES 52-59

We build the 1-d ARMA process defined by:

.. math::
   X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}

where the white noise :math:`E_t` is defined by :math:`E_t \approx \mathrm{Triangular}(a = -1, m = 0, b = 1)`.


.. GENERATED FROM PYTHON SOURCE LINES 61-62

The definition of the recurrence coefficients ARMA (4,2) is simple:

.. GENERATED FROM PYTHON SOURCE LINES 62-66

.. code-block:: Python

    myARCoef = ot.ARMACoefficients([0.4, 0.3, 0.2, 0.1])
    myMACoef = ot.ARMACoefficients([0.4, 0.3])









.. GENERATED FROM PYTHON SOURCE LINES 67-69

We build a regular time discretization of the interval [0,1] with 10 time steps.
We also set up the white noise distribution of the recurrence relation :

.. GENERATED FROM PYTHON SOURCE LINES 69-72

.. code-block:: Python

    myTimeGrid = ot.RegularGrid(0.0, 0.1, 10)
    myWhiteNoise = ot.WhiteNoise(ot.Triangular(-1.0, 0.0, 1.0), myTimeGrid)








.. GENERATED FROM PYTHON SOURCE LINES 73-74

We are now ready to create the ARMA-process :

.. GENERATED FROM PYTHON SOURCE LINES 74-78

.. code-block:: Python

    process = ot.ARMA(myARCoef, myMACoef, myWhiteNoise)
    print(process)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA(X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}, E_t ~ Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 79-104

ARMA process manipulation
-------------------------

In this paragraph we shall expose some of the services exposed by an :math:`ARMA(p,q)` object, namely :

-  its AR and MA coefficients thanks to the methods `getARCoefficients`,
   `getMACoefficients`,

-  its white noise thanks to the method `getWhiteNoise`, that contains
   the time grid of the process,

-  its current state, that is its last :math:`p` values and the last
   :math:`q` values of its white noise, thanks to the method `getState`,

-  a realization thanks to the method `getRealization` or a sample of realizations thanks to the method `getSample`,

-  a possible future of the model, which is a possible extension of
   the current state on the next :math:`n_{prol}` instants, thanks to
   the method `getFuture`.

-  :math:`n` possible futures of the model, which correspond to
   :math:`n` possible prolongations of the current state on the next
   :math:`n_{prol}` instants, thanks to the method
   `getFuture` (:math:`n_{prol}`, :math:`n`).


.. GENERATED FROM PYTHON SOURCE LINES 107-108

First we get the coefficients AR and MA of the recurrence :

.. GENERATED FROM PYTHON SOURCE LINES 108-111

.. code-block:: Python

    print("AR coeff = ", process.getARCoefficients())
    print("MA coeff = ", process.getMACoefficients())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    AR coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]
    shift = 2
    [[ 0.2 ]]
    shift = 3
    [[ 0.1 ]]

    MA coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]





.. GENERATED FROM PYTHON SOURCE LINES 112-113

We check that the white noise is the one we have previously defined :

.. GENERATED FROM PYTHON SOURCE LINES 113-117

.. code-block:: Python

    myWhiteNoise = process.getWhiteNoise()
    print(myWhiteNoise)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    WhiteNoise(Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 118-119

We generate a possible time series realization :

.. GENERATED FROM PYTHON SOURCE LINES 119-122

.. code-block:: Python

    ts = process.getRealization()
    ts.setName("ARMA realization")








.. GENERATED FROM PYTHON SOURCE LINES 123-124

We draw this time series by specifying the wanted marginal index (only 0 is available here).

.. GENERATED FROM PYTHON SOURCE LINES 124-131

.. code-block:: Python

    graph0 = ts.drawMarginal(0)
    graph0.setTitle("One ARMA realization")
    graph0.setXTitle("t")
    graph0.setYTitle(r"$X_t$")
    view = viewer.View(graph0)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.png
   :alt: One ARMA realization
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 132-135

Generate a k time series
k = 5
myProcessSample = process.getSample(k)

.. GENERATED FROM PYTHON SOURCE LINES 135-141

.. code-block:: Python


    # Then get the current state of the ARMA
    # armaState = process.getState()
    # print("armaState = ")
    # print(armaState)








.. GENERATED FROM PYTHON SOURCE LINES 142-143

We draw a sample of size 6 : it is six different time series.

.. GENERATED FROM PYTHON SOURCE LINES 143-157

.. code-block:: Python

    size = 6
    sample = process.getSample(size)
    graph = sample.drawMarginal(0)
    graph.setTitle("Six realizations of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = viewer.View(graph)
    # plt.show()

    # We can obtain the current state of the ARMA process :
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.png
   :alt: Six realizations of the ARMA process
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[-0.000302069]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[0.381154]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[0.687158]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[-0.210009]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[0.758024]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[-0.164226]




.. GENERATED FROM PYTHON SOURCE LINES 158-159

Note that if we use the process in the meantime and ask for the current state again, it will be different.

.. GENERATED FROM PYTHON SOURCE LINES 159-172

.. code-block:: Python

    ts = process.getRealization()
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)


    # From the aforementioned `armaState`, we can get the last values of :math:`X_t` and the last values
    # of the white noise :math:`E_t`.
    myLastValues = armaState.getX()
    print(myLastValues)
    myLastEpsilonValues = armaState.getEpsilon()
    print(myLastEpsilonValues)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[-0.331173]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[0.0567119]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[-0.57972]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[-0.396344]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[-0.687745]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[-0.413865]
    0 : [ -0.331173  ]
    1 : [  0.0567119 ]
    2 : [ -0.57972   ]
    3 : [ -0.396344  ]
    0 : [ -0.687745 ]
    1 : [ -0.413865 ]




.. GENERATED FROM PYTHON SOURCE LINES 173-174

We have access to the number of iterations before getting a stationary state with

.. GENERATED FROM PYTHON SOURCE LINES 174-177

.. code-block:: Python

    Ntherm = process.getNThermalization()
    print("ThermalValue : %d" % Ntherm)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ThermalValue : 75




.. GENERATED FROM PYTHON SOURCE LINES 178-179

This may be important to evaluate it with another precision epsilon :

.. GENERATED FROM PYTHON SOURCE LINES 179-184

.. code-block:: Python

    epsilon = 1e-8
    newThermalValue = process.computeNThermalization(epsilon)
    print("newThermalValue : %d" % newThermalValue)
    process.setNThermalization(newThermalValue)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    newThermalValue : 38




.. GENERATED FROM PYTHON SOURCE LINES 185-186

An important feature of an ARMA process is the future prediction from its current state over the next  `Nit` instants, say `Nit=20`.

.. GENERATED FROM PYTHON SOURCE LINES 186-188

.. code-block:: Python

    Nit = 21








.. GENERATED FROM PYTHON SOURCE LINES 189-190

First we specify a current state `armaState` and build the corresponding ARMA process `arma` :

.. GENERATED FROM PYTHON SOURCE LINES 190-204

.. code-block:: Python

    arma = ot.ARMA(myARCoef, myMACoef, myWhiteNoise, armaState)

    # Then, we generate a possible future. The last instant was :math:`t=0.9` so the future starts at
    # :math:`t=1.0`. We represent the ARMA process with a solid line and its possible future as a dashed
    # curve.
    future = arma.getFuture(Nit)
    graph = future.drawMarginal(0)
    curve = graph.getDrawable(0)
    curve.setLineStyle("dashed")
    graph0.add(curve)
    graph0.setTitle("One ARMA realization and a possible future")
    view = viewer.View(graph0)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.png
   :alt: One ARMA realization and a possible future
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 205-206

It is of course possible to generate `N` different possible futures over the `Nit` next instants.

.. GENERATED FROM PYTHON SOURCE LINES 206-210

.. code-block:: Python

    N = 6
    possibleFuture_N = arma.getFuture(Nit, N)
    possibleFuture_N.setName("Possible futures")








.. GENERATED FROM PYTHON SOURCE LINES 211-212

Here we only show the future.

.. GENERATED FROM PYTHON SOURCE LINES 212-219

.. code-block:: Python

    graph = possibleFuture_N.drawMarginal(0)
    graph.setTitle("Six possible futures of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = viewer.View(graph)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.png
   :alt: Six possible futures of the ARMA process
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 220-221

Display all figures

.. GENERATED FROM PYTHON SOURCE LINES 221-222

.. code-block:: Python

    plt.show()








.. _sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_and_manipulate_arma_process.ipynb <plot_create_and_manipulate_arma_process.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_and_manipulate_arma_process.py <plot_create_and_manipulate_arma_process.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_create_and_manipulate_arma_process.zip <plot_create_and_manipulate_arma_process.zip>`
