
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/distributions/plot_python_distribution.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_distributions_plot_python_distribution.py:


Create a customized distribution or copula
==========================================

.. GENERATED FROM PYTHON SOURCE LINES 7-16

In this example we are going to create a distribution or copula.

The way to go is inheriting the :class:`~openturns.PythonDistribution`, get the  class and overload the methods of the :class:`~openturns.Distribution` object.

To create a Copula, the user has to overload `isCopula()` and return `True`.

Then an instance of the new class can be passed on into a Distribution object.

At least `computeCDF` should be overridden.

.. GENERATED FROM PYTHON SOURCE LINES 18-28

.. code-block:: Python

    import openturns as ot
    import openturns.testing as ott
    import openturns.viewer as otv
    import math as m
    import warnings

    warnings.filterwarnings("ignore")
    ot.Log.Show(ot.Log.NONE)









.. GENERATED FROM PYTHON SOURCE LINES 29-30

Inherit :class:`~openturns.PythonDistribution`:

.. GENERATED FROM PYTHON SOURCE LINES 33-136

.. code-block:: Python

    class UniformNdPy(ot.PythonDistribution):
        def __init__(self, a=[0.0], b=[1.0]):
            super(UniformNdPy, self).__init__(len(a))
            if len(a) != len(b):
                raise ValueError("Invalid bounds")
            for i in range(len(a)):
                if a[i] > b[i]:
                    raise ValueError("Invalid bounds")
            self.a = a
            self.b = b
            self.factor = 1.0
            for i in range(len(a)):
                self.factor *= b[i] - a[i]

        def getRange(self):
            return ot.Interval(self.a, self.b, [True] * len(self.a), [True] * len(self.a))

        def getRealization(self):
            X = []
            for i in range(len(self.a)):
                X.append(
                    self.a[i] + (self.b[i] - self.a[i]) * ot.RandomGenerator.Generate()
                )
            return X

        def getSample(self, size):
            X = []
            for i in range(size):
                X.append(self.getRealization())
            return X

        def computeCDF(self, X):
            prod = 1.0
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                prod *= min(self.b[i], X[i]) - self.a[i]
            return prod / self.factor

        def computePDF(self, X):
            for i in range(len(self.a)):
                if X[i] < self.a[i]:
                    return 0.0
                if X[i] > self.b[i]:
                    return 0.0
            return 1.0 / self.factor

        def getMean(self):
            mu = []
            for i in range(len(self.a)):
                mu.append(0.5 * (self.a[i] + self.b[i]))
            return mu

        def getStandardDeviation(self):
            stdev = []
            for i in range(len(self.a)):
                stdev.append((self.b[i] - self.a[i]) / m.sqrt(12.0))
            return stdev

        def getSkewness(self):
            return [0.0] * len(self.a)

        def getKurtosis(self):
            return [1.8] * len(self.a)

        def getMoment(self, n):
            return [-0.1 * n] * len(self.a)

        def computeCharacteristicFunction(self, x):
            if len(self.a) > 1:
                raise ValueError("dim>1")
            ax = self.a[0] * x
            bx = self.b[0] * x
            return (m.sin(bx) - m.sin(ax) + 1j * (m.cos(ax) - m.cos(bx))) / (bx - ax)

        def isElliptical(self):
            return (len(self.a) == 1) and (self.a[0] == -self.b[0])

        def isCopula(self):
            for i in range(len(self.a)):
                if self.a[i] != 0.0:
                    return False
                if self.b[i] != 1.0:
                    return False
            return True

        def getMarginal(self, indices):
            subA = []
            subB = []
            for i in indices:
                subA.append(self.a[i])
                subB.append(self.b[i])
            py_dist = UniformNdPy(subA, subB)
            return ot.Distribution(py_dist)

        def computeQuantile(self, prob, tail=False):
            p = 1.0 - prob if tail else prob
            quantile = list(self.a)
            for i in range(len(self.a)):
                quantile[i] += p * (self.b[i] - self.a[i])
            return quantile









.. GENERATED FROM PYTHON SOURCE LINES 137-138

Let us instantiate the distribution:

.. GENERATED FROM PYTHON SOURCE LINES 138-140

.. code-block:: Python

    distribution = ot.Distribution(UniformNdPy([5, 6], [7, 9]))








.. GENERATED FROM PYTHON SOURCE LINES 141-142

And plot the CDF:

.. GENERATED FROM PYTHON SOURCE LINES 142-146

.. code-block:: Python

    graph = distribution.drawCDF()
    graph.setColors(["blue"])
    view = otv.View(graph)




.. image-sg:: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.png
   :alt: [X0,X1] iso-CDF
   :srcset: /auto_probabilistic_modeling/distributions/images/sphx_glr_plot_python_distribution_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 147-148

We can easily generate sample:

.. GENERATED FROM PYTHON SOURCE LINES 148-150

.. code-block:: Python

    distribution.getSample(5)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
      <tr><td></td><th>v0</th><th>v1</th></tr>
      <tr><th>0</th><td>5.214382</td><td>8.722445</td></tr>
      <tr><th>1</th><td>5.529527</td><td>8.2088</td></tr>
      <tr><th>2</th><td>5.306683</td><td>8.705896</td></tr>
      <tr><th>3</th><td>5.763463</td><td>6.413362</td></tr>
      <tr><th>4</th><td>6.345027</td><td>6.878352</td></tr>
    </table>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 151-152

or compute the mean:

.. GENERATED FROM PYTHON SOURCE LINES 152-154

.. code-block:: Python

    distribution.getMean()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=2 values=[6,7.5]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 155-156

Also we can compute the probability contained in an interval:

.. GENERATED FROM PYTHON SOURCE LINES 156-158

.. code-block:: Python

    distribution.computeProbability(ot.Interval([5.5, 6], [8.5, 9]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.75



.. GENERATED FROM PYTHON SOURCE LINES 159-161

Now let us validate our distribution with :class:`openturns.testing.DistributionValidation`
It automatically checks the consistency of most services and allows one to check for errors.

.. GENERATED FROM PYTHON SOURCE LINES 161-164

.. code-block:: Python

    checker = ott.DistributionValidation(distribution)
    checker.run()








.. GENERATED FROM PYTHON SOURCE LINES 165-166

.. code-block:: Python

    otv.View.ShowAll()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 3.733 seconds)


.. _sphx_glr_download_auto_probabilistic_modeling_distributions_plot_python_distribution.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_python_distribution.ipynb <plot_python_distribution.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_python_distribution.py <plot_python_distribution.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_python_distribution.zip <plot_python_distribution.zip>`
