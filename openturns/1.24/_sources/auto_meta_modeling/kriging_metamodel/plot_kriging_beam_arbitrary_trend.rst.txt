
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_kriging_beam_arbitrary_trend.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:


Kriging: choose an arbitrary trend
==================================

.. GENERATED FROM PYTHON SOURCE LINES 7-20

The goal of this example is to show how to configure an arbitrary trend in a Kriging metamodel.
In the :doc:`/auto_meta_modeling/kriging_metamodel/plot_kriging_chose_trend`
and :doc:`/auto_meta_modeling/kriging_metamodel/plot_kriging_beam_trend` examples,
we show how to configure a polynomial trend.

In general, any collection of multivariate functions can be used as the
`basis` argument of a :class:`~openturns.KrigingAlgorithm`.
In practice, it might not be convenient to create a multivariate basis and
this is why we sometimes create it by tensorization of univariate functions.
In this example, we first use Legendre polynomials as our univariate functions,
then we create an orthogonal polynomial basis corresponding to the input marginals.

For this purpose, we use the :ref:`cantilever beam <use-case-cantilever-beam>` example.

.. GENERATED FROM PYTHON SOURCE LINES 22-24

Definition of the model
-----------------------

.. GENERATED FROM PYTHON SOURCE LINES 26-32

.. code-block:: Python

    from openturns.usecases import cantilever_beam
    import openturns as ot

    ot.RandomGenerator.SetSeed(0)
    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 33-34

We load the cantilever beam use case

.. GENERATED FROM PYTHON SOURCE LINES 34-36

.. code-block:: Python

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 37-38

We load the function (model) which evaluates the output `Y` depending on the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 38-40

.. code-block:: Python

    model = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 41-42

Then we define the distribution of the input random vector.

.. GENERATED FROM PYTHON SOURCE LINES 42-45

.. code-block:: Python

    dimension = cb.dim  # number of inputs
    myDistribution = cb.distribution








.. GENERATED FROM PYTHON SOURCE LINES 46-48

Create the design of experiments
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 50-53

We consider a simple Monte-Carlo sampling as a design of experiments.
This is why we generate an input sample using the `getSample` method of the distribution.
Then we evaluate the output using the `model` function.

.. GENERATED FROM PYTHON SOURCE LINES 55-59

.. code-block:: Python

    sampleSize_train = 20
    X_train = myDistribution.getSample(sampleSize_train)
    Y_train = model(X_train)








.. GENERATED FROM PYTHON SOURCE LINES 60-66

Create the Legendre basis
-------------------------

We first create a Legendre basis of univariate polynomials. In order to convert then into multivariate polynomials, we use a linear enumerate function.

The :class:`~openturns.LegendreFactory` class creates Legendre polynomials.

.. GENERATED FROM PYTHON SOURCE LINES 68-70

.. code-block:: Python

    univariateFactory = ot.LegendreFactory()








.. GENERATED FROM PYTHON SOURCE LINES 71-72

This factory corresponds to the `Uniform` distribution in the :math:`[-1, 1]` interval.

.. GENERATED FROM PYTHON SOURCE LINES 74-76

.. code-block:: Python

    univariateFactory.getMeasure()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    Uniform
    <ul>
      <li>name=Uniform</li>
      <li>dimension=1</li>
      <li>weight=1</li>
      <li>range=[-1, 1]</li>
      <li>description=[X0]</li>
      <li>isParallel=true</li>
      <li>isCopula=false</li>
    </ul>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 77-79

This interval does not correspond to the interval on which the input marginals are defined (we will come back to this topic later),
but this will, anyway, create a consistent trend for the Kriging.

.. GENERATED FROM PYTHON SOURCE LINES 81-83

.. code-block:: Python

    polyColl = [univariateFactory] * dimension








.. GENERATED FROM PYTHON SOURCE LINES 84-87

.. code-block:: Python

    enumerateFunction = ot.LinearEnumerateFunction(dimension)
    productBasis = ot.OrthogonalProductPolynomialFactory(polyColl, enumerateFunction)








.. GENERATED FROM PYTHON SOURCE LINES 88-95

.. code-block:: Python

    functions = []
    numberOfTrendCoefficients = 12
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    1.73205 * x0 * 1.73205 * x1
    1.73205 * x0 * 1.73205 * x2
    1.73205 * x0 * 1.73205 * x3
    -1.11803 + 3.3541 * x1^2
    1.73205 * x1 * 1.73205 * x2
    1.73205 * x1 * 1.73205 * x3




.. GENERATED FROM PYTHON SOURCE LINES 96-98

.. code-block:: Python

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 99-101

Create the metamodel
--------------------

.. GENERATED FROM PYTHON SOURCE LINES 103-108

In order to create the kriging metamodel, we first select a constant trend
with the :class:`~openturns.ConstantBasisFactory` class.
Then we use a squared exponential covariance model.
Finally, we use the :class:`~openturns.KrigingAlgorithm` class to create the Kriging metamodel,
taking the training sample, the covariance model and the trend basis as input arguments.

.. GENERATED FROM PYTHON SOURCE LINES 110-112

.. code-block:: Python

    covarianceModel = ot.SquaredExponential([1.0] * dimension, [1.0])








.. GENERATED FROM PYTHON SOURCE LINES 113-118

.. code-block:: Python

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 119-120

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 122-124

.. code-block:: Python

    result.getTrendCoefficients()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=12 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 125-126

We see that the number of coefficients in the trend corresponds to the number of functions in the basis.

.. GENERATED FROM PYTHON SOURCE LINES 128-130

.. code-block:: Python

    result.getCovarianceModel()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>SquaredExponential(scale=[1,1,0.163904,0.01], amplitude=[0.0316491])</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 131-133

The :class:`~openturns.SquaredExponential` model has one amplitude coefficient and 4 scale coefficients.
This is because this covariance model is anisotropic : each of the 4 input variables is associated with its own scale coefficient.

.. GENERATED FROM PYTHON SOURCE LINES 135-137

Create an orthogonal multivariate polynomial factory
----------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 139-146

In order to create a Legendre basis which better corresponds to the input marginals, we could consider the orthogonal basis which would be associated to uniform marginals.
To compute the bounds of these uniform distributions, we may consider the 1% and 99% quantiles of each marginal.

There is, however, a simpler way to proceed. We can simply orthogonalize the input marginals and create the orthogonal polynomial basis corresponding to the inputs.
This corresponds to the method we would use in the polynomial chaos.

We first create the polynomial basis which corresponds to the inputs.

.. GENERATED FROM PYTHON SOURCE LINES 148-150

.. code-block:: Python

    multivariateBasis = ot.OrthogonalProductPolynomialFactory([cb.E, cb.F, cb.L, cb.II])








.. GENERATED FROM PYTHON SOURCE LINES 151-152

Then we create the multivariate basis which has maximum degree equal to 2.

.. GENERATED FROM PYTHON SOURCE LINES 154-159

.. code-block:: Python

    totalDegree = 2
    enumerateFunction = multivariateBasis.getEnumerateFunction()
    numberOfTrendCoefficients = enumerateFunction.getStrataCumulatedCardinal(totalDegree)
    numberOfTrendCoefficients





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    15



.. GENERATED FROM PYTHON SOURCE LINES 160-166

.. code-block:: Python

    functions = []
    for i in range(numberOfTrendCoefficients):
        multivariatepolynomial = productBasis.build(i)
        print(multivariatepolynomial)
        functions.append(multivariatepolynomial)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    1
    1.73205 * x0
    1.73205 * x1
    1.73205 * x2
    1.73205 * x3
    -1.11803 + 3.3541 * x0^2
    1.73205 * x0 * 1.73205 * x1
    1.73205 * x0 * 1.73205 * x2
    1.73205 * x0 * 1.73205 * x3
    -1.11803 + 3.3541 * x1^2
    1.73205 * x1 * 1.73205 * x2
    1.73205 * x1 * 1.73205 * x3
    -1.11803 + 3.3541 * x2^2
    1.73205 * x2 * 1.73205 * x3
    -1.11803 + 3.3541 * x3^2




.. GENERATED FROM PYTHON SOURCE LINES 167-169

.. code-block:: Python

    basis = ot.Basis(functions)








.. GENERATED FROM PYTHON SOURCE LINES 170-175

.. code-block:: Python

    algo = ot.KrigingAlgorithm(X_train, Y_train, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    krigingWithConstantTrend = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 176-177

The `getTrendCoefficients` method returns the coefficients of the trend.

.. GENERATED FROM PYTHON SOURCE LINES 179-181

.. code-block:: Python

    result.getTrendCoefficients()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=15 values=[6.80011e-46,8.00088e-35,3.49721e-43,2.99508e-45,1.7335e-52,1.05339e-23,4.11637e-32,3.52382e-34,2.03902e-41,2.02866e-40,1.54017e-42,8.91627e-50,1.39896e-44,7.63508e-52,-7.60276e-46]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 182-193

Conclusion
----------

The trend that we have configured corresponds to the basis that we would have used in a full polynomial chaos computed with least squares.

Other extensions of this work would be:

* to use a Fourier basis with :class:`~openturns.FourierSeriesFactory`,
* wavelets with :class:`~openturns.HaarWaveletFactory`,

or any other univariate factory.


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_kriging_beam_arbitrary_trend.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_kriging_beam_arbitrary_trend.ipynb <plot_kriging_beam_arbitrary_trend.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_kriging_beam_arbitrary_trend.py <plot_kriging_beam_arbitrary_trend.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_kriging_beam_arbitrary_trend.zip <plot_kriging_beam_arbitrary_trend.zip>`
