
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/polynomial_chaos_metamodel/plot_chaos_cantilever_beam_integration.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_cantilever_beam_integration.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_cantilever_beam_integration.py:


Create a polynomial chaos metamodel by integration on the cantilever beam
=========================================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-17

In this example, we create a polynomial chaos metamodel by integration on the
:ref:`cantilever beam <use-case-cantilever-beam>` example.
We choose to evaluate the coefficients of the chaos decomposition by
integration using various kinds of design of experiments:

- Gauss product,
- Latin hypercube sampling,
- Quasi Monte-Carlo with a Sobol' sequence.

We will compare the results obtained on each design.

.. GENERATED FROM PYTHON SOURCE LINES 19-25

.. code-block:: Python

    from openturns.usecases import cantilever_beam
    import openturns as ot
    import openturns.viewer as otv

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 26-27

We first load the model from the usecases module :

.. GENERATED FROM PYTHON SOURCE LINES 27-29

.. code-block:: Python

    cb = cantilever_beam.CantileverBeam()








.. GENERATED FROM PYTHON SOURCE LINES 30-32

In this example we consider all marginals independent.
They are defined in the :class:`~openturns.usecases.cantilever_beam.CantileverBeam`  class:

.. GENERATED FROM PYTHON SOURCE LINES 32-38

.. code-block:: Python

    dist_E = cb.E
    dist_F = cb.F
    dist_L = cb.L
    dist_I = cb.II
    distribution = cb.independentDistribution








.. GENERATED FROM PYTHON SOURCE LINES 39-40

We load the model.

.. GENERATED FROM PYTHON SOURCE LINES 40-44

.. code-block:: Python

    dim_input = cb.dim  # dimension of the input
    dim_output = 1  # dimension of the output
    g = cb.model








.. GENERATED FROM PYTHON SOURCE LINES 45-47

Create a polynomial chaos decomposition
---------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 49-51

We create the multivariate polynomial basis by tensorization of the
univariate polynomials and the default linear enumerate rule.

.. GENERATED FROM PYTHON SOURCE LINES 51-55

.. code-block:: Python

    multivariateBasis = ot.OrthogonalProductPolynomialFactory(
        [dist_E, dist_F, dist_L, dist_I]
    )








.. GENERATED FROM PYTHON SOURCE LINES 56-60

In this case, we select :math:`P` using the
:meth:`~openturns.EnumerateFunction.getBasisSizeFromTotalDegree` method,
so that all polynomials with total degree lower or equal to 5 are used.
This will lead to the computation of 126 coefficients.

.. GENERATED FROM PYTHON SOURCE LINES 60-65

.. code-block:: Python

    totalDegree = 5
    enum_func = multivariateBasis.getEnumerateFunction()
    basisSize = enum_func.getBasisSizeFromTotalDegree(totalDegree)
    print(f"Basis size = {basisSize}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Basis size = 126




.. GENERATED FROM PYTHON SOURCE LINES 66-68

We select the :class:`~openturns.FixedStrategy` truncation rule, which corresponds to using
the first :math:`P` polynomials of the polynomial basis.

.. GENERATED FROM PYTHON SOURCE LINES 68-70

.. code-block:: Python

    adaptiveStrategy = ot.FixedStrategy(multivariateBasis, basisSize)








.. GENERATED FROM PYTHON SOURCE LINES 71-74

We begin by getting the standard measure associated with the multivariate polynomial basis.
We see that the range of the `Beta` distribution has been standardized into the `[-1, 1]` interval.
This is the same for the `Uniform` distribution and the second `Beta` distribution.

.. GENERATED FROM PYTHON SOURCE LINES 74-77

.. code-block:: Python

    measure = multivariateBasis.getMeasure()
    print(f"Measure = {measure}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Measure = JointDistribution(Beta(alpha = 0.9, beta = 3.5, a = -1, b = 1), LogNormal(muLog = 5.69881, sigmaLog = 0.0997513, gamma = 0), Uniform(a = -1, b = 1), Beta(alpha = 2.5, beta = 4, a = -1, b = 1), IndependentCopula(dimension = 4))




.. GENERATED FROM PYTHON SOURCE LINES 78-80

The choice of the :class:`~openturns.GaussProductExperiment` rule with 4 nodes
in each of the 4 dimensions leads to :math:`4^4=256` evaluations of the model.

.. GENERATED FROM PYTHON SOURCE LINES 80-86

.. code-block:: Python

    marginalSizes = [4] * dim_input
    experiment = ot.GaussProductExperiment(distribution, marginalSizes)
    print(f"N={experiment.getSize()}")
    X, W = experiment.generateWithWeights()
    Y = g(X)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    N=256




.. GENERATED FROM PYTHON SOURCE LINES 87-88

We now set the method used to compute the coefficients; we select the integration method.

.. GENERATED FROM PYTHON SOURCE LINES 88-90

.. code-block:: Python

    projectionStrategy = ot.IntegrationStrategy()








.. GENERATED FROM PYTHON SOURCE LINES 91-92

We can now create the functional chaos.

.. GENERATED FROM PYTHON SOURCE LINES 92-97

.. code-block:: Python

    algo = ot.FunctionalChaosAlgorithm(
        X, W, Y, distribution, adaptiveStrategy, projectionStrategy
    )
    algo.run()








.. GENERATED FROM PYTHON SOURCE LINES 98-99

Get the result

.. GENERATED FROM PYTHON SOURCE LINES 99-101

.. code-block:: Python

    result = algo.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 102-103

The :meth:`~openturns.FunctionalChaosResult.getMetaModel` method returns the metamodel function.

.. GENERATED FROM PYTHON SOURCE LINES 103-105

.. code-block:: Python

    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 106-108

Validate the metamodel
----------------------

.. GENERATED FROM PYTHON SOURCE LINES 110-111

Generate a new validation sample (which is independent of the training sample).

.. GENERATED FROM PYTHON SOURCE LINES 111-115

.. code-block:: Python

    n_valid = 1000
    X_test = distribution.getSample(n_valid)
    Y_test = g(X_test)








.. GENERATED FROM PYTHON SOURCE LINES 116-118

The :class:`~openturns.MetaModelValidation` class validates the metamodel
based on a validation sample.

.. GENERATED FROM PYTHON SOURCE LINES 118-121

.. code-block:: Python

    metamodelPredictions = metamodel(X_test)
    val = ot.MetaModelValidation(Y_test, metamodelPredictions)








.. GENERATED FROM PYTHON SOURCE LINES 122-123

Compute the :math:`R^2` coefficient of determination.

.. GENERATED FROM PYTHON SOURCE LINES 123-126

.. code-block:: Python

    r2Score = val.computeR2Score()[0]
    r2Score





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.9999963114616416



.. GENERATED FROM PYTHON SOURCE LINES 127-128

Plot the observed versus the predicted outputs.

.. GENERATED FROM PYTHON SOURCE LINES 128-132

.. code-block:: Python

    graph = val.drawValidation()
    graph.setTitle(f"Gauss product N={experiment.getSize()} - R2={r2Score * 100:.2f}")
    view = otv.View(graph)




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_001.png
   :alt: Gauss product N=256 - R2=100.00
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 133-134

Now repeat the same process on various designs.

.. GENERATED FROM PYTHON SOURCE LINES 134-156

.. code-block:: Python



    def draw_validation(experiment):
        projectionStrategy = ot.IntegrationStrategy(experiment)
        algo = ot.FunctionalChaosAlgorithm(
            X, Y, distribution, adaptiveStrategy, projectionStrategy
        )
        algo.run()
        result = algo.getResult()
        metamodel = result.getMetaModel()
        X_test = distribution.getSample(n_valid)
        Y_test = g(X_test)
        metamodelPredictions = metamodel(X_test)
        val = ot.MetaModelValidation(Y_test, metamodelPredictions)
        r2Score = val.computeR2Score()[0]
        graph = val.drawValidation()
        graph.setTitle(
            f"{experiment.__class__.__name__} - N={experiment.getSize()} - R2={r2Score * 100:.2f}"
        )
        return graph









.. GENERATED FROM PYTHON SOURCE LINES 157-158

Use an LHS design.

.. GENERATED FROM PYTHON SOURCE LINES 158-162

.. code-block:: Python

    experiment = ot.LHSExperiment(distribution, int(1e6))
    graph = draw_validation(experiment)
    view = otv.View(graph)




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_002.png
   :alt: LHSExperiment - N=1000000 - R2=-459402.29
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 163-164

Use a low-discrepancy experiment (Quasi-Monte Carlo).

.. GENERATED FROM PYTHON SOURCE LINES 164-171

.. code-block:: Python

    sequence = ot.SobolSequence()
    experiment = ot.LowDiscrepancyExperiment(sequence, distribution, int(1e5))
    graph = draw_validation(experiment)
    view = otv.View(graph)

    otv.View.ShowAll()




.. image-sg:: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_003.png
   :alt: LowDiscrepancyExperiment - N=100000 - R2=-155951.05
   :srcset: /auto_meta_modeling/polynomial_chaos_metamodel/images/sphx_glr_plot_chaos_cantilever_beam_integration_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 172-179

Conclusion
----------
With the Gauss product rule, the coefficients are particularly well computed
since the R2 score is excellent, even with the relatively limited amount
of simulation (256 points).
On the other hand the LHS and low-discrepancy experiments require many more
points to achieve a :math:`R^2` > 99%.


.. _sphx_glr_download_auto_meta_modeling_polynomial_chaos_metamodel_plot_chaos_cantilever_beam_integration.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_chaos_cantilever_beam_integration.ipynb <plot_chaos_cantilever_beam_integration.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_chaos_cantilever_beam_integration.py <plot_chaos_cantilever_beam_integration.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_chaos_cantilever_beam_integration.zip <plot_chaos_cantilever_beam_integration.zip>`
