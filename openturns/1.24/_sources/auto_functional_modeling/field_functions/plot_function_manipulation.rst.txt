
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_functional_modeling/field_functions/plot_function_manipulation.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_functional_modeling_field_functions_plot_function_manipulation.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_functional_modeling_field_functions_plot_function_manipulation.py:


Function manipulation
=====================

.. GENERATED FROM PYTHON SOURCE LINES 7-20

In this example we are going to exhibit some of the generic function services such as:

- to ask the dimension of its input and output vectors
- to evaluate itself, its gradient and hessian
- to set a finite difference method for the evaluation of the gradient or the hessian
- to evaluate the number of times the function or its gradient or its hessian have been evaluated
- to disable or enable (enabled by default) the history mechanism
- to disable or enable the cache mechanism
- to get all the values evaluated by the function and the associated inputs with the methods
- to clear the history
- to ask the description of its input and output vectors
- to extract output components
- to get a graphical representation

.. GENERATED FROM PYTHON SOURCE LINES 23-28

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as viewer

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 29-31

Create a vectorial function R ^n --> R^p
for example R^2 --> R^2

.. GENERATED FROM PYTHON SOURCE LINES 31-57

.. code-block:: Python

    f = ot.SymbolicFunction(["x1", "x2"], ["1+2*x1+x2", "2+x1+2*x2"])

    # Create a scalar function R --> R
    func1 = ot.SymbolicFunction(["x"], ["x^2"])

    # Create another function R^2 --> R
    func2 = ot.SymbolicFunction(["x", "y"], ["x*y"])

    # Create a vectorial function R ^3 --> R^2
    func3 = ot.SymbolicFunction(
        ["x1", "x2", "x3"], ["1+2*x1+x2+x3^3", "2+sin(x1+2*x2)-sin(x3) * x3^4"]
    )

    # Create a second vectorial function R ^n --> R^p
    # for example R^2 --> R^2
    g = ot.SymbolicFunction(["x1", "x2"], ["x1+x2", "x1^2+2*x2^2"])


    def python_eval(X):
        a, b = X
        y = a + b
        return [y]


    func4 = ot.PythonFunction(2, 1, python_eval)








.. GENERATED FROM PYTHON SOURCE LINES 58-59

Ask for the dimension of the input and output vectors

.. GENERATED FROM PYTHON SOURCE LINES 59-62

.. code-block:: Python

    print(f.getInputDimension())
    print(f.getOutputDimension())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    2
    2




.. GENERATED FROM PYTHON SOURCE LINES 63-64

Enable the history mechanism

.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: Python

    f = ot.MemoizeFunction(f)








.. GENERATED FROM PYTHON SOURCE LINES 67-68

Evaluate the function at a particular point

.. GENERATED FROM PYTHON SOURCE LINES 68-72

.. code-block:: Python

    x = [1.0] * f.getInputDimension()
    y = f(x)
    print("x=", x, "y=", y)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    x= [1.0, 1.0] y= [4,5]




.. GENERATED FROM PYTHON SOURCE LINES 73-74

Get the history

.. GENERATED FROM PYTHON SOURCE LINES 74-78

.. code-block:: Python

    samplex = f.getInputHistory()
    sampley = f.getOutputHistory()
    print("evaluation history = ", samplex, sampley)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    evaluation history =  0 : [ 1 1 ] 0 : [ 4 5 ]




.. GENERATED FROM PYTHON SOURCE LINES 79-80

Clear the history mechanism

.. GENERATED FROM PYTHON SOURCE LINES 80-82

.. code-block:: Python

    f.clearHistory()








.. GENERATED FROM PYTHON SOURCE LINES 83-84

Disable the history mechanism

.. GENERATED FROM PYTHON SOURCE LINES 84-86

.. code-block:: Python

    f.disableHistory()








.. GENERATED FROM PYTHON SOURCE LINES 87-88

Enable the cache mechanism

.. GENERATED FROM PYTHON SOURCE LINES 88-93

.. code-block:: Python

    f4 = ot.MemoizeFunction(func4)
    f4.enableCache()
    for i in range(10):
        f4(x)








.. GENERATED FROM PYTHON SOURCE LINES 94-95

Get the number of times cached values are reused

.. GENERATED FROM PYTHON SOURCE LINES 95-97

.. code-block:: Python

    f4.getCacheHits()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    9



.. GENERATED FROM PYTHON SOURCE LINES 98-99

Evaluate the gradient of the function at a particular point

.. GENERATED FROM PYTHON SOURCE LINES 99-102

.. code-block:: Python

    gradientMatrix = f.gradient(x)
    gradientMatrix






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[[ 2 1 ]<br>
     [ 1 2 ]]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 103-104

Evaluate the hessian of the function at a particular point

.. GENERATED FROM PYTHON SOURCE LINES 104-107

.. code-block:: Python

    hessianMatrix = f.hessian(x)
    hessianMatrix






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>sheet #0<br>
    [[ 0 0 ]<br>
     [ 0 0 ]]<br>
    sheet #1<br>
    [[ 0 0 ]<br>
     [ 0 0 ]]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 108-109

Change the gradient method to a non centered finite difference method

.. GENERATED FROM PYTHON SOURCE LINES 109-114

.. code-block:: Python

    step = [1e-7] * f.getInputDimension()
    gradient = ot.NonCenteredFiniteDifferenceGradient(step, f.getEvaluation())
    f.setGradient(gradient)
    gradient






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=NonCenteredFiniteDifferenceGradient name=Unnamed epsilon=class=Point name=Unnamed dimension=2 values=[1e-07,1e-07] evaluation=MemoizeEvaluation(class=SymbolicEvaluation name=Unnamed inputVariablesNames=[x1,x2] outputVariablesNames=[y0,y1] formulas=[1+2*x1+x2,2+x1+2*x2])
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 115-116

Change the hessian method to a centered finite difference method

.. GENERATED FROM PYTHON SOURCE LINES 116-121

.. code-block:: Python

    step = [1e-7] * f.getInputDimension()
    hessian = ot.CenteredFiniteDifferenceHessian(step, f.getEvaluation())
    f.setHessian(hessian)
    hessian






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=CenteredFiniteDifferenceHessian name=Unnamed epsilon=class=Point name=Unnamed dimension=2 values=[1e-07,1e-07] evaluation=MemoizeEvaluation(class=SymbolicEvaluation name=Unnamed inputVariablesNames=[x1,x2] outputVariablesNames=[y0,y1] formulas=[1+2*x1+x2,2+x1+2*x2])
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 122-123

Get the number of times the function has been evaluated

.. GENERATED FROM PYTHON SOURCE LINES 123-125

.. code-block:: Python

    f.getEvaluationCallsNumber()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    1



.. GENERATED FROM PYTHON SOURCE LINES 126-127

Get the number of times the gradient has been evaluated

.. GENERATED FROM PYTHON SOURCE LINES 127-129

.. code-block:: Python

    f.getGradientCallsNumber()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0



.. GENERATED FROM PYTHON SOURCE LINES 130-131

Get the number of times the hessian has been evaluated

.. GENERATED FROM PYTHON SOURCE LINES 131-133

.. code-block:: Python

    f.getHessianCallsNumber()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0



.. GENERATED FROM PYTHON SOURCE LINES 134-135

Get the component i

.. GENERATED FROM PYTHON SOURCE LINES 135-137

.. code-block:: Python

    f.getMarginal(1)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <ul>
      <li> Input dimension = 2  </li>
      <li> Input description = [x1,x2]  </li>
      <li> Output dimension = 1  </li>
      <li> Output description = [y1]  </li>
      <li> Parameter = []  </li>
    </ul>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 138-139

Compose two functions : h = f o g

.. GENERATED FROM PYTHON SOURCE LINES 139-141

.. code-block:: Python

    ot.ComposedFunction(f, g)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    (MemoizeEvaluation([x1,x2]->[1+2*x1+x2,2+x1+2*x2]))o([x1,x2]->[x1+x2,x1^2+2*x2^2])
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 142-143

Get the valid symbolic constants

.. GENERATED FROM PYTHON SOURCE LINES 143-145

.. code-block:: Python

    ot.SymbolicFunction.GetValidConstants()






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    [e_ -> Euler's constant (2.71828...),pi_ -> Pi constant (3.14159...)]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 146-150

Graph 1 : z -->  f_2(x_0,y_0,z)
for z in [-1.5, 1.5] and y_0 = 2. and z_0 = 2.5
Specify the input component that varies
Care : numerotation begins at 0

.. GENERATED FROM PYTHON SOURCE LINES 150-165

.. code-block:: Python

    inputMarg = 2
    # Give its variation intervall
    zMin = -1.5
    zMax = 1.5
    # Give the coordinates of the fixed input components
    centralPt = [1.0, 2.0, 2.5]
    # Specify the output marginal function
    # Care : numerotation begins at 0
    outputMarg = 1
    # Specify the point number of the final curve
    ptNb = 101
    # Draw the curve!
    graph = func3.draw(inputMarg, outputMarg, centralPt, zMin, zMax, ptNb)
    view = viewer.View(graph)




.. image-sg:: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_001.png
   :alt: y1 as a function of x3 around [1,2,2.5]
   :srcset: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 166-170

Graph 2 : (x,z) -->  f_1(x,y_0,z)
for x in [-1.5, 1.5], z in [-2.5, 2.5]
and y_0 = 2.5
Specify the input components that vary

.. GENERATED FROM PYTHON SOURCE LINES 170-186

.. code-block:: Python

    firstInputMarg = 0
    secondInputMarg = 2
    # Give their variation interval
    inputMin2 = [-1.5, -2.5]
    inputMax2 = [1.5, 2.5]
    # Give the coordinates of the fixed input components
    centralPt = [0.0, 2.0, 2.5]
    # Specify the output marginal function
    outputMarg = 1
    # Specify the point number of the final curve
    ptNb = [101, 101]
    graph = func3.draw(
        firstInputMarg, secondInputMarg, outputMarg, centralPt, inputMin2, inputMax2, ptNb
    )
    view = viewer.View(graph)




.. image-sg:: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_002.png
   :alt: y1 as a function of (x1,x3) around [0,2,2.5]
   :srcset: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 187-190

Graph 3 : simplified method for x -->  func1(x)
for x in [-1.5, 1.5]
Give the variation interval

.. GENERATED FROM PYTHON SOURCE LINES 190-198

.. code-block:: Python

    xMin3 = -1.5
    xMax3 = 1.5
    # Specify the point number of the final curve
    ptNb = 101
    # Draw the curve!
    graph = func1.draw(xMin3, xMax3, ptNb)
    view = viewer.View(graph)




.. image-sg:: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_003.png
   :alt: y0 as a function of x
   :srcset: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 199-202

Graph 4 : (x,y) -->  func2(x,y)
for x in [-1.5, 1.5], y in [-2.5, 2.5]
Give their variation interval

.. GENERATED FROM PYTHON SOURCE LINES 202-213

.. code-block:: Python

    inputMin4 = [-1.5, -2.5]
    inputMax4 = [1.5, 2.5]
    # Give the coordinates of the fixed input components
    centralPt = [0.0, 2.0, 2.5]
    # Specify the output marginal function
    outputMarg = 1
    # Specify the point number of the final curve
    ptNb = [101, 101]
    graph = func2.draw(inputMin4, inputMax4, ptNb)
    view = viewer.View(graph)




.. image-sg:: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_004.png
   :alt: y0 as a function of (x,y)
   :srcset: /auto_functional_modeling/field_functions/images/sphx_glr_plot_function_manipulation_004.png
   :class: sphx-glr-single-img






.. _sphx_glr_download_auto_functional_modeling_field_functions_plot_function_manipulation.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_function_manipulation.ipynb <plot_function_manipulation.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_function_manipulation.py <plot_function_manipulation.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_function_manipulation.zip <plot_function_manipulation.zip>`
