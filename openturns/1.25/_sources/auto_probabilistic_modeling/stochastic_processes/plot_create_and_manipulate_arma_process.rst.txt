
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_probabilistic_modeling/stochastic_processes/plot_create_and_manipulate_arma_process.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py:


Create and manipulate an ARMA process
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 7-9

In this example we first create an ARMA process and then manipulate it.


.. GENERATED FROM PYTHON SOURCE LINES 11-15

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as viewer
    from matplotlib import pyplot as plt








.. GENERATED FROM PYTHON SOURCE LINES 16-47

Create an ARMA process
----------------------

In this example we are going to build an ARMA process defined by its linear recurrence coefficients.

The creation of an ARMA model requires the data of the AR and MA
coefficients which are:

-  a list of scalars in the unidmensional case :
   :math:`(a_1, \dots, a_p)` for the AR-coefficients and
   :math:`(b_1, \dots, b_q)` for the MA-coefficients

-  a list of square matrix
   :math:`(\mat{A}_{\, 1}, \dots, \mat{A}{\, _p})` for the
   AR-coefficients and
   :math:`(\mat{B}_{\, 1}\, \dots, \mat{B}_{\, q})` for the
   MA-coefficients

It also requires the definition of a white noise
:math:`\vect{\varepsilon}` that contains the same time grid as the
one of the process.
The current state of an ARMA model is characterized by its last
:math:`p` values and the last :math:`q` values of its white noise. It
is possible to get that state thanks to the methods `getState`.
It is possible to create an ARMA with a specific current state. That
specific current state is taken into account to generate possible
futures but not to generate realizations (in order to respect the
stationarity property of the model).
At the creation step, we check whether the process
:math:`ARMA(p,q)` is stationnary.
When the process is not stationary, the user is warned by a message.

.. GENERATED FROM PYTHON SOURCE LINES 49-56

We build the 1-d ARMA process defined by:

.. math::
   X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}

where the white noise :math:`E_t` is defined by :math:`E_t \approx \mathrm{Triangular}(a = -1, m = 0, b = 1)`.


.. GENERATED FROM PYTHON SOURCE LINES 58-59

The definition of the recurrence coefficients ARMA (4,2) is simple:

.. GENERATED FROM PYTHON SOURCE LINES 59-63

.. code-block:: Python

    myARCoef = ot.ARMACoefficients([0.4, 0.3, 0.2, 0.1])
    myMACoef = ot.ARMACoefficients([0.4, 0.3])









.. GENERATED FROM PYTHON SOURCE LINES 64-66

We build a regular time discretization of the interval [0,1] with 10 time steps.
We also set up the white noise distribution of the recurrence relation :

.. GENERATED FROM PYTHON SOURCE LINES 66-69

.. code-block:: Python

    myTimeGrid = ot.RegularGrid(0.0, 0.1, 10)
    myWhiteNoise = ot.WhiteNoise(ot.Triangular(-1.0, 0.0, 1.0), myTimeGrid)








.. GENERATED FROM PYTHON SOURCE LINES 70-71

We are now ready to create the ARMA-process :

.. GENERATED FROM PYTHON SOURCE LINES 71-75

.. code-block:: Python

    process = ot.ARMA(myARCoef, myMACoef, myWhiteNoise)
    print(process)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA(X_{0,t} + 0.4 X_{0,t-1} + 0.3 X_{0,t-2} + 0.2 X_{0,t-3} + 0.1 X_{0,t-4} = E_{0,t} + 0.4 E_{0,t-1} + 0.3 E_{0,t-2}, E_t ~ Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 76-101

ARMA process manipulation
-------------------------

In this paragraph we shall expose some of the services exposed by an :math:`ARMA(p,q)` object, namely :

-  its AR and MA coefficients thanks to the methods `getARCoefficients`,
   `getMACoefficients`,

-  its white noise thanks to the method `getWhiteNoise`, that contains
   the time grid of the process,

-  its current state, that is its last :math:`p` values and the last
   :math:`q` values of its white noise, thanks to the method `getState`,

-  a realization thanks to the method `getRealization` or a sample of realizations thanks to the method `getSample`,

-  a possible future of the model, which is a possible extension of
   the current state on the next :math:`n_{prol}` instants, thanks to
   the method `getFuture`.

-  :math:`n` possible futures of the model, which correspond to
   :math:`n` possible prolongations of the current state on the next
   :math:`n_{prol}` instants, thanks to the method
   `getFuture` (:math:`n_{prol}`, :math:`n`).


.. GENERATED FROM PYTHON SOURCE LINES 104-105

First we get the coefficients AR and MA of the recurrence :

.. GENERATED FROM PYTHON SOURCE LINES 105-108

.. code-block:: Python

    print("AR coeff = ", process.getARCoefficients())
    print("MA coeff = ", process.getMACoefficients())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    AR coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]
    shift = 2
    [[ 0.2 ]]
    shift = 3
    [[ 0.1 ]]

    MA coeff =  shift = 0
    [[ 0.4 ]]
    shift = 1
    [[ 0.3 ]]





.. GENERATED FROM PYTHON SOURCE LINES 109-110

We check that the white noise is the one we have previously defined :

.. GENERATED FROM PYTHON SOURCE LINES 110-114

.. code-block:: Python

    myWhiteNoise = process.getWhiteNoise()
    print(myWhiteNoise)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    WhiteNoise(Triangular(a = -1, m = 0, b = 1))




.. GENERATED FROM PYTHON SOURCE LINES 115-116

We generate a possible time series realization :

.. GENERATED FROM PYTHON SOURCE LINES 116-119

.. code-block:: Python

    ts = process.getRealization()
    ts.setName("ARMA realization")








.. GENERATED FROM PYTHON SOURCE LINES 120-121

We draw this time series by specifying the wanted marginal index (only 0 is available here).

.. GENERATED FROM PYTHON SOURCE LINES 121-128

.. code-block:: Python

    graph0 = ts.drawMarginal(0)
    graph0.setTitle("One ARMA realization")
    graph0.setXTitle("t")
    graph0.setYTitle(r"$X_t$")
    view = viewer.View(graph0)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.svg
   :alt: One ARMA realization
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 129-132

Generate a k time series
k = 5
myProcessSample = process.getSample(k)

.. GENERATED FROM PYTHON SOURCE LINES 132-138

.. code-block:: Python


    # Then get the current state of the ARMA
    # armaState = process.getState()
    # print("armaState = ")
    # print(armaState)








.. GENERATED FROM PYTHON SOURCE LINES 139-140

We draw a sample of size 6 : it is six different time series.

.. GENERATED FROM PYTHON SOURCE LINES 140-154

.. code-block:: Python

    size = 6
    sample = process.getSample(size)
    graph = sample.drawMarginal(0)
    graph.setTitle("Six realizations of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = viewer.View(graph)
    # plt.show()

    # We can obtain the current state of the ARMA process :
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)




.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.svg
   :alt: Six realizations of the ARMA process
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_002.svg
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[-0.13028]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[-0.868465]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[-0.0128748]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[0.421732]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[-0.0152444]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[0.392247]




.. GENERATED FROM PYTHON SOURCE LINES 155-156

Note that if we use the process in the meantime and ask for the current state again, it will be different.

.. GENERATED FROM PYTHON SOURCE LINES 156-169

.. code-block:: Python

    ts = process.getRealization()
    armaState = process.getState()
    print("ARMA state : ")
    print(armaState)


    # From the aforementioned `armaState`, we can get the last values of :math:`X_t` and the last values
    # of the white noise :math:`E_t`.
    myLastValues = armaState.getX()
    print(myLastValues)
    myLastEpsilonValues = armaState.getEpsilon()
    print(myLastEpsilonValues)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ARMA state : 
    X(t-4) = class=Point name=Unnamed dimension=1 values=[0.437017]
    X(t-3) = class=Point name=Unnamed dimension=1 values=[0.305822]
    X(t-2) = class=Point name=Unnamed dimension=1 values=[-0.290839]
    X(t-1) = class=Point name=Unnamed dimension=1 values=[-0.460089]
    epsilon(t-2) = class=Point name=Unnamed dimension=1 values=[-0.178082]
    epsilon(t-1) = class=Point name=Unnamed dimension=1 values=[-0.378829]
    0 : [  0.437017 ]
    1 : [  0.305822 ]
    2 : [ -0.290839 ]
    3 : [ -0.460089 ]
    0 : [ -0.178082 ]
    1 : [ -0.378829 ]




.. GENERATED FROM PYTHON SOURCE LINES 170-171

We have access to the number of iterations before getting a stationary state with

.. GENERATED FROM PYTHON SOURCE LINES 171-174

.. code-block:: Python

    Ntherm = process.getNThermalization()
    print("ThermalValue : %d" % Ntherm)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ThermalValue : 75




.. GENERATED FROM PYTHON SOURCE LINES 175-176

This may be important to evaluate it with another precision epsilon :

.. GENERATED FROM PYTHON SOURCE LINES 176-181

.. code-block:: Python

    epsilon = 1e-8
    newThermalValue = process.computeNThermalization(epsilon)
    print("newThermalValue : %d" % newThermalValue)
    process.setNThermalization(newThermalValue)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    newThermalValue : 38




.. GENERATED FROM PYTHON SOURCE LINES 182-183

An important feature of an ARMA process is the future prediction from its current state over the next  `Nit` instants, say `Nit=20`.

.. GENERATED FROM PYTHON SOURCE LINES 183-185

.. code-block:: Python

    Nit = 21








.. GENERATED FROM PYTHON SOURCE LINES 186-187

First we specify a current state `armaState` and build the corresponding ARMA process `arma` :

.. GENERATED FROM PYTHON SOURCE LINES 187-202

.. code-block:: Python

    arma = ot.ARMA(myARCoef, myMACoef, myWhiteNoise, armaState)

    # Then, we generate a possible future. The last instant was :math:`t=0.9` so the future starts at
    # :math:`t=1.0`. We represent the ARMA process with a solid line and its possible future as a dashed
    # curve.
    future = arma.getFuture(Nit)
    graph = future.drawMarginal(0)
    curve = graph.getDrawable(0)
    curve.setLineStyle("dashed")
    graph0.add(curve)
    graph0.setTitle("One ARMA realization and a possible future")
    # sphinx_gallery_thumbnail_number = 3
    view = viewer.View(graph0)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.svg
   :alt: One ARMA realization and a possible future
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_003.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 203-204

It is of course possible to generate `N` different possible futures over the `Nit` next instants.

.. GENERATED FROM PYTHON SOURCE LINES 204-208

.. code-block:: Python

    N = 6
    possibleFuture_N = arma.getFuture(Nit, N)
    possibleFuture_N.setName("Possible futures")








.. GENERATED FROM PYTHON SOURCE LINES 209-210

Here we only show the future.

.. GENERATED FROM PYTHON SOURCE LINES 210-217

.. code-block:: Python

    graph = possibleFuture_N.drawMarginal(0)
    graph.setTitle("Six possible futures of the ARMA process")
    graph.setXTitle("t")
    graph.setYTitle(r"$X_t$")
    view = viewer.View(graph)





.. image-sg:: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.svg
   :alt: Six possible futures of the ARMA process
   :srcset: /auto_probabilistic_modeling/stochastic_processes/images/sphx_glr_plot_create_and_manipulate_arma_process_004.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 218-219

Display all figures

.. GENERATED FROM PYTHON SOURCE LINES 219-220

.. code-block:: Python

    plt.show()








.. _sphx_glr_download_auto_probabilistic_modeling_stochastic_processes_plot_create_and_manipulate_arma_process.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_create_and_manipulate_arma_process.ipynb <plot_create_and_manipulate_arma_process.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_create_and_manipulate_arma_process.py <plot_create_and_manipulate_arma_process.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_create_and_manipulate_arma_process.zip <plot_create_and_manipulate_arma_process.zip>`
