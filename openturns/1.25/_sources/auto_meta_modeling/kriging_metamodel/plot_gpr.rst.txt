
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_meta_modeling/kriging_metamodel/plot_gpr.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_gpr.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_meta_modeling_kriging_metamodel_plot_gpr.py:


Gaussian Process Regression: multiple input dimensions
======================================================

.. GENERATED FROM PYTHON SOURCE LINES 7-23

In this example we are going to create an approximation of a model response using a GP model.
We consider a bidimensional function with Gaussian inputs.
Then we create a GP metamodel with a constant basis and a :class:`~openturns.SquaredExponential` covariance.

We consider the function

.. math::
   g(\vect{x}) = \cos(x_1 + x_2)


for any :math:`\vect{x} \in \Rset^2`.
We assume that :math:`X_1` and :math:`X_2` have a Gaussian distribution:

.. math::
   X_1 \sim \mathcal{N}(0,1) \textrm{ and } X_2 \sim \mathcal{N}(0,1).


.. GENERATED FROM PYTHON SOURCE LINES 25-30

.. code-block:: Python

    import openturns as ot
    import openturns.experimental as otexp
    import openturns.viewer as viewer









.. GENERATED FROM PYTHON SOURCE LINES 31-32

We define the model.

.. GENERATED FROM PYTHON SOURCE LINES 34-39

.. code-block:: Python

    dimension = 2
    input_names = ["x1", "x2"]
    formulas = ["cos(x1 + x2)"]
    model = ot.SymbolicFunction(input_names, formulas)








.. GENERATED FROM PYTHON SOURCE LINES 40-41

We generate a simple Monte-Carlo input sample and evaluate the corresponding output sample.

.. GENERATED FROM PYTHON SOURCE LINES 43-48

.. code-block:: Python

    distribution = ot.Normal(dimension)
    samplesize = 15
    x = distribution.getSample(samplesize)
    y = model(x)








.. GENERATED FROM PYTHON SOURCE LINES 49-50

Then we create a GP metamodel, using a constant trend and a squared exponential covariance model.

.. GENERATED FROM PYTHON SOURCE LINES 50-60

.. code-block:: Python

    basis = ot.ConstantBasisFactory(dimension).build()
    covarianceModel = ot.SquaredExponential([0.1] * dimension, [1.0])
    fitter = otexp.GaussianProcessFitter(x, y, covarianceModel, basis)
    fitter.run()
    fitter_result = fitter.getResult()
    algo = otexp.GaussianProcessRegression(fitter_result)
    algo.run()
    result = algo.getResult()
    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 61-63

It is not so easy to visualize a bidimensional function. In order to simplify the graphics, we consider the value of the function at the input :math:`x_{1,ref}=0.5`.
This amounts to create a :class:`~openturns.ParametricFunction` where the first variable :math:`x_1` (at input index 0) is set to :math:`0.5`.

.. GENERATED FROM PYTHON SOURCE LINES 65-69

.. code-block:: Python

    x1ref = 0.5
    metamodelAtXref = ot.ParametricFunction(metamodel, [0], [x1ref])
    modelAtXref = ot.ParametricFunction(model, [0], [x1ref])








.. GENERATED FROM PYTHON SOURCE LINES 70-72

For this given value of :math:`x_1`, we plot the model and the metamodel with :math:`x_2` from its 1% up to its 99% quantile.
We configure the X title to "X2" because the default setting would state that this axis is the first value of the parametric function, which default name is "X0".

.. GENERATED FROM PYTHON SOURCE LINES 74-87

.. code-block:: Python

    x2min = ot.Normal().computeQuantile(0.01)[0]
    x2max = ot.Normal().computeQuantile(0.99)[0]
    graph = metamodelAtXref.draw(x2min, x2max)
    graph.setLegends(["Kriging"])
    curve = modelAtXref.draw(x2min, x2max)
    curve.setLegends(["Model"])
    curve.setColors(["red"])
    graph.add(curve)
    graph.setLegendPosition("upper right")
    graph.setTitle("Sample size = %d" % (samplesize))
    graph.setXTitle("X2")
    view = viewer.View(graph)




.. image-sg:: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_001.svg
   :alt: Sample size = 15
   :srcset: /auto_meta_modeling/kriging_metamodel/images/sphx_glr_plot_gpr_001.svg
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 88-90

.. code-block:: Python

    view.ShowAll()








.. GENERATED FROM PYTHON SOURCE LINES 91-93

As we can see, the metamodel is quite accurate in this case.
The metamodel is very close to the model in the center of the domain, where the density of the input distribution is highest.


.. _sphx_glr_download_auto_meta_modeling_kriging_metamodel_plot_gpr.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_gpr.ipynb <plot_gpr.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_gpr.py <plot_gpr.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_gpr.zip <plot_gpr.zip>`
