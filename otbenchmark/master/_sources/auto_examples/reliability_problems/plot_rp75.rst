
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/reliability_problems/plot_rp75.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_reliability_problems_plot_rp75.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_reliability_problems_plot_rp75.py:


RP75 analysis and 2D graphics
=============================

.. GENERATED FROM PYTHON SOURCE LINES 7-15

The objective of this example is to present problem 75 of the BBRC.
We also present graphic elements for the visualization of the limit state surface in 2 dimensions.

This problem has two dimension and a reference probability approximately equal to $10^{-2}$.
Hence, the problem should be relatively easy to solve.
The failure domain is made of two separate sub-domains, leading to two different design points.
Hence, the FORM approximation cannot be accurate, because it systematically ignores one of them,
no matter what point is found by the optimization algorithm.

.. GENERATED FROM PYTHON SOURCE LINES 17-21

.. code-block:: Python

    import openturns as ot
    import openturns.viewer as otv
    import otbenchmark as otb








.. GENERATED FROM PYTHON SOURCE LINES 22-25

.. code-block:: Python

    problem = otb.ReliabilityProblem75()
    print(problem)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    name = RP75
    event = class=ThresholdEventImplementation antecedent=class=CompositeRandomVector function=class=Function name=Unnamed implementation=class=FunctionImplementation name=Unnamed description=[x1,x2,y0] evaluationImplementation=class=SymbolicEvaluation name=Unnamed inputVariablesNames=[x1,x2] outputVariablesNames=[y0] formulas=[3 - x1 * x2] gradientImplementation=class=SymbolicGradient name=Unnamed evaluation=class=SymbolicEvaluation name=Unnamed inputVariablesNames=[x1,x2] outputVariablesNames=[y0] formulas=[3 - x1 * x2] hessianImplementation=class=SymbolicHessian name=Unnamed evaluation=class=SymbolicEvaluation name=Unnamed inputVariablesNames=[x1,x2] outputVariablesNames=[y0] formulas=[3 - x1 * x2] antecedent=class=UsualRandomVector distribution=class=JointDistribution name=JointDistribution dimension=2 copula=class=IndependentCopula name=IndependentCopula dimension=2 marginal[0]=class=Normal name=Normal dimension=1 mean=class=Point name=Unnamed dimension=1 values=[0] sigma=class=Point name=Unnamed dimension=1 values=[1] correlationMatrix=class=CorrelationMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[1] marginal[1]=class=Normal name=Normal dimension=1 mean=class=Point name=Unnamed dimension=1 values=[0] sigma=class=Point name=Unnamed dimension=1 values=[1] correlationMatrix=class=CorrelationMatrix dimension=1 implementation=class=MatrixImplementation name=Unnamed rows=1 columns=1 values=[1] operator=class=Less name=Unnamed threshold=0
    probability = 0.00981929872154689





.. GENERATED FROM PYTHON SOURCE LINES 26-29

.. code-block:: Python

    event = problem.getEvent()
    g = event.getFunction()








.. GENERATED FROM PYTHON SOURCE LINES 30-32

.. code-block:: Python

    problem.getProbability()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    0.00981929872154689



.. GENERATED FROM PYTHON SOURCE LINES 33-34

Create the Monte-Carlo algorithm

.. GENERATED FROM PYTHON SOURCE LINES 34-39

.. code-block:: Python

    algoProb = ot.ProbabilitySimulationAlgorithm(event)
    algoProb.setMaximumOuterSampling(1000)
    algoProb.setMaximumCoefficientOfVariation(0.01)
    algoProb.run()








.. GENERATED FROM PYTHON SOURCE LINES 40-41

Get the results

.. GENERATED FROM PYTHON SOURCE LINES 41-52

.. code-block:: Python

    resultAlgo = algoProb.getResult()
    neval = g.getEvaluationCallsNumber()
    print("Number of function calls = %d" % (neval))
    pf = resultAlgo.getProbabilityEstimate()
    print("Failure Probability = %.4f" % (pf))
    level = 0.95
    c95 = resultAlgo.getConfidenceLength(level)
    pmin = pf - 0.5 * c95
    pmax = pf + 0.5 * c95
    print("%.1f %% confidence interval :[%.4f,%.4f] " % (level * 100, pmin, pmax))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of function calls = 1000
    Failure Probability = 0.0090
    95.0 % confidence interval :[0.0031,0.0149] 




.. GENERATED FROM PYTHON SOURCE LINES 53-55

Compute the bounds of the domain
--------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 57-70

.. code-block:: Python

    inputVector = event.getAntecedent()
    distribution = inputVector.getDistribution()
    X1 = distribution.getMarginal(0)
    X2 = distribution.getMarginal(1)
    alphaMin = 0.00001
    alphaMax = 1 - alphaMin
    lowerBound = ot.Point(
        [X1.computeQuantile(alphaMin)[0], X2.computeQuantile(alphaMin)[0]]
    )
    upperBound = ot.Point(
        [X1.computeQuantile(alphaMax)[0], X2.computeQuantile(alphaMax)[0]]
    )








.. GENERATED FROM PYTHON SOURCE LINES 71-76

.. code-block:: Python

    nbPoints = [100, 100]
    figure = g.draw(lowerBound, upperBound, nbPoints)
    figure.setTitle("Iso-values of limit state function")
    _ = otv.View(figure)




.. image-sg:: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_001.png
   :alt: Iso-values of limit state function
   :srcset: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 77-79

Print the iso-values of the distribution
----------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 81-83

.. code-block:: Python

    _ = otv.View(distribution.drawPDF())




.. image-sg:: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_002.png
   :alt: [X1,X2] iso-PDF
   :srcset: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 84-87

.. code-block:: Python

    sampleSize = 5000
    drawEvent = otb.DrawEvent(event)








.. GENERATED FROM PYTHON SOURCE LINES 88-91

.. code-block:: Python

    cloud = drawEvent.drawSampleCrossCut(sampleSize)
    _ = otv.View(cloud)




.. image-sg:: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_003.png
   :alt: Points X s.t. g(X) < 0.0
   :srcset: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 92-94

Draw the limit state surface
----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 96-99

.. code-block:: Python

    bounds = ot.Interval(lowerBound, upperBound)
    bounds






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Interval name=Unnamed dimension=2 lower bound=class=Point name=Unnamed dimension=2 values=[-4.26489,-4.26489] upper bound=class=Point name=Unnamed dimension=2 values=[4.26489,4.26489] finite lower bound=[1,1] finite upper bound=[1,1]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 100-104

.. code-block:: Python

    graph = drawEvent.drawLimitStateCrossCut(bounds)
    graph.add(cloud)
    _ = otv.View(graph)




.. image-sg:: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_004.png
   :alt: Limit state surface
   :srcset: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 105-108

.. code-block:: Python

    domain = drawEvent.fillEventCrossCut(bounds)
    _ = otv.View(domain)




.. image-sg:: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_005.png
   :alt: Domain where g(x) < 0.0
   :srcset: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_005.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 109-112

.. code-block:: Python

    domain.add(cloud)
    _ = otv.View(domain)




.. image-sg:: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_006.png
   :alt: Domain where g(x) < 0.0
   :srcset: /auto_examples/reliability_problems/images/sphx_glr_plot_rp75_006.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 113-115

Test with FORM method
---------------------

.. GENERATED FROM PYTHON SOURCE LINES 117-118

We create a NearestPoint algorithm

.. GENERATED FROM PYTHON SOURCE LINES 118-127

.. code-block:: Python

    nearestPointAlgorithm = ot.Cobyla()
    # Resolution options:
    eps = 1e-3
    nearestPointAlgorithm.setMaximumCallsNumber(1000)
    nearestPointAlgorithm.setMaximumAbsoluteError(eps)
    nearestPointAlgorithm.setMaximumRelativeError(eps)
    nearestPointAlgorithm.setMaximumResidualError(eps)
    nearestPointAlgorithm.setMaximumConstraintError(eps)








.. GENERATED FROM PYTHON SOURCE LINES 128-138

.. code-block:: Python

    initialNumberOfCall = g.getEvaluationCallsNumber()
    mean = distribution.getMean()
    algoFORM = ot.FORM(nearestPointAlgorithm, event, mean)
    algoFORM.run()
    resultFORM = algoFORM.getResult()
    numberOfFunctionEvaluationsFORM = g.getEvaluationCallsNumber() - initialNumberOfCall
    probabilityFORM = resultFORM.getEventProbability()
    print("Number of calls to the limit state =", numberOfFunctionEvaluationsFORM)
    print("Pf =", probabilityFORM)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of calls to the limit state = 155
    Pf = 0.007161044716104123




.. GENERATED FROM PYTHON SOURCE LINES 139-140

We create a NearestPoint algorithm

.. GENERATED FROM PYTHON SOURCE LINES 140-149

.. code-block:: Python

    nearestPointAlgorithm = ot.AbdoRackwitz()
    # Resolution options:
    eps = 1e-3
    nearestPointAlgorithm.setMaximumCallsNumber(100)
    nearestPointAlgorithm.setMaximumAbsoluteError(eps)
    nearestPointAlgorithm.setMaximumRelativeError(eps)
    nearestPointAlgorithm.setMaximumResidualError(eps)
    nearestPointAlgorithm.setMaximumConstraintError(eps)








.. GENERATED FROM PYTHON SOURCE LINES 150-153

If the mean point is used as a starting point with the `AbdoRackwitz` class, then the algorithm fails with:
*RuntimeError: InternalException : Error in Abdo Rackwitz algorithm: the gradient of the level function is zero*
In order to fix this, we just use a different starting point.

.. GENERATED FROM PYTHON SOURCE LINES 155-157

.. code-block:: Python

    startingPoint = mean + [1.0e-3] * 2








.. GENERATED FROM PYTHON SOURCE LINES 158-168

.. code-block:: Python

    initialNumberOfCall = g.getEvaluationCallsNumber()
    mean = distribution.getMean()
    algoFORM = ot.FORM(nearestPointAlgorithm, event, startingPoint)
    algoFORM.run()
    resultFORM = algoFORM.getResult()
    numberOfFunctionEvaluationsFORM = g.getEvaluationCallsNumber() - initialNumberOfCall
    probabilityFORM = resultFORM.getEventProbability()
    print("Number of calls to the limit state =", numberOfFunctionEvaluationsFORM)
    print("Pf =", probabilityFORM)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Number of calls to the limit state = 16
    Pf = 0.007148267752544499




.. GENERATED FROM PYTHON SOURCE LINES 169-171

.. code-block:: Python

    mean






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    class=Point name=Unnamed dimension=2 values=[0,0]
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 172-174

.. code-block:: Python

    g.gradient(mean)






.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <p>[[ -0 ]<br>
     [ -0 ]]</p>
    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 175-176

.. code-block:: Python

    otv.View.ShowAll()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 1.777 seconds)


.. _sphx_glr_download_auto_examples_reliability_problems_plot_rp75.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_rp75.ipynb <plot_rp75.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_rp75.py <plot_rp75.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_rp75.zip <plot_rp75.zip>`
