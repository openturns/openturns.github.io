
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/reliability_problems/plot_reliability_benchmark.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_reliability_problems_plot_reliability_benchmark.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_reliability_problems_plot_reliability_benchmark.py:


Benchmark on a given set of problems
====================================

.. GENERATED FROM PYTHON SOURCE LINES 7-10

In this example, we show how to make a loop over the problems in the benchmark.
We also show how to run various reliability algorithms on a given problem so that
we can score the methods using number of digits or performance.

.. GENERATED FROM PYTHON SOURCE LINES 12-16

.. code-block:: Python

    import openturns as ot
    import numpy as np
    import otbenchmark as otb








.. GENERATED FROM PYTHON SOURCE LINES 17-19

Browse the reliability problems
-------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 21-22

We present the BBRC test cases using the otbenchmark module.

.. GENERATED FROM PYTHON SOURCE LINES 22-27

.. code-block:: Python

    benchmarkProblemList = otb.ReliabilityBenchmarkProblemList()
    numberOfProblems = len(benchmarkProblemList)
    numberOfProblems






.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    26



.. GENERATED FROM PYTHON SOURCE LINES 28-39

.. code-block:: Python

    for i in range(numberOfProblems):
        problem = benchmarkProblemList[i]
        name = problem.getName()
        pf = problem.getProbability()
        event = problem.getEvent()
        antecedent = event.getAntecedent()
        distribution = antecedent.getDistribution()
        dimension = distribution.getDimension()
        print("#", i, ":", name, " : pf = ", pf, ", dimension=", dimension)






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    # 0 : RP8  : pf =  0.0007897927545597477 , dimension= 6
    # 1 : RP14  : pf =  0.00077285 , dimension= 5
    # 2 : RP22  : pf =  0.004207305511299618 , dimension= 2
    # 3 : RP24  : pf =  0.00286 , dimension= 2
    # 4 : RP25  : pf =  4.148566293759747e-05 , dimension= 2
    # 5 : RP28  : pf =  1.4532945550025393e-07 , dimension= 2
    # 6 : RP31  : pf =  0.003226681209587691 , dimension= 2
    # 7 : RP33  : pf =  0.00257 , dimension= 3
    # 8 : RP35  : pf =  0.00347894632 , dimension= 2
    # 9 : RP38  : pf =  0.0081 , dimension= 7
    # 10 : RP53  : pf =  0.0313 , dimension= 2
    # 11 : RP55  : pf =  0.5600144282863704 , dimension= 2
    # 12 : RP54  : pf =  0.000998 , dimension= 20
    # 13 : RP57  : pf =  0.0284 , dimension= 2
    # 14 : RP75  : pf =  0.00981929872154689 , dimension= 2
    # 15 : RP89  : pf =  0.00543 , dimension= 2
    # 16 : RP107  : pf =  2.92e-07 , dimension= 10
    # 17 : RP110  : pf =  3.19e-05 , dimension= 2
    # 18 : RP111  : pf =  7.65e-07 , dimension= 2
    # 19 : RP63  : pf =  0.000379 , dimension= 100
    # 20 : RP91  : pf =  0.000697 , dimension= 5
    # 21 : RP60  : pf =  0.0456 , dimension= 5
    # 22 : RP77  : pf =  2.87e-07 , dimension= 3
    # 23 : Four-branch serial system  : pf =  0.0022227950661944398 , dimension= 2
    # 24 : R-S  : pf =  0.07864960352514257 , dimension= 2
    # 25 : Axial stressed beam  : pf =  0.02919819462483095 , dimension= 2




.. GENERATED FROM PYTHON SOURCE LINES 40-52

.. code-block:: Python

    maximumEvaluationNumber = 1000
    maximumAbsoluteError = 1.0e-3
    maximumRelativeError = 1.0e-3
    maximumResidualError = 1.0e-3
    maximumConstraintError = 1.0e-3
    nearestPointAlgorithm = ot.AbdoRackwitz()
    nearestPointAlgorithm.setMaximumCallsNumber(maximumEvaluationNumber)
    nearestPointAlgorithm.setMaximumAbsoluteError(maximumAbsoluteError)
    nearestPointAlgorithm.setMaximumRelativeError(maximumRelativeError)
    nearestPointAlgorithm.setMaximumResidualError(maximumResidualError)
    nearestPointAlgorithm.setMaximumConstraintError(maximumConstraintError)








.. GENERATED FROM PYTHON SOURCE LINES 53-55

The FORM method
---------------

.. GENERATED FROM PYTHON SOURCE LINES 57-59

.. code-block:: Python

    problem = otb.ReliabilityProblem8()








.. GENERATED FROM PYTHON SOURCE LINES 60-62

.. code-block:: Python

    metaAlgorithm = otb.ReliabilityBenchmarkMetaAlgorithm(problem)








.. GENERATED FROM PYTHON SOURCE LINES 63-66

.. code-block:: Python

    benchmarkResult = metaAlgorithm.runFORM(nearestPointAlgorithm)
    benchmarkResult.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    'computedProbability = 0.000659887791408224\nexactProbability = 0.0007897927545597477\nabsoluteError = 0.00012990496315152373\nnumberOfCorrectDigits = 0.7838874012130279\nnumberOfFunctionEvaluations = 8\nnumberOfDigitsPerEvaluation = 0.09798592515162849'



.. GENERATED FROM PYTHON SOURCE LINES 67-69

The SORM method
---------------

.. GENERATED FROM PYTHON SOURCE LINES 71-74

.. code-block:: Python

    benchmarkResult = metaAlgorithm.runSORM(nearestPointAlgorithm)
    benchmarkResult.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    'computedProbability = 0.0007838036444007651\nexactProbability = 0.0007897927545597477\nabsoluteError = 5.989110158982603e-06\nnumberOfCorrectDigits = 2.120150844037516\nnumberOfFunctionEvaluations = 8\nnumberOfDigitsPerEvaluation = 0.2650188555046895'



.. GENERATED FROM PYTHON SOURCE LINES 75-77

The LHS method
--------------

.. GENERATED FROM PYTHON SOURCE LINES 79-82

.. code-block:: Python

    benchmarkResult = metaAlgorithm.runLHS(maximumOuterSampling=10000)
    benchmarkResult.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    'computedProbability = 0.000800000000000001\nexactProbability = 0.0007897927545597477\nabsoluteError = 1.0207245440253332e-05\nnumberOfCorrectDigits = 1.8886045874596635\nnumberOfFunctionEvaluations = 10000\nnumberOfDigitsPerEvaluation = 0.00018886045874596635'



.. GENERATED FROM PYTHON SOURCE LINES 83-85

The MonteCarloSampling method
-----------------------------

.. GENERATED FROM PYTHON SOURCE LINES 87-90

.. code-block:: Python

    benchmarkResult = metaAlgorithm.runMonteCarlo(maximumOuterSampling=10000)
    benchmarkResult.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    'computedProbability = 0.0006000000000000008\nexactProbability = 0.0007897927545597477\nabsoluteError = 0.00018979275455974687\nnumberOfCorrectDigits = 0.619233516283543\nnumberOfFunctionEvaluations = 10000\nnumberOfDigitsPerEvaluation = 6.192335162835429e-05'



.. GENERATED FROM PYTHON SOURCE LINES 91-93

The FORM - Importance Sampling method
-------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 95-98

.. code-block:: Python

    benchmarkResult = metaAlgorithm.runFORMImportanceSampling(nearestPointAlgorithm)
    benchmarkResult.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    'computedProbability = 0.0007350753178889453\nexactProbability = 0.0007897927545597477\nabsoluteError = 5.471743667080241e-05\nnumberOfCorrectDigits = 1.1593874013240713\nnumberOfFunctionEvaluations = 431\nnumberOfDigitsPerEvaluation = 0.0026899939705894924'



.. GENERATED FROM PYTHON SOURCE LINES 99-101

The Subset method
-----------------

.. GENERATED FROM PYTHON SOURCE LINES 103-106

.. code-block:: Python

    benchmarkResult = metaAlgorithm.runSubsetSampling()
    benchmarkResult.summary()





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    'computedProbability = 0.000630630000000001\nexactProbability = 0.0007897927545597477\nabsoluteError = 0.00015916275455974674\nnumberOfCorrectDigits = 0.6956716985835134\nnumberOfFunctionEvaluations = 4000\nnumberOfDigitsPerEvaluation = 0.00017391792464587836'



.. GENERATED FROM PYTHON SOURCE LINES 107-112

The following function computes the number of correct base-10 digits
in the computed result compared to the exact result.
The `CompareMethods` function takes as a parameter a problem
and it returns the probabilities estimated by each method.
In addition, it returns the performance of these methods.

.. GENERATED FROM PYTHON SOURCE LINES 114-132

.. code-block:: Python



    def PrintResults(name, benchmarkResult):
        print("------------------------------------------------------------------")
        print(name)
        numberOfDigitsPerEvaluation = (
            benchmarkResult.numberOfCorrectDigits
            / benchmarkResult.numberOfFunctionEvaluations
        )
        print("Estimated probability:", benchmarkResult.computedProbability)
        print("Number of function calls:", benchmarkResult.numberOfFunctionEvaluations)
        print("Number of correct digits=%.1f" % (benchmarkResult.numberOfCorrectDigits))
        print(
            "Performance=%.2e (correct digits/evaluation)" % (numberOfDigitsPerEvaluation)
        )
        return [name, benchmarkResult.numberOfCorrectDigits, numberOfDigitsPerEvaluation]









.. GENERATED FROM PYTHON SOURCE LINES 133-192

.. code-block:: Python



    def CompareMethods(problem, nearestPointAlgorithm, maximumOuterSampling=10000):
        """
        Runs various algorithms on a given problem.
        """
        summaryList = []
        pfReference = problem.getProbability()
        print("Exact probability:", pfReference)
        metaAlgorithm = otb.ReliabilityBenchmarkMetaAlgorithm(problem)
        # SubsetSampling
        benchmarkResult = metaAlgorithm.runSubsetSampling()
        summaryList.append(PrintResults("SubsetSampling", benchmarkResult))
        # FORM
        benchmarkResult = metaAlgorithm.runFORM(nearestPointAlgorithm)
        summaryList.append(PrintResults("FORM", benchmarkResult))
        # SORM
        benchmarkResult = metaAlgorithm.runSORM(nearestPointAlgorithm)
        summaryList.append(PrintResults("SORM", benchmarkResult))
        # FORM - ImportanceSampling
        benchmarkResult = metaAlgorithm.runFORMImportanceSampling(
            nearestPointAlgorithm, maximumOuterSampling=maximumOuterSampling
        )
        summaryList.append(PrintResults("FORM-IS", benchmarkResult))
        # MonteCarloSampling
        benchmarkResult = metaAlgorithm.runMonteCarlo(
            maximumOuterSampling=maximumOuterSampling
        )
        summaryList.append(PrintResults("MonteCarloSampling", benchmarkResult))
        # LHS
        benchmarkResult = metaAlgorithm.runLHS()
        summaryList.append(PrintResults("LHS", benchmarkResult))
        # Gather results
        numberOfMethods = len(summaryList)
        correctDigitsList = []
        performanceList = []
        algorithmNames = []
        for i in range(numberOfMethods):
            [name, numberOfCorrectDigits, numberOfDigitsPerEvaluation] = summaryList[i]
            algorithmNames.append(name)
            correctDigitsList.append(numberOfCorrectDigits)
            performanceList.append(numberOfDigitsPerEvaluation)
        print("------------------------------------------------------------------------")
        print("Scoring by number of correct digits")
        indices = np.argsort(correctDigitsList)
        rank = list(indices)
        for i in range(numberOfMethods):
            j = rank[i]
            print("%d : %s (%.1f)" % (j, algorithmNames[j], correctDigitsList[j]))
        print("------------------------------------------------------------------------")
        print("Scoring by performance (digits/evaluation)")
        indices = np.argsort(performanceList)
        rank = list(indices)
        for i in range(len(indices)):
            j = rank[i]
            print("%d : %s (%.1e)" % (j, algorithmNames[j], performanceList[j]))
        return correctDigitsList, performanceList









.. GENERATED FROM PYTHON SOURCE LINES 193-196

.. code-block:: Python

    problem = otb.ReliabilityProblem8()
    _ = CompareMethods(problem, nearestPointAlgorithm)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Exact probability: 0.0007897927545597477
    ------------------------------------------------------------------
    SubsetSampling
    Estimated probability: 0.0004810000000000005
    Number of function calls: 4000
    Number of correct digits=0.4
    Performance=1.02e-04 (correct digits/evaluation)
    ------------------------------------------------------------------
    FORM
    Estimated probability: 0.000659887791408224
    Number of function calls: 8
    Number of correct digits=0.8
    Performance=9.80e-02 (correct digits/evaluation)
    ------------------------------------------------------------------
    SORM
    Estimated probability: 0.0007838036444007651
    Number of function calls: 8
    Number of correct digits=2.1
    Performance=2.65e-01 (correct digits/evaluation)
    ------------------------------------------------------------------
    FORM-IS
    Estimated probability: 0.0008064234778872405
    Number of function calls: 369
    Number of correct digits=1.7
    Performance=4.54e-03 (correct digits/evaluation)
    ------------------------------------------------------------------
    MonteCarloSampling
    Estimated probability: 0.0006000000000000008
    Number of function calls: 10000
    Number of correct digits=0.6
    Performance=6.19e-05 (correct digits/evaluation)
    ------------------------------------------------------------------
    LHS
    Estimated probability: 0.0
    Number of function calls: 1000
    Number of correct digits=0.0
    Performance=0.00e+00 (correct digits/evaluation)
    ------------------------------------------------------------------------
    Scoring by number of correct digits
    5 : LHS (0.0)
    0 : SubsetSampling (0.4)
    4 : MonteCarloSampling (0.6)
    1 : FORM (0.8)
    3 : FORM-IS (1.7)
    2 : SORM (2.1)
    ------------------------------------------------------------------------
    Scoring by performance (digits/evaluation)
    5 : LHS (0.0e+00)
    4 : MonteCarloSampling (6.2e-05)
    0 : SubsetSampling (1.0e-04)
    3 : FORM-IS (4.5e-03)
    1 : FORM (9.8e-02)
    2 : SORM (2.7e-01)




.. GENERATED FROM PYTHON SOURCE LINES 197-205

Remarks
-------

* We note that the FORM and SORM methods are faster, but, they do not converge to the exact proba.
* We also notice the effectiveness of the FORM-ImportanceSampling method (inexpensive method, and converges).
* The convergence of the MonteCarlo method requires a large number of simulations.
* SubsetSampling converges even if the probability is very low.



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 2.879 seconds)


.. _sphx_glr_download_auto_examples_reliability_problems_plot_reliability_benchmark.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_reliability_benchmark.ipynb <plot_reliability_benchmark.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_reliability_benchmark.py <plot_reliability_benchmark.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_reliability_benchmark.zip <plot_reliability_benchmark.zip>`
