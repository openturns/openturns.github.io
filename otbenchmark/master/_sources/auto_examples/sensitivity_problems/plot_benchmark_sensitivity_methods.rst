
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/sensitivity_problems/plot_benchmark_sensitivity_methods.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_sensitivity_problems_plot_benchmark_sensitivity_methods.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_sensitivity_problems_plot_benchmark_sensitivity_methods.py:


Benchmark sensitivity analysis methods
======================================

.. GENERATED FROM PYTHON SOURCE LINES 7-10

.. code-block:: Python

    import openturns as ot
    import otbenchmark as otb








.. GENERATED FROM PYTHON SOURCE LINES 11-17

When we estimate Sobol' indices, we may encounter the following warning messages:
```
WRN - The estimated first order Sobol index (2) is greater than its total order index ...
WRN - The estimated total order Sobol index (2) is lesser than first order index ...
```
Lots of these messages are printed in the current Notebook. This is why we disable them with:

.. GENERATED FROM PYTHON SOURCE LINES 17-19

.. code-block:: Python

    ot.Log.Show(ot.Log.NONE)








.. GENERATED FROM PYTHON SOURCE LINES 20-21

Use Borgonovo problem

.. GENERATED FROM PYTHON SOURCE LINES 21-25

.. code-block:: Python

    problem = otb.BorgonovoSensitivity()
    distribution = problem.getInputDistribution()
    model = problem.getFunction()








.. GENERATED FROM PYTHON SOURCE LINES 26-27

Exact first and total order

.. GENERATED FROM PYTHON SOURCE LINES 27-30

.. code-block:: Python

    exact_first_order = problem.getFirstOrderIndices()
    exact_total_order = problem.getTotalOrderIndices()








.. GENERATED FROM PYTHON SOURCE LINES 31-33

Saltelli estimator with Monte-Carlo sample
------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 35-37

.. code-block:: Python

    sample_size = 10000








.. GENERATED FROM PYTHON SOURCE LINES 38-41

.. code-block:: Python

    inputDesign = ot.SobolIndicesExperiment(distribution, sample_size).generate()
    outputDesign = model(inputDesign)








.. GENERATED FROM PYTHON SOURCE LINES 42-43

Compute first order indices using the Saltelli estimator

.. GENERATED FROM PYTHON SOURCE LINES 43-49

.. code-block:: Python

    sensitivityAnalysis = ot.SaltelliSensitivityAlgorithm(
        inputDesign, outputDesign, sample_size
    )
    computed_first_order = sensitivityAnalysis.getFirstOrderIndices()
    computed_total_order = sensitivityAnalysis.getTotalOrderIndices()








.. GENERATED FROM PYTHON SOURCE LINES 50-51

Compare with exact results

.. GENERATED FROM PYTHON SOURCE LINES 51-59

.. code-block:: Python

    print("Sample size : ", sample_size)
    # First order
    print("Computed first order = ", computed_first_order)
    print("Exact first order = ", exact_first_order)
    # Total order
    print("Computed total order = ", computed_total_order)
    print("Exact total order = ", exact_total_order)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Sample size :  10000
    Computed first order =  [0.18553,0.173199,0.637105]
    Exact first order =  [0.157895,0.157895,0.631579]
    Computed total order =  [0.203344,0.210474,0.620406]
    Exact total order =  [0.210526,0.210526,0.631579]




.. GENERATED FROM PYTHON SOURCE LINES 60-62

Saltelli estimator with Quasi Monte-Carlo sample
------------------------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: Python

    sample_size = 500








.. GENERATED FROM PYTHON SOURCE LINES 67-72

.. code-block:: Python

    dimension = distribution.getDimension()
    sequence = ot.SobolSequence(dimension)
    restart = True
    experiment = ot.LowDiscrepancyExperiment(sequence, distribution, sample_size, restart)








.. GENERATED FROM PYTHON SOURCE LINES 73-76

.. code-block:: Python

    inputDesign = ot.SobolIndicesExperiment(experiment).generate()
    outputDesign = model(inputDesign)








.. GENERATED FROM PYTHON SOURCE LINES 77-78

Compute first order indices using the Saltelli estimator

.. GENERATED FROM PYTHON SOURCE LINES 78-84

.. code-block:: Python

    sensitivityAnalysis = ot.SaltelliSensitivityAlgorithm(
        inputDesign, outputDesign, sample_size
    )
    first_order = sensitivityAnalysis.getFirstOrderIndices()
    total_order = sensitivityAnalysis.getTotalOrderIndices()








.. GENERATED FROM PYTHON SOURCE LINES 85-86

Compare with exact results

.. GENERATED FROM PYTHON SOURCE LINES 86-94

.. code-block:: Python

    print("Sample size : ", sample_size)
    # First order
    print("Computed first order = ", computed_first_order)
    print("Exact first order = ", exact_first_order)
    # Total order
    print("Computed total order = ", computed_total_order)
    print("Exact total order = ", exact_total_order)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Sample size :  500
    Computed first order =  [0.18553,0.173199,0.637105]
    Exact first order =  [0.157895,0.157895,0.631579]
    Computed total order =  [0.203344,0.210474,0.620406]
    Exact total order =  [0.210526,0.210526,0.631579]




.. GENERATED FROM PYTHON SOURCE LINES 95-97

Loop over the estimators
------------------------

.. GENERATED FROM PYTHON SOURCE LINES 99-105

.. code-block:: Python

    print("Available estimators:")
    estimators_list = otb.SensitivityBenchmarkMetaAlgorithm.GetEstimators()
    for sobolAlgorithm in estimators_list:
        name = sobolAlgorithm.getClassName()
        print(" - ", name)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Available estimators:
     -  SaltelliSensitivityAlgorithm
     -  MartinezSensitivityAlgorithm
     -  JansenSensitivityAlgorithm
     -  MauntzKucherenkoSensitivityAlgorithm




.. GENERATED FROM PYTHON SOURCE LINES 106-108

.. code-block:: Python

    metaSAAlgorithm = otb.SensitivityBenchmarkMetaAlgorithm(problem)








.. GENERATED FROM PYTHON SOURCE LINES 109-120

.. code-block:: Python

    print("Monte-Carlo sampling")
    for sobolAlgorithm in estimators_list:
        (
            computed_first_order,
            computed_total_order,
        ) = metaSAAlgorithm.runSamplingEstimator(sample_size)
        name = sobolAlgorithm.getClassName()
        print(name)
        print("    S = ", computed_first_order)
        print("    T = ", computed_total_order)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Monte-Carlo sampling
    SaltelliSensitivityAlgorithm
        S =  [0.199997,0.180685,0.664071]
        T =  [0.223721,0.228732,0.6502]
    MartinezSensitivityAlgorithm
        S =  [0.191903,0.173622,0.638601]
        T =  [0.2242,0.207898,0.591462]
    JansenSensitivityAlgorithm
        S =  [0.0952801,0.125079,0.615803]
        T =  [0.253686,0.237742,0.592254]
    MauntzKucherenkoSensitivityAlgorithm
        S =  [0.205369,0.314775,0.698245]
        T =  [0.220371,0.172107,0.567821]




.. GENERATED FROM PYTHON SOURCE LINES 121-134

.. code-block:: Python

    print("Quasi Monte-Carlo sampling")
    for estimator in ["Saltelli", "Martinez", "Jansen", "MauntzKucherenko"]:
        (
            computed_first_order,
            computed_total_order,
        ) = metaSAAlgorithm.runSamplingEstimator(
            sample_size, estimator=estimator, sampling_method="QMC"
        )
        name = sobolAlgorithm.getClassName()
        print(name)
        print("    S = ", computed_first_order)
        print("    T = ", computed_total_order)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Quasi Monte-Carlo sampling
    MauntzKucherenkoSensitivityAlgorithm
        S =  [0.147144,0.151326,0.624455]
        T =  [0.212622,0.209087,0.643622]
    MauntzKucherenkoSensitivityAlgorithm
        S =  [0.147601,0.150976,0.629051]
        T =  [0.210037,0.210799,0.640943]
    MauntzKucherenkoSensitivityAlgorithm
        S =  [0.151099,0.149846,0.632098]
        T =  [0.20915,0.21105,0.635553]
    MauntzKucherenkoSensitivityAlgorithm
        S =  [0.159027,0.163209,0.636338]
        T =  [0.212622,0.209087,0.643622]




.. GENERATED FROM PYTHON SOURCE LINES 135-149

.. code-block:: Python

    print("Polynomial chaos")
    sample_size = 500
    (
        computed_first_order,
        computed_total_order,
    ) = metaSAAlgorithm.runPolynomialChaosEstimator(
        sample_size_train=sample_size,
        sample_size_test=2,
        total_degree=5,
        hyperbolic_quasinorm=0.5,
    )
    print("    S = ", computed_first_order)
    print("    T = ", computed_total_order)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Polynomial chaos
        S =  [0.157895,0.157895,0.631579]
        T =  [0.210526,0.210526,0.631579]




.. GENERATED FROM PYTHON SOURCE LINES 150-152

Define the metric
-----------------

.. GENERATED FROM PYTHON SOURCE LINES 154-164

We consider the following accuracy metrics:
* the vector or log relative errors for a given index (first order or total order),
* the mean log relative error, as the mean of the LRE vector (first order or total order),
* the average mean log relative error, as the mean of the first and total order mean log relative error.

Larger LRE values are prefered.

The first order (resp. total order) mean LRE represents the mean number of digits for all components
of the first order indices (resp. total order indices).
The average mean LRE represents the mean LRE for both first and total order indices.

.. GENERATED FROM PYTHON SOURCE LINES 166-176

.. code-block:: Python

    S_LRE = ot.Point(dimension)
    T_LRE = ot.Point(dimension)
    for i in range(dimension):
        S_LRE[i] = otb.ComputeLogRelativeError(
            computed_first_order[i], exact_first_order[i]
        )
        T_LRE[i] = otb.ComputeLogRelativeError(
            computed_total_order[i], exact_total_order[i]
        )








.. GENERATED FROM PYTHON SOURCE LINES 177-180

.. code-block:: Python

    print("LRE S = ", S_LRE)
    print("LRE T = ", T_LRE)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    LRE S =  [14.7136,14.5509,15.153]
    LRE T =  [15.0349,14.8008,15.153]




.. GENERATED FROM PYTHON SOURCE LINES 181-188

.. code-block:: Python

    mean_LRE_S = sum(S_LRE) / dimension
    mean_LRE_T = sum(T_LRE) / dimension
    mean_LRE = (mean_LRE_S + mean_LRE_T) / 2.0
    print("Mean LRE S = %.2f" % (mean_LRE_S))
    print("Mean LRE T = %.2f" % (mean_LRE_T))
    print("Mean LRE = %.2f" % (mean_LRE))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Mean LRE S = 14.81
    Mean LRE T = 15.00
    Mean LRE = 14.90




.. GENERATED FROM PYTHON SOURCE LINES 189-190

The digit per point ratio measure the number of digits relatively to the sample size. A greater value is prefered.

.. GENERATED FROM PYTHON SOURCE LINES 190-192

.. code-block:: Python

    digit_per_point_ratio = mean_LRE / sample_size
    print("Digit / point = %.3e" % (digit_per_point_ratio))




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Digit / point = 2.980e-02





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.025 seconds)


.. _sphx_glr_download_auto_examples_sensitivity_problems_plot_benchmark_sensitivity_methods.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_benchmark_sensitivity_methods.ipynb <plot_benchmark_sensitivity_methods.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_benchmark_sensitivity_methods.py <plot_benchmark_sensitivity_methods.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_benchmark_sensitivity_methods.zip <plot_benchmark_sensitivity_methods.zip>`
