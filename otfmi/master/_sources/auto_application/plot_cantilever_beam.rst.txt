
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_application/plot_cantilever_beam.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_application_plot_cantilever_beam.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_application_plot_cantilever_beam.py:


Estimate the probability of a threshold excedance
=================================================

.. GENERATED FROM PYTHON SOURCE LINES 6-26

A load is applied to a cantilever beam. For construction
reasons, the beam must not exceed a bending of 30 cm. The load (F), beam
Young's modulus (E), length (L) and section modulus (I) are uncertain.

.. image:: /_static/beam.png
   :scale: 25 %
   :alt: alternate text
   :align: center

--------

See the cantilever beam model :doc:`here<../fmus/deviation>`.

--------


**What is the probability that the deviation exceeds the
threshold ?**



.. GENERATED FROM PYTHON SOURCE LINES 26-34

.. code-block:: Python


    import openturns as ot
    import otfmi
    import otfmi.example.utility
    import openturns.viewer as otv

    path_fmu = otfmi.example.utility.get_path_fmu("deviation")








.. GENERATED FROM PYTHON SOURCE LINES 35-37

We load the FMU as a :class:`~otfmi.FMUFunction` here as the event
explicitely requires a function of type :py:class:`openturns.Function`.

.. GENERATED FROM PYTHON SOURCE LINES 37-41

.. code-block:: Python

    model_fmu = otfmi.FMUFunction(
        path_fmu, inputs_fmu=["E", "F", "L", "I"], outputs_fmu="y"
    )








.. GENERATED FROM PYTHON SOURCE LINES 42-43

We test the function wrapping the deviation model on a point:

.. GENERATED FROM PYTHON SOURCE LINES 43-48

.. code-block:: Python

    point = ot.Point([3e7, 2e4, 255, 350])
    model_evaluation = model_fmu(point)[-1]
    print(f"Running the FMU: deviation = {model_evaluation}")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Running the FMU: deviation = 10.527857142857142




.. GENERATED FROM PYTHON SOURCE LINES 49-50

We define probability laws on the 4 uncertain inputs:

.. GENERATED FROM PYTHON SOURCE LINES 50-57

.. code-block:: Python


    E = ot.Beta(0.93, 3.2, 2.8e7, 4.8e7)
    F = ot.LogNormal()
    F.setParameter(ot.LogNormalMuSigma()([30.0e3, 9e3, 15.0e3]))
    L = ot.Uniform(250.0, 260.0)
    II = ot.Beta(2.5, 4.0, 310.0, 450.0)








.. GENERATED FROM PYTHON SOURCE LINES 58-72

According to the laws of mechanics, when the length L increases, the moment
of inertia I decreases.
The variables L and I are thus negatively correlated.

**We assume that the random variables E, F, L and I are dependent and
associated with a gaussian copula which correlation matrix:**

.. math::
   \begin{pmatrix}
   1 & 0 & 0 & 0 \\
   0 & 1 & 0 & 0 \\
   0 & 0 & 1 & -0.2 \\
   0 & 0 & -0.2 & 1 \\
   \end{pmatrix}

.. GENERATED FROM PYTHON SOURCE LINES 74-75

We implement this correlation:

.. GENERATED FROM PYTHON SOURCE LINES 75-86

.. code-block:: Python


    # Create the Spearman correlation matrix of the input random vector
    RS = ot.CorrelationMatrix(4)
    RS[2, 3] = -0.2

    # Evaluate the correlation matrix of the Normal copula from RS
    R = ot.NormalCopula.GetCorrelationFromSpearmanCorrelation(RS)

    # Create the Normal copula parametrized by R
    mycopula = ot.NormalCopula(R)








.. GENERATED FROM PYTHON SOURCE LINES 87-88

And we endly create the composed input probability distribution.

.. GENERATED FROM PYTHON SOURCE LINES 88-91

.. code-block:: Python

    inputDistribution = ot.ComposedDistribution([E, F, L, II], mycopula)
    inputDistribution.setDescription(model_fmu.getInputDescription())








.. GENERATED FROM PYTHON SOURCE LINES 92-93

Create the event whose probability we want to estimate:

.. GENERATED FROM PYTHON SOURCE LINES 93-101

.. code-block:: Python


    inputRandomVector = ot.RandomVector(inputDistribution)
    outputVariableOfInterest = ot.CompositeRandomVector(model_fmu, inputRandomVector)

    threshold = 30
    event = ot.ThresholdEvent(outputVariableOfInterest, ot.Greater(), threshold)
    event.setName("Deviation > %g cm" % threshold)








.. GENERATED FROM PYTHON SOURCE LINES 102-103

Parameterize and run the Monte Carlo algorithm:

.. GENERATED FROM PYTHON SOURCE LINES 103-112

.. code-block:: Python


    ot.RandomGenerator.SetSeed(23091926)  # set seed for reproducibility

    experiment = ot.MonteCarloExperiment()
    algo = ot.ProbabilitySimulationAlgorithm(event, experiment)
    algo.setMaximumOuterSampling(200)
    algo.setMaximumCoefficientOfVariation(0.2)
    algo.run()








.. GENERATED FROM PYTHON SOURCE LINES 113-114

Draw the distribution of threshold excedance probability:

.. GENERATED FROM PYTHON SOURCE LINES 114-118

.. code-block:: Python

    monte_carlo_result = algo.getResult()
    probabilityDistribution = monte_carlo_result.getProbabilityDistribution()
    graph = otv.View(probabilityDistribution.drawPDF())




.. image-sg:: /auto_application/images/sphx_glr_plot_cantilever_beam_001.png
   :alt: plot cantilever beam
   :srcset: /auto_application/images/sphx_glr_plot_cantilever_beam_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 119-120

Get the probability with which the beam deviation exceeds 30 cm:

.. GENERATED FROM PYTHON SOURCE LINES 120-124

.. code-block:: Python


    probability = monte_carlo_result.getProbabilityEstimate()
    print(f"Threshold excedance probability: {probability}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Threshold excedance probability: 0.009999999999999998




.. GENERATED FROM PYTHON SOURCE LINES 125-128

Given the uncertainties on the load applied and the beam mechanical
parameters, the beam bending has a probability of 0.01 to exceed 30 cm.
Is this probability low or not ? It depends on your context ðŸ™‚

.. GENERATED FROM PYTHON SOURCE LINES 130-131

.. code-block:: Python

    otv.View.ShowAll()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 3.727 seconds)


.. _sphx_glr_download_auto_application_plot_cantilever_beam.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_cantilever_beam.ipynb <plot_cantilever_beam.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_cantilever_beam.py <plot_cantilever_beam.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_cantilever_beam.zip <plot_cantilever_beam.zip>`
