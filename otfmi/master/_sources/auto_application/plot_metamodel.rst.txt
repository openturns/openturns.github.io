
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_application/plot_metamodel.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_application_plot_metamodel.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_application_plot_metamodel.py:


Metamodel a FMU time-dependent output
=====================================

.. GENERATED FROM PYTHON SOURCE LINES 6-36

We are interested in the evolution of an epidemic through a
population (for instance, Covid!). We have an epidemiologic model describing
the epidemic dynamics. More precisely, we focus on the evolution of the number
of people infected by the disease.

.. image:: /_static/epid.png
   :scale: 80 %
   :alt: alternate text
   :align: center

--------

See the epidemiological model :doc:`here<../fmus/epid>`.

--------


**To decrease the model simulation costs, let's create a metamodel.**

Metamodeling a model which output depends on time is a difficult problem. We
will combine two methods: Karhunen-Loeve dimension reduction should precede the Kriging metamodeling.

We will proceed the following way:

- simulate the FMU *n* times on a design of experiment,
- concentrate the information of the time-dependent output via Karhunen-Loeve,
- metamodel the Karhunen-Loeve coefficients.

The composition of the coefficients metamodel with the inverse
Karhunen-Loeve will make the global metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 38-40

Create the metamodel
++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 43-47

We load the FMU as a FMUPointToFieldFunction (see the
:doc:`tutorial<../_generated/otfmi.FMUPointToFieldFunction>`). We concentrate
on the first time unit of the epidemiological model output. The single
uncertain input of the model is the ``Ã¬nfection_rate``.

.. GENERATED FROM PYTHON SOURCE LINES 47-65

.. code-block:: Python


    import otfmi.example.utility
    import openturns as ot
    import openturns.viewer as otv

    path_fmu = otfmi.example.utility.get_path_fmu("epid")
    mesh = ot.RegularGrid(0.0, 0.05, 20)
    meshSample = mesh.getVertices()

    function = otfmi.FMUPointToFieldFunction(
        mesh,
        path_fmu,
        inputs_fmu=["infection_rate"],
        outputs_fmu=["infected"],
        start_time=0.0,
        final_time=1.0,
    )








.. GENERATED FROM PYTHON SOURCE LINES 66-69

We create a Monte-Carlo design of experiment, on which we
simulate the FMU.
The simulation inputs and outputs will be used to train the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 69-81

.. code-block:: Python


    inputLaw = ot.Uniform(0.001, 0.01)
    inputSample = inputLaw.getSample(30)
    outputFMUSample = function(inputSample)

    graph = outputFMUSample.draw().getGraph(0, 0)
    graph.setTitle("FMU simulations")
    graph.setXTitle("Time")
    graph.setYTitle("Number of infected")
    graph.setLegends([f"{line[0]:.3f}" for line in inputSample[:15]] + ["_"] * 15)
    view = otv.View(graph, legend_kw={"title": "infection rate", "loc": "upper left"})




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_001.png
   :alt: FMU simulations
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 82-83

We define a function to visualize the upcoming Karhunen-Loeve modes.

.. GENERATED FROM PYTHON SOURCE LINES 83-108

.. code-block:: Python



    def drawKL(scaledKL, KLev, mesh, title="Scaled KL modes"):
        graph_modes = scaledKL.drawMarginal()
        graph_modes.setTitle(title + " scaled KL modes")
        graph_modes.setXTitle("$x$")
        graph_modes.setYTitle(r"$\sqrt{\lambda_i}\phi_i$")
        data_ev = [[i, KLev[i]] for i in range(scaledKL.getSize())]
        graph_ev = ot.Graph()
        graph_ev.add(ot.Curve(data_ev))
        graph_ev.add(ot.Cloud(data_ev))
        graph_ev.setTitle(title + " KL eigenvalues")
        graph_ev.setXTitle("$k$")
        graph_ev.setYTitle(r"$\lambda_i$")
        graph_ev.setAxes(True)
        graph_ev.setGrid(True)
        graph_ev.setLogScale(2)
        bb = graph_ev.getBoundingBox()
        lower = bb.getLowerBound()
        lower[1] = 1.0e-7
        bb = ot.Interval(lower, bb.getUpperBound())
        graph_ev.setBoundingBox(bb)
        return graph_modes, graph_ev









.. GENERATED FROM PYTHON SOURCE LINES 109-112

We compute the Karhunen-Loeve decomposition of the model outputs.
The underlying assumption is that these outputs are realizations of a
stochastic process.

.. GENERATED FROM PYTHON SOURCE LINES 112-118

.. code-block:: Python


    threshold = 0.0001
    algoKL = ot.KarhunenLoeveSVDAlgorithm(outputFMUSample, threshold)
    algoKL.run()
    resultKL = algoKL.getResult()








.. GENERATED FROM PYTHON SOURCE LINES 119-120

Let be curious and plot the Karhunen-Loeve modes:

.. GENERATED FROM PYTHON SOURCE LINES 120-125

.. code-block:: Python

    phi_Y = resultKL.getScaledModesAsProcessSample()
    lambda_Y = resultKL.getEigenvalues()
    graph_modes_Y, graph_ev_Y = drawKL(phi_Y, lambda_Y, mesh, "Y")
    view = otv.View(graph_modes_Y)




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_002.png
   :alt: Y scaled KL modes
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 126-128

Now that Karhunen-Loeve algorithm is trained, we can project them
in the smaller-dimension space:

.. GENERATED FROM PYTHON SOURCE LINES 128-132

.. code-block:: Python

    projectionSample = resultKL.project(outputFMUSample)
    n_mode = projectionSample.getDimension()
    print(f"Karhunen-Loeve projection in dimension {n_mode}")





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Karhunen-Loeve projection in dimension 3




.. GENERATED FROM PYTHON SOURCE LINES 133-136

We keep on following our road map, by metamodeling the projection
of the curves on the smaller-dimension space.
We metamodel the Karhunen-Loeve coefficients using ordinary Kriging.

.. GENERATED FROM PYTHON SOURCE LINES 136-149

.. code-block:: Python

    dim = inputSample.getDimension()  # only 1 input dimension
    univb = ot.ConstantBasisFactory(dim).build()  # univariate basis
    coll = [ot.AggregatedFunction([univb.build(i)] * n_mode) for i in range(univb.getSize())]
    basis = ot.Basis(coll)  # multivariate basis
    covarianceModel = ot.SquaredExponential(dim)
    covarianceModel = ot.TensorizedCovarianceModel([covarianceModel] * n_mode)


    algo = ot.KrigingAlgorithm(inputSample, projectionSample, covarianceModel, basis)
    algo.run()
    result = algo.getResult()
    metamodel = result.getMetaModel()








.. GENERATED FROM PYTHON SOURCE LINES 150-152

We have created all pieces for a "PointToField" metamodel. Let put these
pieces together:

.. GENERATED FROM PYTHON SOURCE LINES 152-161

.. code-block:: Python



    def globalMetamodel(sample):
        emulatedCoefficients = metamodel(sample)
        restoreFunction = ot.KarhunenLoeveLifting(resultKL)
        emulatedProcessSample = restoreFunction(emulatedCoefficients)
        return emulatedProcessSample









.. GENERATED FROM PYTHON SOURCE LINES 162-164

Validate the metamodel
++++++++++++++++++++++

.. GENERATED FROM PYTHON SOURCE LINES 167-169

We create a new Monte-Carlo design of experiment. On this design of
experiment, the FMU is simulated as well as the metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 169-174

.. code-block:: Python


    inputTestSample = inputLaw.getSample(10)
    outputFMUTestSample = function(inputTestSample)
    outputMetamodelTestSample = globalMetamodel(inputTestSample)








.. GENERATED FROM PYTHON SOURCE LINES 175-176

First, we have a visual check:

.. GENERATED FROM PYTHON SOURCE LINES 176-195

.. code-block:: Python


    gridLayout = ot.GridLayout(1, 2)

    graph1 = outputFMUTestSample.draw().getGraph(0, 0)
    graph1.setTitle("FMU simulations")
    graph2 = outputMetamodelTestSample.draw().getGraph(0, 0)
    graph2.setTitle("Metamodel")

    for graph in [graph1, graph2]:
        graph.setXTitle("Time")
        graph.setYTitle("Number of infected")
        graph.setLegends([f"{line[0]:.3f}" for line in inputSample[:10]])

    gridLayout.setGraph(0, 0, graph1)
    gridLayout.setGraph(0, 1, graph2)
    view = otv.View(
        gridLayout, legend_kw={"title": "infection rate", "loc": "upper left"}
    )




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_003.png
   :alt: , FMU simulations, Metamodel
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_003.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 196-197

We validate the pertinence of Karhunen-Loeve decomposition:

.. GENERATED FROM PYTHON SOURCE LINES 197-203

.. code-block:: Python


    validationKL = ot.KarhunenLoeveValidation(outputFMUTestSample, resultKL)
    graph = validationKL.computeResidualMean().draw()
    graph.setYTitle("infected residual mean")
    ot.Show(graph)




.. image-sg:: /auto_application/images/sphx_glr_plot_metamodel_004.png
   :alt: KL residual mean - 0 marginal
   :srcset: /auto_application/images/sphx_glr_plot_metamodel_004.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 204-206

As the epidemiological model considers a population size of 700, the residual
mean error on the field is acceptable.

.. GENERATED FROM PYTHON SOURCE LINES 208-210

We validate the Kriging (using the Karhunen-Loeve coefficients of the test
sample):

.. GENERATED FROM PYTHON SOURCE LINES 210-219

.. code-block:: Python


    projectFunction = ot.KarhunenLoeveProjection(resultKL)
    coefficientSample = projectFunction(outputFMUTestSample)
    predictions = metamodel(inputTestSample)

    validation = ot.MetaModelValidation(coefficientSample, predictions)
    Q2 = validation.computeR2Score()[0]
    print(Q2)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    0.9999949331018687




.. GENERATED FROM PYTHON SOURCE LINES 220-224

The predictivity factor is very close to 1, which is satisfying.
Further statistical tests exist in
`OpenTURNS <http://openturns.github.io/openturns/master/contents.html>`_ to
assert the quality of the obtained metamodel.

.. GENERATED FROM PYTHON SOURCE LINES 226-237

----------------------

The ``globalMetamodel`` (computationnally faster than the FMU) created with
the above script can now be used as a computationnally much cheaper
substitute to the FMU for

- `sensitivity analysis <openturns.github.io/openturns/latest/auto_reliability_sensitivity/index.html#sensitivity-analysis>`_,
- `parameter inference <openturns.github.io/openturns/latest/auto_calibration/index.html#bayesian-calibration>`_,
- `estimate a failure probability <openturns.github.io/openturns/latest/auto_reliability_sensitivity/index.html#reliability>`_,

etc.

.. GENERATED FROM PYTHON SOURCE LINES 240-241

.. code-block:: Python

    otv.View.ShowAll()








.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.728 seconds)


.. _sphx_glr_download_auto_application_plot_metamodel.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_metamodel.ipynb <plot_metamodel.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_metamodel.py <plot_metamodel.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_metamodel.zip <plot_metamodel.zip>`
